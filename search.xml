<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[这书能让你戒烟]]></title>
    <url>%2F2020%2F06%2F30%2F%E8%BF%99%E4%B9%A6%E8%83%BD%E8%AE%A9%E4%BD%A0%E6%88%92%E7%83%9F-8-14%2F</url>
    <content type="text"><![CDATA[第8章 什么是戒断反应？&emsp;&emsp;我已经解释过，吸烟者认为吸烟是一种享受，能帮他们放松，或是能起到别的什么正面作用。这是一种错觉，吸烟的真正作用是对尼古丁戒断症状的暂时缓解。&emsp;&emsp;过去，吸烟曾经是社会地位的标志。不过，那样的时代早已一去不复返。如今，我们的潜意识整天都在接受暗示：在恰当的时机点上一支烟是一种享受。 &emsp;&emsp;你的毒瘾越深，对尼古丁的需求就越大。你越是困在吸烟的陷阱中不能自拔，就越相信吸烟其实是件好事。这一切都是悄悄发生的，你完全意识不到。每一天，你的感觉似乎和前一天并无不同。绝大多数吸烟者根本意识不到尼古丁毒瘾的存在，直到尝试戒烟的那一刻为止。就算意识到了，许多人也不会承认。少数死硬分子则采取鸵鸟般的态度，把头埋在沙子里自欺欺人，努力让自己和别人相信吸烟其实是一种享受。&emsp;&emsp;我曾与上百名青少年进行过这样的对话： &emsp;&emsp;我：你知道尼古丁是一种毒品 ，你吸烟的唯一原因是没办法停下来。 &emsp;&emsp;青少年：才不是呢！我喜欢吸烟。要不然我会停下来的。 &emsp;&emsp;我：那么你先停一个星期，向我证明这一点，好不好？ &emsp;&emsp;青少年：没有必要。我很享受吸烟的感觉。只要我想停下来，随时都可以。 &emsp;&emsp;我：先停一个星期，向你自己证明这一点。 &emsp;&emsp;青少年：何必呢？我是真的喜欢吸烟。 &emsp;&emsp;我已经说过，在压力、无聊、集中注意、放松等情况下，吸烟者会特别倾向于缓解戒断反应。接下来的几章将会详细讨论这一点。 第9章吸烟能释放压力？&emsp;&emsp;在这里，“压力”一词主要指生活中琐碎小事造成的压力——社交 、接电话、抚育小孩，等等。 &emsp;&emsp;以接电话为例。对大多数人来说，接电话是一件有压力的事情，对于商界人士尤为如此。绝大多数电话并不是满意的客户打来的，更不是老板专门打来夸奖你。电话铃声通常意味着某些事情并不顺利，不是什么东西出了问题，就是什么人提出了更多的要求。每逢这种情况，吸烟者都会先点起一支烟，再拿起话筒。他自己并不清楚这样做的原因，但是压力程度似乎的确减轻了。 &emsp;&emsp;实际上究竟发生了什么？吸烟者之前已经承受了一定的压力（尼古丁戒断症状），虽然他自己并没有意识到。在电话铃声造成压力时，如果通过吸烟缓解戒断症状造成的压力，吸烟者承受的总体压力就会下降，这并不是幻觉，而是千真万确的事实。不过，即使在吸烟过程中，比起相同状态的非吸烟者，吸烟者仍然承受着更大的压力。 &emsp;&emsp;我已经说过，这本书的内容不涉及冲击疗法。以下的例子并不是故意对你造成惊吓，只是为了强调，吸烟会摧毁你的意志。 &emsp;&emsp;“如果所有吸烟者都能抱着开放的心态读完这本书，所有的烟草公司都会倒闭，无数人的生活都会变得快乐得多。” ——卡罗尔?安妮?F &emsp;&emsp;假设你的烟瘾已经非常严重，医生告诉你如果不戒烟的话，他不得不手术切除你的双腿。假设他说的是实话，想象一下没有了双腿，你的生活会变成什么样子。再假设有这样一个人，尽管接到了如此的警告，仍然继续吸烟，直到双腿被切除为止。 &emsp;&emsp;我还是个烟鬼时，就曾听过许多类似的说法，每次都不屑一顾。我倒是很希望能有个医生对我这样说，那样我就能成功戒烟了。不过事实上，当时我完全清楚，我每一天都有可能因吸烟引发的脑溢血而死亡，那样损失的就不仅仅是双腿，还有更宝贵的生命。我并不认为自己疯了，只是烟瘾很重而已。 &emsp;&emsp;方才的假设并不是空穴来风。事实上，尼古丁对你身体的损害，几乎比失去双腿更加严重。随着烟瘾逐渐加深，你的意志和勇气也在悄悄流失。越是这样，你就越认为吸烟有助于提高意志和勇气，从而在烟瘾中陷得更深。许多吸烟者夜间外出时都会神经紧张，因为他们担心口袋里的香烟抽完。非吸烟者绝对不会这样。紧张感是尼古丁造成的。吸烟不仅会摧毁你的意志，还会毒害你的身体，让你的健康每况愈下。随着吸烟者的烟瘾越来越重，最终威胁到生命，他的误解也越来越深，对“吸烟能提供勇气”的说法深信不疑。 &emsp;&emsp;要看清问题的本质：吸烟并不会帮你放松，只会逐渐摧毁你的意志。戒烟可以帮你恢复意志力和自信。 第10章吸烟是因为无聊吗？&emsp;&emsp;如果你现在正在吸烟的话，很可能你根本没意识到自己嘴里的烟卷，直到看见这句话。 &emsp;&emsp;关于吸烟的另一种错误观念是，吸烟能够缓解无聊。无聊是一种精神状态。当你吸烟时，你的头脑并不会反复强调“我正在吸烟，我正在吸烟。”只有当你长时间没有烟抽，或是尝试戒烟时，才会真正意识到吸烟这件事情的存在。 &emsp;&emsp;真实情况是这样的：当你已经染上尼古丁毒瘾，而又没有吸烟时，就会产生戒断反应。如果你的注意力被某种东西吸引，同时又没有承受外来的压力，你通常不会有任何感觉。不过，当你无聊时，注意力就会自然而然地集中在戒断症状的感觉上，于是你就开始吸烟。而如果你没有戒烟欲望 的话，点烟的过程几乎是下意识的，即使对于抽烟斗和自制烟卷的人也是如此。绝大多数吸烟者无论怎么回忆，也想不起一天中的每根烟究竟是何时抽的，最多只能回忆起一小部分——比如早晨或者饭后的第一支烟。 &emsp;&emsp;“尼古清公司的一位代表曾对我说，按亚伦?卡尔的方法戒烟的人很容易分辨，因为戒烟真的能让他们感到开心。” ——尤娜?M &emsp;&emsp;事实上，吸烟是无聊的间接原因之一，因为尼古丁会引发嗜睡感，让吸烟者倾向于远离需要付出精力的活动，维持无所事事的无聊状态。 &emsp;&emsp;所以，必须根除“吸烟能缓解无聊”的错误观念。因为我们从小接受洗脑，认为吸烟能缓解无聊，所以当吸烟者在无聊时开始吸烟时，我们并不会感觉到惊讶。洗脑还让我们认为口香糖有助于放松。事实上，磨牙是人们承受压力时的自然反应。口香糖唯一的作用，就是给你一个磨牙的正当理由。下次你看到有人嚼口香糖时，仔细观察他的精神状态，看他究竟是紧张还是放松。无聊的吸烟者即使点起一支烟，精神状态仍旧很无聊，因为吸烟完全没有缓解无聊的作用。 &emsp;&emsp;身为一个曾经的烟鬼，我可以向你担保，一根接一根点燃香烟，每天重复这样的过程，是全世界最无聊的事情。 第11章 吸烟与注意力问题&emsp;&emsp;“吸烟有助于集中注意力”的说法，只不过是又一种误会。 &emsp;&emsp;需要集中注意力时，你会自动忽略其他感觉，如周围温 度的高低等。当一个吸烟者需要集中注意力时，因为“吸烟有助于集中注意力”的说法，他会点起一支烟，然后立即忽略自己正在吸烟的事实。 &emsp;&emsp;吸烟并不能帮你集中注意力，只会适得其反，因为香烟一熄灭，尼古丁戒断症状就会迅速浮现，逼你不得不分心，再点上一支烟。 &emsp;&emsp;此外，吸烟还会以另一种方式导致注意力分散。香烟中的毒素会使血液携氧能力下降，从而导致大脑供氧不足，使你难以集中注意力。 &emsp;&emsp;我自己使用意志法戒烟时，就是因为相信吸烟有助于集中注意力，才导致了最终的失败。不适感我可以忍受，但每当需要集中注意力的时候，我都非点上一支烟不可。我还记得，当初参加会计师认证考试时，考场不允许吸烟的规定让我几近抓狂。当时我已经染上了严重的烟瘾，觉得一连三个小时不吸烟的话，根本不可能专心思考。然而真正到了考场上，我全神贯注于答题，完全无暇考虑吸烟的事。那次考试我的成绩相当不错。 &emsp;&emsp;吸烟者在戒烟期间，之所以会感觉注意力难以集中，并不是戒断症状的原因。吸烟者遇上难以解决的问题时，就会习惯性地点上一支烟，尽管这对解决问题并没有任何帮助。吸烟者不会把任何问题归罪于香烟。他们认为自己不是因吸烟伤肺而咳嗽，只是经常感冒而已。然而一旦他们决定戒烟，却会把生活中的所有不如意归罪于戒烟这件事情。如果他们碰上难以解决的问题，就会想：“要是我点支烟的话，问题一定会迎刃而解。”这样他们就会开始质疑戒烟的决定。 &emsp;&emsp;如果你相信吸烟有助于集中注意力，担心戒烟会影响注意力，那么影响你注意力的其实是担心本身。问题的根源在于心态，而不是生理层面的戒断症状。记住：只有吸烟者才会出现戒断症状。 &emsp;&emsp;我最终成功戒烟时，每天的吸烟量从100支瞬间下降到0，对注意力并没有任何影响。 第12章 吸烟可以让人放松？&emsp;&emsp;绝大多数吸烟者相信吸烟有助于放松。事实上，尼古丁具有兴奋作用，会导致心率上升。 &emsp;&emsp;许多吸烟者都喜欢饭后点上一支烟。饭后是休息的时间，没有工作压力，也没有饥饿的折磨，可以全心全意放松。不幸的是，吸烟者无法利用这段时间放松，因为他还有另一种“饥饿”需要满足。他以为“饭后一支烟，赛过活神仙”，殊不知：让他无法放松的原因正是吸烟。 &emsp;&emsp;尼古丁上瘾者永远无法彻底的放松，而且毒瘾越深，程度就越严重。 &emsp;&emsp;世界上最不容易放松的人，可能就是有严重烟瘾的企业高层人员。他们连续吸烟，永远都在咳嗽，血压很高，而且很容易受刺激。到了这种程度，吸烟已经无法完全缓解尼古丁戒断反应了。 &emsp;&emsp;我还记得，当我还是个烟鬼时，如果家里哪个孩子做错了什么事，哪怕是很轻微的小事，我也会大发雷霆。当时我以为这是自己性格的缺陷，但现在我明白了，这其实是尼古丁的作用。当时我觉得整个世界天昏地暗，但现在回忆起来，那时承受的压力其实并不大。我能够控制生活的每个方面，唯一不能控制的就是吸烟。正是吸烟造就了我的恶劣脾气。吸烟者为吸烟行为寻找借口时，总是会说“哦，香烟能让我镇静下来，帮我放松”。 &emsp;&emsp;几年前，英国的收养机构曾考虑是否应禁止吸烟者收养孤儿。他们接到了一个吸烟者的电话，那人说：“你们完全搞错了。小时候，每当我有什么问题需要我母亲解决，总是等她点上一支烟，因为那时她会完全放松下来。”那么，在他母亲不吸烟时，他为什么无法同她交 流？为什么吸烟者不抽烟就无法放松？仔细观察他们的表现，尤其是没办法吸烟的时候，你会发现，他们有的把手放在嘴上，有的大拇指扭在一起，有的玩弄头发，有的磨牙，有的双脚乱动，总之都无法保持安静。他们早就忘了真正放松的滋味。 &emsp;&emsp;人们吸烟的过程，可以比作苍蝇被困在捕蝇草中的过程。最初是苍蝇吮吸捕蝇草的汁液，然后不知不觉间，就变成捕蝇草消化苍蝇了。 &emsp;&emsp;你难道不该早点挣脱捕蝇草的束缚吗？ 第13章 什么是综合性吸烟？&emsp;&emsp;不要单按字面意思，把综合性吸烟理解为同时抽两支烟甚至更多。曾经有一次，我嘴里叼着烟的时候就试图开始抽另一支烟，结果烫伤了手背。事实上，如果有人真的同时抽两支烟，那他的动机并不是不可理解。随着烟瘾的加深，戒断症状越来越难以缓解，普通强度的尼古丁刺激根本无法解决问题。即使嘴里正叼着烟卷，吸烟者仍然会出现戒断症状，于是会下意识地点起第二支烟。这也是许多烟瘾严重者转向其他毒品 的原因。不过，本章的主题不在于此。 &emsp;&emsp;所谓“综合性吸烟”，是指由多于一种原因导致的吸烟行为，如在社交 场合、聚会、婚礼、饭店等地吸烟。这些都属于既有压力又放松的场合，这两点看似矛盾，其实不然。任何形式的社交 都会产生压力，即使交往对象是很亲密的朋友，同时你又会觉得十分享受，彻底放松下来。 &emsp;&emsp;某些情况下，吸烟的四种诱因甚至能够并存。开车时就是这样的情况。如果你正开车离开某个让你很紧张的地方，如医院或牙医诊所，你会感觉十分放松。开车本身是一件很有压力的事情，你需要保证自己的生命安全，同时也需要集中注意力。或许你意识不到这两点因素，但它们的确存在于潜意识中。最后，如果堵车，或者在漫长的高速公路上驾驶，你就会感觉十分无聊。 &emsp;&emsp;另一个例子是打牌时的情况。玩桥牌或扑克牌时，你必须集中注意力。如果牌局有可能输掉，就会产生压力。如果你很久抓不到好牌，就会觉得无聊。而这一切都是在放松状态下进行的——打牌本身属于休闲娱乐的范畴。在牌局上，无论尼古丁戒断症状有多轻微，都会让吸烟者立即点起烟来，即使是轻度吸烟者也不例外。烟灰缸很快就塞满了烟头，牌桌周围萦绕着经久不散的烟气。如果你拍拍某个吸烟者的肩，问他是否享受这种感觉，他肯定会回答“你不是在开玩笑吧”。事实上，很多时候就是在刚刚经历过这样一夜 ，在喉咙痛和咳嗽中醒来的时候，我们才会决定戒烟。 &emsp;&emsp;考虑戒烟时，我们想得最多的通常是综合性吸烟的情况，担心如果在这样的场合不能吸烟，我们的生活会变得毫无可取之处。事实上，整件事的原理仍然相同：香烟只不过是暂时缓解了戒断反应。 &emsp;&emsp;让你感觉非抽支烟不可的，并不是香烟本身，而是当时的具体情况。如果能成功戒烟，你在这些情况下会更开心，更能抵抗压力。下一章会详细解释这一问题。]]></content>
      <categories>
        <category>这书能让你戒烟</category>
      </categories>
      <tags>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这书能让你戒烟]]></title>
    <url>%2F2020%2F06%2F30%2F%E8%BF%99%E4%B9%A6%E8%83%BD%E8%AE%A9%E4%BD%A0%E6%88%92%E7%83%9F%2F</url>
    <content type="text"><![CDATA[这书能让你戒烟 亚伦·卡尔，是一位事业有成的会计师，也是一位重度上瘾的老烟枪。长达33年的烟龄，每天100只烟，日益恶化的健康状况，使他几乎陷于绝望。1983年，他终于发现了“轻松戒烟法”，告别了烟瘾。从此，他立誓为这个世界解决吸烟问题。25年来，他通过自己的书籍和戒烟诊所，让全球1000万人成功摆脱了烟瘾的控制！ 如侵权，删帖删文请联系我 第1章：你的烟瘾比我还大吗？&emsp;&emsp;或许我应该先解释一下，我究竟有什么资格写这本书。我既不是医生，也不是心理学家，不过我认为我比他们更有资格。我的吸烟史长达33年，到了后期，我每天多则抽100支烟，少则六七十支。 &emsp;&emsp;我曾十几次尝试过戒烟，有一次甚至强忍了六个月没有犯禁。但是我并没有摆脱烟瘾，仍然会在旁边有人吸烟时情不自禁地凑上前去，想尽量多吸入一点烟气。乘火车的时候，我总是购买吸烟车厢的车票。 &emsp;&emsp;绝大多数吸烟者都会告诉自己：“我会在被烟瘾害死之前戒烟的。”烟瘾最严重的时候，我明知道自己正在迈向死亡，却完全无能为力。由于经常咳嗽，我整天都在头疼，随时都能感觉到大脑中的血管正在跳动。我是真的相信，那些脆弱的血管随时都会破裂，然后我就会因为脑溢血而死亡。即使这样，我仍然无法戒烟。 &emsp;&emsp;我一度想彻底放弃戒烟的努力，并不是因为我真的喜欢吸烟，某些吸烟者会用这样的理由欺骗自己，但我从来不会。我一直都很讨厌烟味，但我相信吸烟能帮助我放松，给我勇气和自信。每次尝试戒烟时，我总是感到非常痛苦，无法想象没有香烟的生活会是什么样子。 &emsp;&emsp;最终，妻子说服我去接受催眠治疗。我得承认，当时我对催眠疗法嗤之以鼻，因为对疗法的实际过程完全不了解，一听到“催眠”二字，想到的就是一个眼神犀利、表情陰鸷的家伙，手里拿着一个钟摆。吸烟者通常会产生的错觉，我几乎全部具备，除了一项：我并不认为自己是个意志薄弱的人。我能把握生活的每一方面，除了吸烟这一项。当时我以为催眠就是意志力的较量，尽管我不会主动抗拒（像大多数吸烟者一样，我还是真心希望摆脱烟瘾的），但也并不相信任何人能诱使我改变看法。 &emsp;&emsp;接受催眠治疗的过程似乎完全是浪费时间。催眠师要我做一些普通的事情，像举起胳膊之类。一切都并不神秘，我没有失去知觉，没有进入出神状态，至少我觉得我没有。然而疗程结束之后，我不仅停止了吸烟，而且还感觉颇为受用，即使是在戒断期间。 &emsp;&emsp;在你急忙跑去找催眠师之前，我必须澄清一个概念：催眠疗法只是一种交 流方式。如果催眠师与你交 流的是错误的信息，就不会给你任何帮助。我并不愿意批评为我治疗的催眠师，因为如果当时不去找他，我绝对活不到今天。然而，他的治疗并不是让我戒烟的决定因素，只是一个反面的刺激。我也并不反对催眠疗法；事实上，我们的诊所也将催眠疗法作为治疗方式之一。催眠是一种强大的交 流和说服工具，可以达到良好的正面效果，也可以产生毁灭性的负面效应。不要轻易接受催眠治疗，除非催眠师是由你尊敬信任的人推荐的。 &emsp;&emsp;承受烟瘾折磨的日子里，我相信我的生活离不开香烟，宁可死也不愿彻底戒烟。直到今天，仍有人会问我，我是不是偶尔会莫名其妙感到痛苦。答案是“从来没有”——情况正好相反，我现在的生活非常幸福。如果我因吸烟而死的话，临死时我是不会抱怨的。不过由于意料之外的幸运，我居然摆脱了生命中最大的梦魇，永远不用再做烟瘾的奴隶，任由自己摧毁自己的健康和生命。 &emsp;&emsp;我不是个神秘主义者，不相信魔法、秘术那一套。我接受过严谨的科学训练，所以当这一切魔法般降临在我头上时，我感到完全无法理解。我开始阅读有关催眠和吸烟的书籍，然而一切似乎都无法解释发生在我身上的奇迹：为什么成功戒烟是如此容易，而我过去却从来没有成功过？ &emsp;&emsp;我花了很长时间才考虑清楚，因为思考的顺序正好颠倒了。我无法理解的是为什么自己戒烟如此容易，而我实际上应该思考的，却是为什么大多数人戒烟如此之难——也包括过去的我在内。吸烟者对戒断期的痛苦谈之色变，但当我回忆最终戒烟的过程时，却发现自己完全没有经历过痛苦。事实上，戒断期的痛苦并不是生理层面的疼痛，而是精神层面的自我折磨。 &emsp;&emsp;如今，我把全部精力都投入帮人们戒烟的事业中，取得了不错的成绩。我曾亲自帮数千名吸烟者摆脱烟瘾。在此我必须强调：任何人的烟瘾都可以根除。我还没遇到过烟瘾比我还大的人。恐惧是让我们不断吸烟的根本原因：害怕一旦失去香烟，生活会变得缺少意义。事实与我们的恐惧恰好相反。戒烟不仅不会导致生活质量下降，还能让我们的身体更加健康，精力更加充沛，生活更加充实、更有情趣。 &emsp;&emsp;一切吸烟者都可以轻松摆脱烟瘾——包括你！你所需要做的，只不过是抱着开放的心态读完这本书。你越能理解书中的内容，戒烟的过程就越容易。即使你一句话都不理解，只要照着书中的指示去做，也可以轻松戒烟。最重要的是，你再也不会感觉到对香烟的需求了。到那时，你唯一不能理解的，就是你为什么吸了这么久的烟。 &emsp;&emsp;我必须首先提出警告，能导致轻松戒烟法失效的只有两种可能： 1.没有严格遵照指示。 &emsp;&emsp;本书中的许多指示非常绝对化，或许这会让你觉得很不舒服。比如，我会告诉你绝对不要采用减量法戒烟，或是糖果、口香糖等替代法（尤其是尼古丁替代法）。之所以这么绝对化，是因为我对这些方法十分了解。我并不否认，的确有不少人用这些方法达到了戒烟的目的，但他们成功的原因并不是方法本身。某些人甚至能在吊床 上做愛，但那绝对不是最容易的方式。这本书中的每一句话都是为了唯一的目的：让你的戒烟过程尽可能轻松，从而确保成功。 2.没有理解指示内容。 &emsp;&emsp;不要想当然。对这本书中的一切，以及你自己的观点和别人的态度，都要进行辩证思考。比如，如果你认为吸烟不过是一种习惯的话，不妨想想为什么别的习惯大多很容易改掉，然而吸烟虽然感觉并不好，代价高昂，还能引发疾病甚至死亡，却总是难以停止。 &emsp;&emsp;如果你觉得自己真的很喜欢香烟的气味，请扪心自问，生活中到底有多少东西是你更喜欢的，为什么你唯独离不开香烟，一想到戒烟就会心慌意乱？ 第2章 轻松戒烟法&emsp;&emsp;这本书的目的在于帮你进入合适的精神状态，让你的戒烟之旅变得不像攀登珠穆朗玛峰一样艰难，而是宛如乡间漫步一般轻松。戒烟之后，你不会羡慕身边的吸烟者，而是会感觉兴高采烈，仿佛大病初愈一般。在以后的生活中，每当你看到香烟都会纳闷，自己当初怎么会跟它们打那么久的交 道。看见吸烟者时，你心中只有同情，绝不会有一丝羡慕。 &emsp;&emsp;如果你是个吸烟者，并且尚未成功戒烟，那么在读完这本书之前务必保持原先的吸烟习惯。这条指示听起来似乎与主题矛盾，不过一定要严格照办。后文中我会详细解释，香烟其实对你并没有任何作用。事实上，吸烟的矛盾之一就在于，当我们点起一根香烟的时候，心里其实并不知道我们为什么要这样做。不过，让我们首先假设，无论你是否愿意，你相信自己已经染上了烟瘾。只要你相信这一点，就永远无法彻底放松或是完全集中注意力，直到点起一根烟为止。所以，在读完全书之前，不要过早尝试戒烟。在阅读的过程中，你的烟瘾会自然消退，太过着急可能会导致非常严重的后果。记住，一定要严格遵照本书中的指示。 &emsp;&emsp;“现在我知道，再没有什么东西能让我重新开始吸烟了。我永远不会再成为烟瘾的奴隶。自由 的感觉真好。” ——克莉丝?J &emsp;&emsp;20多年来的反馈信息表明，本书的读者们对这条指示意见颇大。我自己最初戒烟的时候，许多亲友也都跟风戒了烟，因为他们觉得，“要是这家伙都能行，那我也一定能。”后来，通过劝说和诱导，我逐渐让那些还没有戒烟的亲友们意识到，摆脱烟瘾是一件无比美好的事情。这本书最初出版时，我自己买下了许多本，送给那些仍然坚持吸烟的亲友。我相信，虽然书写得并不好，但是他们仍然会读，因为写书的是他们认识的人。几个月之后，我发现他们并没有读完，不禁很惊讶也很痛苦。我甚至发现，有一位和我关系最好的朋友不但没有读，还把我送他的书转手送给别人了。这让我感觉很受伤，但我那时尚未意识到，他们仍然对戒烟心存恐惧。恐惧的力量比友谊更大。我甚至差点因戒烟闹过离婚。我母亲有一次问我妻子：“你为什么不拿离婚威胁他戒烟？”妻子的回答则是：“如果我那样做，他真的会离婚的。”我不得不承认，她说的是实话：这就是恐惧的力量。现在我很清楚，许多吸烟者读不完这本书，是因为他们害怕读完之后就会远离香烟。某些人故意每天只读一行，以推迟那一刻的到来。我也清楚，许多吸烟者都是迫于亲友的压力才翻开这本书的。不妨换个角度思考：你究竟有什么可损失的？如果读完这本书之后你选择继续吸烟，那你的情况同过去并不会有什么区别。你不仅没什么可损失的，而且还有可能收获许多东西！ &emsp;&emsp;“我从来没有幻想过，我居然会主动想要放弃吸烟——而且在读完这本书之前，还必须故意压抑这种想法！” ——瑞切尔?C &emsp;&emsp;一个例外是，如果你已经一段时间没有抽烟了，并且不知道自己究竟算是个吸烟者，戒烟成功者还是非吸烟者，那么在阅读过程中请不要吸烟。事实上，如果你已经成功戒烟的话，这本书的任务就非常简单了：把你从一个普通的非吸烟者变成一个快乐的非吸烟者。 &emsp;&emsp;我的方法与普通的戒烟法原理正好相反。普通的方法是把戒烟的所有坏处列出来，然后告诉自己：“如果我能忍受足够长的时间，烟瘾就会最终消退。然后我就可以重新享受生活，不再做烟瘾的奴隶。” &emsp;&emsp;这的确是通常的逻辑，许多吸烟者每天都在用类似的方法尝试戒烟。不过，这样的方法很难成功，原因如下： &emsp;&emsp;1.停止吸烟并不是最重要的。每次你熄灭一支烟的时候，都算是停止了吸烟。或许你某一天会有充足的理由告诉自己“我不想再吸烟了”——所有吸烟者都曾这样告诉过自己，而且很多人的理由都比你更充足。问题在于第二天，第十天，第一万天，当你的理由不是那么充足时，如果手边碰巧有一支烟，你就会突然恢复之前的状态。 &emsp;&emsp;2.有关健康的担忧并无益处。我们的理性思维会说：“不要再这样下去了。你是个笨蛋。”但是事实上，担忧并不会帮我们戒烟，反而会使戒烟变得更难。很多人吸烟的原因是心情紧张。对吸烟者解释吸烟的危害，会让他们心情紧张，结果更加加重他们的烟瘾。伦敦皇家马斯登医院是全英国最先进的癌症治疗中心，院门前的烟头比任何一家别的英国医院都多。 &emsp;&emsp;3.除此之外，强调因吸烟的危害而戒烟，还有两重负面效应。首先，这样会制造一种感觉，戒烟似乎成了一种牺牲。你会觉得，只是为了摆脱这些危害，你才不得不牺牲吸烟的权利。其次，这样还会制造一种障碍，让我们无法理解停止吸烟的真正原因。最恰当的问题应该是：“我们为什么想要吸烟，或者需要吸烟？” &emsp;&emsp;轻松戒烟法的过程可以简单概括为：首先忘记原本的戒烟理由，然后再这样问自己： &emsp;&emsp;1.吸烟究竟有什么用？ &emsp;&emsp;2.我真的在享受吗？ &emsp;&emsp;3.我真的必须为了把烟卷叼在嘴里、让自己窒息而付钱吗？ &emsp;&emsp;事实真相是，吸烟一点用也没有。这句话绝不是说，吸烟的负面效应比正面效应要大；所有吸烟者都明白这一点。我的意思是，吸烟根本就没有正面效应。过去，吸烟还可算是高人一等的地位象征，而在今天，就连吸烟者自己也承认，吸烟是一种反社会的行为。 &emsp;&emsp;绝大多数吸烟者在吸烟时都会进行理性思考，但他们所谓的理性其实是错觉和幻想的结合。 &emsp;&emsp;我们必须消灭这些错觉和幻想。你会意识到，你其实并不需要放弃什么，因为根本没有什么可放弃的。戒烟不仅没有任何负面效应，而且有多方面的正面效应，健康只不过是其中之一。当所有的恐惧和错觉悄然消失时，当你意识到生活不会因缺少了香烟而变得更糟糕时，当你不再有任何失落感时，再回过头来考虑健康问题——以及其他传统的戒烟理由。只有这样，这些理由才会成为你的动力，推动你去追求真心想要的东西——自由 快乐的生活。 第3章 为什么戒烟如此之难？&emsp;&emsp;我已经解释过，之所以我会对戒烟发生兴趣，是因为我自己就曾是个烟鬼。我最终戒烟成功的时候，感觉相当神奇。之前我每次尝试戒烟，总是会导致长时间的抑郁，就算偶尔心情能轻松一下，第二天又会消沉下去。那种感觉就像是掉进了一个四壁光滑的坑，拼命想爬出来，却总是在看见陽光的那一刻滑回坑底。最终你会选择投降，点起一支烟卷，尽管你不知道为什么要这样。 &emsp;&emsp;在诊所时，我每次都会问来求助的吸烟者：“你愿意戒烟吗？”这似乎是个愚蠢的问题。所有吸烟者都愿意戒烟。如果你问一个烟瘾严重的人：“假如你可以回到染上烟瘾之前的时候，你还会开始吸烟吗？”他的回答必然是：“绝对不会！” &emsp;&emsp;问一个烟瘾十分严重，不相信吸烟会损害健康，不在乎其社会影响，而且完全买得起烟的人——这样的人并不多——“你鼓励你的孩子吸烟吗？”回答同样是：“绝对不会！” &emsp;&emsp;所有吸烟者都知道，吸烟并不是一件好事。最初我们的想法总是“我迟早会戒烟的，不过不是今天，等到明天再说。”最终，我们会在失望中怀疑自己的意志力，或是相信我们的生活离不开香烟。 &emsp;&emsp;我已经说过，问题不在于解释戒烟为什么很容易，而在于解释戒烟的困难。事实上，真正的问题在于解释人们为什么要吸烟，为什么在英国，最多时居然有60%的人口吸烟。 &emsp;&emsp;“我一直以为，一旦戒烟的话，我就不会像原来一样快乐和自信。你的书让我发现，戒烟之后，我会变得更快乐，更自信！” ——珍妮弗?O &emsp;&emsp;吸烟这件事情本身就是一个谜。我们之所以吸烟，是因为别人也在做同样的事情，但是所有这些吸烟者中，没人不认为吸烟是时间和金钱的浪费，没人不希望自己摆脱烟瘾。我们自己还是青少年的时候，总觉得吸烟是成年人才能享受的乐趣，所以才努力追求这种乐趣；而当我们自己成年之后，却又追悔莫及，总希望我们的孩子不要重蹈覆辙。 &emsp;&emsp;吸烟的成本相当高昂。每天吸20支烟的人，一辈子花在香烟上的钱多达10万元以上。而我们花这些钱做了什么？（要是点火把这些钱烧掉，可能还好一些。）我们花钱往自己的肺部填充致癌性的焦油，导致血液中毒，血管堵塞。我们花钱让肌肉和脏器得不到足够的氧气，令自己昏昏欲睡，提不起精神。我们花钱把自己变得肮脏不堪，满口烟臭，牙齿焦黄，浑身散发着令人讨厌的气息。我们花钱折磨自己。在不允许吸烟的场所（医院、学校、剧院、教堂、火车车厢等），我们总是痛苦不堪。而当我们离开这些场所，点起烟卷开始狂吸时，又会产生深深的负罪感。烟瘾就是这样，当我们吸烟时会觉得吸烟不对，不吸烟时又忍不住想吸。别人会认为我们低人一等，而我们自己也瞧不起自己。每当全国无烟日到来，每当接触到报纸和电视上的戒烟宣传，每当与不吸烟的人在一起，吸烟者总是会自惭形秽。承受了这么多痛苦和压力，我们又能从吸烟中得到什么？什么都没有！ &emsp;&emsp;快乐？享受？放松？激情？这些都是错觉，除非你认为故意穿上挤脚的小鞋，再把它们脱下来就算是享受！ &emsp;&emsp;我已经说过，真正的问题在于解释清楚，为什么人们要吸烟，为什么他们觉得戒烟如此之难。 &emsp;&emsp;或许你会说：“这些我都知道，但一旦染上了烟瘾，再想摆脱就难了。”但是为什么？许多吸烟者终其一生都在寻找答案，但却总是不得要领。 &emsp;&emsp;有人说，戒烟的难处在于戒断症状。其实，尼古丁的戒断症状非常轻（参见第6章），绝大多数吸烟者一辈子都意识不到自己尼古丁上瘾的事实。 &emsp;&emsp;有人说吸烟是一种享受，他们错了。吸烟者自己并不喜欢烟味。随便找个吸烟者问问，假如手边只有他不喜欢的牌子的香烟，他会不会拿来抽。如果别无他法，吸烟者甚至会把旧绳子点燃来抽。吸烟完全跟享受无关。我很享受龙虾的味道，但我绝对不会随身带着20只龙虾，就像在烟盒里塞上20支香烟一样。很多东西都能提供享受，但在我们无法享受这些东西时，却不会感觉到空虚。 &emsp;&emsp;有人试图寻找潜意识层面的原因，所谓的“弗洛伊德综合征”“复归于婴儿”之类，实际情况正好相反。绝大多数青少年开始吸烟，是为了假装成年人。如果真的在潜意识上“复归于婴儿”，我们就应该找个奶嘴来吮。 &emsp;&emsp;有人认为吞云吐雾能让鼻孔里产生火辣辣的感觉，这种感觉非常刺激，这样的理由同样站不住脚。如果火辣辣的感觉就能产生刺激，为什么不把燃烧的香烟塞进耳朵里？如果说这样做很荒唐，那把致癌性的焦油吸进肺部岂不是更荒唐？ &emsp;&emsp;有人说：“这样我手上才有事情做！”那为什么要把烟卷点燃？ &emsp;&emsp;“嘴里叼着烟的感觉很好。”为什么要把烟卷点燃？ &emsp;&emsp;“烟气进入肺部的感觉很好。”一点都不好——这种感觉又称为窒息。 &emsp;&emsp;许多人认为吸烟可以缓解无聊，这也是一种错觉。“无聊”是一种精神状态，香烟可没有任何有趣之处。 &emsp;&emsp;身为烟民的33年中，我的理由一直是，吸烟能让我放松，给我信心和勇气。我很清楚吸烟有害健康，而且成本高昂。我为什么不去医生那里，让他给我开点别的什么药物，帮我增加信心和勇气？因为我知道，他只会开出别的什么药物，绝不会让我继续吸烟。这只不过是个借口，绝谈不上理由。 &emsp;&emsp;有人说，他们吸烟是因为他们的朋友也吸。他们真的这么愚蠢吗？要是这样，他们最好现在就开始祈祷，他们的朋友不要把自己的头剁掉！ &emsp;&emsp;最终，大多数吸烟者会得出这样的结论：吸烟只不过是一种习惯。这并不算是解释，但当一切解释都无法成立的时候，这是唯一的借口。不幸的是，这种借口同样缺乏逻辑。我们的生活习惯总是在不断改变，唯独吸烟一成不变。相信吸烟是一种习惯，而习惯总是很难改，这是最大的误解。习惯真的很难改吗？在英国，我们习惯了靠左侧通行，但一旦去欧洲大陆 或者美国，我们立即就能适应过来。习惯并不难改。事实上，我们生活中的每一天都在改变旧的习惯，养成新的习惯。 &emsp;&emsp;如果说吸烟是一种习惯，那么这种感觉糟糕透顶、有害健康、浪费钱财、遭人恶心。我们全心全意想改掉的习惯，为什么偏偏改不掉？答案很简单，吸烟并不是一种习惯，而是尼古丁上瘾！ &emsp;&emsp;绝大多数吸烟者不了解毒品 上瘾的机制，所以才会觉得戒烟无比困难。他们的主要理由是，吸烟能给他们带来享受或寄托，放弃吸烟是一种牺牲。 &emsp;&emsp;而事实真相却是，一旦你理解了尼古丁上瘾的机制，以及你吸烟的真正原因，你就会停止吸烟——就这么简单——三个星期之后，你就会开始扪心自问，当初你为什么吸了那么久的烟，为什么你不能说服其他吸烟者：不吸烟的感觉多么好啊！ 第4章 险恶的陷阱&emsp;&emsp;吸烟是世上最为险恶的陷阱，是由人类和大自然共同制造的。我们为什么会在青少年时代掉进陷阱？因为有无数的成年人已经掉了进去。他们不是没有警告过我们，吸烟是一种恶心的习惯，不仅浪费金钱，最后还会要了我们的命；然而我们却把这样的警告当成耳边风，认为他们一定是把吸烟当成一种享受。吸烟的荒谬处之一就在于，要“学会”吸烟、染上烟瘾，其实并不是一件容易的事。 &emsp;&emsp;这个陷阱里并没有任何诱饵，我们并不是因为吸烟感觉良好才掉进去的，事实上第一支烟的感觉必然十分糟糕。如果第一支烟感觉良好，或许我们头脑里就会响起警钟，我们会意识到陷阱的存在。然而正因为第一支烟的感觉无比糟糕，我们才会以为自己绝不会染上烟瘾，在不知不觉中一步步走进陷阱。 &emsp;&emsp;一切毒品 都可以让人产生快感，香烟中的尼古丁是唯一的例外。男孩子开始吸烟的原因，通常是想表现出男子气概，就像屏幕上的电影 明星一样。然而当你点起第一支烟时，立刻就会忘掉所有的男子气概。你不敢吸气，一旦时间稍长，就会感到头晕目眩，然后是一阵恶心。你唯一的愿望就是离开伙伴们，把手中的香烟丢得远远的，但你却尽力克制这样的愿望。 &emsp;&emsp;女孩子开始吸烟的原因，则通常是想表现得成熟一点。我们都见过未成年的女孩子小口小口吸着香烟，一副煞有介事的样子。等到男孩子真的培养起男子气概、女孩子真正成熟的时候，他们就会后悔当初的愚蠢。我不知道，究竟是吸烟真能让女性显得成熟，还是这只是烟草公司宣传出来的效果。据我所见，从初学吸烟者到吸烟方面的“专家”，中间似乎没有任何过渡。 &emsp;&emsp;在我们的余生中，我们努力警告自己的孩子，不要重蹈我们当年的覆辙。偶尔我们也会努力尝试，想从烟瘾的陷阱中挣脱出来。 &emsp;&emsp;然而，只有当我们感觉到压力时，才会想到尝试挣脱，无论这压力是来自健康问题，家庭经济问题，还是别人的看法和态度。 &emsp;&emsp;我们一旦停止吸烟，压力不但不会减小，反倒还会进一步增加（因为尼古丁上瘾的戒断症状），而我们只习惯一种缓解压力的手段，那就是吸烟。 &emsp;&emsp;忍受了几天的痛苦折磨之后，我们开始觉得时机不对，不应该在这时候戒烟，而应该等到没有压力的那一天再进行尝试。一旦产生这样的想法，戒烟的动力就会完全消失。自然，那一天永远不会到来，因为我们总是认为，我们生活中的压力会随着时间增加。离开家长的保护之后，我们会按照常规建立自己的家庭，抵押买房，生养儿女，追求事业的发展，等等。事实上，这是一种错觉。人类一生中压力最大的时期，实际上是童年和青少年时期。“责任”与“压力”很容易混淆。事实上，吸烟者的生活压力之所以会逐渐增加，是因为吸烟并不能真的帮你放松，更不能缓解压力。情况正好相反：吸烟会让你神经紧张，增加你承受的压力。 &emsp;&emsp;吸烟者即使停止吸烟（许多人都这样做过，有的只有一次，有的有许多次），过上正常的生活，也有可能突然重新染上烟瘾。 &emsp;&emsp;吸烟这件事情仿佛是一座巨大的迷宫，我们一进入迷宫内，头脑就会变得糊里糊涂，尽管努力寻找，却总也找不到迷宫的出口。有些人幸运地找到了出口，却莫名其妙地再次误入。 &emsp;&emsp;寻找出口的过程花了我整整33年。与其他吸烟者一样，我当时并不明白个中机制。不过，由于种种幸运与巧合，我碰巧发现了真正的出口。我想知道为什么戒烟如此之难，而当我找到答案的时候，蓦然发现，其实戒烟是一件非常简单的事情。 &emsp;&emsp;成功戒烟之后，我开始努力研究烟瘾陷阱的本质。我发现，这个问题极其错综复杂，仿佛顺序被打乱的魔方一般。不过，我最终拼出了魔方的图案，答案其实十分简单！我找到了轻松戒烟的有效方法。我会手把手领你走出迷宫，让你永远不会再次误入。你需要做的事情很简单：严格遵照本书中的指示。哪怕一个小小的失误，也会导致很严重的后果。 &emsp;&emsp;任何人都可以轻松戒烟，但是首先必须知道一些事实。我并不是指吸烟的危害性。我知道你对吸烟的危害性很清楚，因为相关的宣传已经太多太多了。如果那些宣传能帮你戒烟的话，你早就戒烟成功了。我的意思是，我们为什么会认为戒烟是一件难事？要回答这个问题，我们必须首先弄清楚，我们究竟为什么要吸烟。 第5章 我们为什么要吸烟？&emsp;&emsp;我们开始吸烟的理由多种多样，然而一旦开始，我们就会一直吸下去。 &emsp;&emsp;为什么？ &emsp;&emsp;我们为什么要吸烟？ &emsp;&emsp;没有一个吸烟者知道自己吸烟的真实原因。如果他们知道，就不会再吸烟了。在我们的诊所里，我曾对数千名吸烟者问过这个问题，他们的答案千奇百怪，但都与事实相去甚远。 &emsp;&emsp;所有吸烟者内心深处其实都清楚，他们犯了一个愚蠢的错误：在染上烟瘾之前，他们原本没有任何吸烟的必要。他们几乎都能记得，第一支烟的味道无比糟糕，他们是经过痛苦的努力才“学会”吸烟的。最让他们伤心的是，不吸烟的人什么都没有缺少，并且还嘲笑他们。 &emsp;&emsp;不过，吸烟者同样是有智力、能进行理性思考的人类。他们很清楚，吸烟不仅对他们的健康造成了巨大的危害，而且也严重浪费了他们的钱财。他们需要一个合理的解释。 &emsp;&emsp;事实上，导致我们吸烟的因素只有两种，我会在接下来的两章中分别讨论。两种因素分别是： &emsp;&emsp;1.尼古丁上瘾； &emsp;&emsp;2.洗脑。 第6章 尼古丁上瘾&emsp;&emsp;尼古丁是一种无色油状物质，是导致烟瘾的元凶，也是上瘾速度最快的毒品 。许多人只须抽一根烟，就会引起尼古丁上瘾。 &emsp;&emsp;你每次吸一口烟，都会有少量的尼古丁通过肺部进入大脑，其传导和作用速度比静脉注射海洛因更快。 &emsp;&emsp;如果一支烟用了20口才吸完，那么你的大脑就会受到20次尼古丁刺激。 &emsp;&emsp;尼古丁是一种代谢奇快的毒品 。吸烟后半个小时，血液中的尼古丁含量就会下降50%，再过半个小时就会下降到25%。这就是大部分吸烟者每天吸20支烟的原因。 &emsp;&emsp;每当吸烟者抽完一支烟，血液中的尼古丁含量就会迅速下降，很快就会引发戒断症状。 &emsp;&emsp;在这里，我有必要解释清楚戒断症状的概念。吸烟者经常认为，戒烟时出现的痛苦感觉就是戒断症状。事实上，这种痛苦主要是精神上的，是吸烟者心理作用的结果。关于这一问题，下文还会详细讨论。 &emsp;&emsp;“感谢你的远见卓识和幽默感，你几乎把一切都预料到了。读这本书的时候，我有好几次都笑出声来。” ——J?桑德斯夫人 &emsp;&emsp;尼古丁本身的戒断症状十分轻微，绝大多数吸烟者一直到死都不会意识到，他们自己与吸毒者其实没有区别。我们听到“尼古丁上瘾”这个说法时，总以为我们不过是“养成了吸烟的习惯”而已。绝大多数吸烟者对毒品 都充满恐惧，却不知道尼古丁正是一种毒品 。幸运的是，尼古丁比其他毒品 更容易戒掉，不过你得首先接受自己养成毒瘾的事实。 &emsp;&emsp;尼古丁戒断并不会导致生理上的疼痛，唯一的症状是心理上的空虚感，似乎有什么东西不见了，所以许多吸烟者才认为，吸烟是为了“让手上有点事情做”——也就是排解这种空虚感。如果这种感觉长期持续，就会导致吸烟者神经紧张，没有安全感，容易激动，自信心和自制力下降。这种感觉其实是身体对尼古丁的饥渴。 &emsp;&emsp;点着香烟后七秒钟之内，吸烟者就会得到新的尼古丁供应，于是空虚感消失。吸烟者会产生放松和自信的感觉，因为这两种感觉正是他们先前所缺失的。 &emsp;&emsp;我们最初开始吸烟时，戒断症状非常轻微，几乎无法察觉。当我们开始养成经常吸烟的习惯时，由于不了解戒断症状的机制，我们会误以为自己真的喜欢上了吸烟，或是养成了“习惯”。事实真相是，我们的尼古丁毒瘾越来越重，越来越需要经常满足。 &emsp;&emsp;所有吸烟者都是因为某个愚蠢的理由才开始吸烟的。吸烟并不是一种需要。吸烟者们之所以要经常吸烟，是为了满足尼古丁毒瘾。 &emsp;&emsp;“与上一次戒烟的情况不同，我并没有做噩梦，没有失眠，也没有情绪低落。事实正好相反——我感觉仿佛重获了新生。” ——玛莎?F &emsp;&emsp;所有吸烟者内心深处都清楚，他们犯了一个愚蠢的错误，掉进了烟瘾的陷阱。最可悲的地方在于，他们误以为吸烟能给他们放松和自信的感觉，殊不知这些感觉正是被尼古丁戒断症状所剥夺的，吸烟只是暂时满足毒瘾、缓解戒断症状而已。 &emsp;&emsp;你曾经一定有过这样的感觉：如果邻居家的防盗警铃响了一整天，然后突然被关掉了，整个世界都会瞬间变得无比安宁。事实上，这并不是安宁，只不过是烦心事的终结。 &emsp;&emsp;我们的身体原本是完整的。开始吸烟之后，我们放任尼古丁进入身体，一旦烟卷吸完，体内的尼古丁含量就会迅速下降。戒断症状——不是生理上的疼痛，而是心理上的空虚感——让我们的身体不再完整，让我们渴求尼古丁的作用。我们的理性无法解释这种渴望，也完全没有必要。我们只知道自己想要再吸一支烟，一旦点燃烟卷，渴望就会自行消失。我们会恢复正常的状态，就像没有染上烟瘾前一样。不过，这种状态只是暂时的，一旦烟卷熄灭，整个周期就会重新开始，周而复始，永远没有穷尽——除非被我们主动打破。 &emsp;&emsp;我曾做过这样的比喻，吸烟就如同故意穿上挤脚的小鞋，再把它们脱下来，享受片刻的安慰。吸烟者之所以意识不到这一点，主要有三点原因： &emsp;&emsp;1.自打生下来开始，我们一直在接受别人和社会的洗脑，我们误以为吸烟者真的享受吸烟的过程，而且离不开香烟。我们为什么要怀疑这一点？如果不是这样，吸烟者为什么要冒那么大的风险、花那么多钱吸烟？ &emsp;&emsp;2.尼古丁戒断症状不会产生生理上的疼痛，只会引发心理上的空虚感，与饥饿或压力的感觉类似。所以当我们点起香烟的时候，并不会觉得有什么不妥。 &emsp;&emsp;3.吸烟者之所以意识不到吸烟的本质，最重要的原因是，戒断症状只有在不吸烟的时候才会发作。由于症状并不重，在烟瘾形成的早期尤为轻微，我们总是将之误认为正常的反应，无法把症状与之前的吸烟行为联系起来。吸烟越频繁，戒断症状就越不容易发作，我们神经紧张和信心下降的程度有所缓解，却把这种作用归结为香烟的功效。 &emsp;&emsp;一切毒品 都很难戒掉，正是因为这第三点原因。如果一个海洛因上瘾者得不到海洛因，必然会痛苦不堪。一旦他给自己注射一针海洛因，这种痛苦就会立即消除。他能从注射的过程中得到快乐吗？对于没有海洛因毒瘾的人，海洛因就不具备消除痛苦的作用，反而会引发痛苦。同样，对于不吸烟的人来说，吸烟并不能缓解尼古丁戒断症状，所以他们也无法理解，吸烟者究竟能从香烟中得到什么快乐，而吸烟者自己同样无法理解。 &emsp;&emsp;我们经常说，吸烟能帮助我们放松，让我们感到满足。但是如果没有不满足，又何来满足？如果没有紧张，又何来放松？为什么不吸烟的人就不需要这样的放松和满足？为什么吃完一顿饭之后，不吸烟的人可以直接放松下来，而吸烟者却需要点起一支烟才能让自己“放松”？ &emsp;&emsp;尽管这句话我已经说过很多次，但还是要再重复一遍：吸烟者之所以感觉戒烟很难，是因为他们以为戒烟意味着放弃很多东西。你必须明白，其实你并不需要放弃任何东西。 &emsp;&emsp;要理解尼古丁上瘾的本质，可以把吸烟与吃饭进行对比。如果我们养成按时就餐的习惯，在非用餐时间就难以察觉到饥饿。如果某一顿饭没有按时吃，我们就会感到饥饿。即使如此，我们也不会有生理上的疼痛，只有一种心理上的空虚感：“我需要吃饭。”于是，吃饭的过程就成了一种享受。 &emsp;&emsp;吸烟的原理也是这样。尼古丁戒断产生的空虚感，同饥饿的感觉几乎完全一样：同样没有生理上的疼痛，同样难以察觉——只要我们像按时就餐一样“按时”吸烟。只有当我们想吸烟却没得吸时，才会意识到空虚感的存在。只要点起一支烟，空虚感就会消失，于是吸烟的过程也仿佛成了一种享受。 &emsp;&emsp;正因为吸烟与吃饭如此相似，吸烟者们才会产生错觉，以为吸烟能带给他们真正的享受。许多吸烟者初次听到吸烟没有任何正面效应的说法时，都会觉得难以接受。有人会说：“吸烟怎么会没有正面效应？当我点起一支烟时，感觉就不会那么紧张，这还是你告诉我的。” &emsp;&emsp;尽管吸烟与吃饭有许多相似之处，但其本质则完全相反： &emsp;&emsp;1.我们吃饭是为了生存，而吸烟则会减少我们的寿命。 &emsp;&emsp;2.食物通常味道不错，吃饭的确是一种享受，而烟卷的气味非常恶心，并且吸入肺部会导致窒息。 &emsp;&emsp;3.吃饭不会导致饥饿，只会缓解饥饿。吸烟会导致身体对尼古丁产生需求，然后再为身体提供尼古丁，暂时缓解这种需求。 &emsp;&emsp;接下来，我们要讨论另一种常见的错误观念——吸烟是一种习惯。吃饭是习惯吗？如果你认为是，那么改掉这个习惯如何？把吃饭定义为习惯，如同把呼吸定义为习惯一样荒唐。二者都是生存所必需的。的确，不同人的用餐习惯和食谱不尽相同，但是每个人都需要吃饭。吃饭本身并不是习惯。吸烟也不是。吸烟者点燃香烟的目的是缓解尼古丁戒断症状，而这症状正是由吸烟导致的。的确，不同吸烟者的吸烟方式和嗜好品牌不尽相同，但是吸烟本身并不是习惯。 &emsp;&emsp;人们总是把吸烟称为习惯，在这本书里为了方便，我有时也会使用“吸烟习惯”这种说法。不过，你一定要随时意识到，吸烟绝对不是习惯，而是毒瘾的一种！ &emsp;&emsp;我们最开始尝试吸烟的时候，必须下很大努力才能“学会”。然而突然之间，我们不仅开始养成吸烟的习惯，而且离了香烟就会心烦意乱。随着时间的流逝，我们对香烟的依赖也与日俱增。 &emsp;&emsp;这是因为身体会对尼古丁产生耐受性，从而增大对尼古丁的需求。上一支烟熄灭后没多久，尼古丁戒断症状就会渐渐浮现，逼你再点起一支烟。你的感觉的确比方才要好，但相比正常状态仍然糟糕得多。吸烟比穿小鞋更为荒谬，因为即使你远离香烟，仍然会遭到戒断症状的折磨——而小鞋一脱下来就不再痛苦了。 &emsp;&emsp;之前我已经解释过，血液中尼古丁水平的下降速度非常快。正是由于这个原因，在压力较大的时候，许多吸烟者才会连续吸烟。 &emsp;&emsp;吸烟并不是一种习惯。人们吸烟的真正原因是尼古丁上瘾，必须经常接受尼古丁的刺激。在四种情况下，吸烟者最倾向于寻求尼古丁刺激，这四种情况分别是： &emsp;&emsp;无聊/集中注意——二者正好相反！ &emsp;&emsp;压力/放松——二者正好相反！ &emsp;&emsp;什么样的毒品 才能在同一个人身上起到两种相反的效果？除了这四种情况，以及睡眠状态之外，我们的生活还能处于什么状态？事实上，吸烟既不能缓解无聊或压力，也无法帮你放松，让你集中注意力。这一切都是幻觉。 &emsp;&emsp;尼古丁不仅是一种毒品 ，还是一种强力毒素，是杀虫剂的成分之一（查查辞典就知道了）。如果进行静脉注射，一支烟含有的尼古丁就足以杀死你。除尼古丁之外，吸烟还会产生多种毒素，包括一氧化碳。烟草与剧毒的颠茄是同一个属。 &emsp;&emsp;这本书虽然常提到“香烟”，但其内容涵盖了烟草的所有使用方式，如烟斗、雪茄、嚼烟等，以及尼古丁的所有摄入方式，如口香糖、贴膏、喷雾剂等。 &emsp;&emsp;人是地球上最复杂的生物体之一，但即使最简单的生物体，比如单细胞生物，也不可能在混淆食物与毒素的情况下生存。 &emsp;&emsp;经过千百万年来的自然选择，我们的头脑和身体已经形成了一整套机制，可以有效分辨食物与毒素，确保万无一失。 &emsp;&emsp;任何人都讨厌烟味，直到染上烟瘾为止。如果把烟气喷到婴儿或者动物的脸上，他/它就会剧烈咳嗽。 &emsp;&emsp;我们自己吸进第一口烟的时候，也必然会导致咳嗽，如果第一次吸得太多，还会出现头晕、恶心等反应。这就是我们的身体在表达“你把毒素当成食物了！快停下来！”的意思。对这种反应的态度，通常会决定我们是否染上烟瘾。认为只有意志薄弱的人才会染上烟瘾，这其实是错误的。意志薄弱的人其实通常是幸运的，因为他们无法忍受第一支烟的感觉；他们的肺部无法承受烟气引起的窒息感，所以他们一辈子都不会吸烟。或者，他们心理上无法接受吸烟造成的痛苦，所以也不会再次尝试。 &emsp;&emsp;对我来说，需要下很大努力才能“学会”吸烟的事实，是最大的悲剧之一。正是因为这一点，青少年的吸烟行为才难以阻止。他们仍处于“学习 ”阶段，仍然感到烟味无法忍受，所以才会以为他们随时都可以停下来。他们为什么不吸取我们的教训？而我们又为什么不吸取上一代人的教训？ &emsp;&emsp;许多吸烟者认为自己的确喜欢烟味，这其实是一种幻觉。我们“学习 ”吸烟时，其实是在强迫身体适应糟糕的烟味。海洛因上瘾者也认为自己的确喜欢注射海洛因的感觉，然而事实却是，海洛因的戒断症状更为痛苦，他们喜欢的是缓解痛苦的感觉。 &emsp;&emsp;如果哪个吸烟者相信，他只是因为喜欢烟味才吸烟，你可以这样问他：“假如手边没有你平时抽的香烟牌子，只有你不喜欢的牌子，你会不会拿来抽？”他当然会的。如果别无选择，他甚至会把旧绳子点燃来抽，更别说薄荷烟卷、雪茄和烟斗了。无论是感冒、流感、喉咙痛、气管炎还是肺气肿，都无法阻止吸烟者点上一支烟。 &emsp;&emsp;这一切完全与享受无关。如果追求享受的话，任何人吸过第一支烟之后都不会再次尝试。不少所谓的戒烟者甚至会对尼古丁口香糖上瘾。 &emsp;&emsp;许多吸烟者意识到吸烟其实是一种毒瘾时，都觉得问题更严重了，戒烟会变得更加困难。事实上，知道这一点绝不是坏事，原因有两条： &emsp;&emsp;1.绝大多数人吸烟的原因是，尽管知道吸烟弊大于利，但他们相信吸烟是一种享受。他们认为戒烟是放弃这种享受的过程，会给他们的生活造成损失。这是一种错觉。吸烟无法提供任何享受，只能先制造痛苦，然后再部分缓解痛苦，造成享受的假象。后文中，我会详细解释这一机制。 &emsp;&emsp;2.尽管尼古丁是上瘾速度最快的毒品 ，但是上瘾程度并不会很严重。由于尼古丁的作用速度很快，只消三个星期不吸烟，你体内99%以上的尼古丁就会排出体外，而且实质性的戒断症状非常轻微，绝大多数吸烟者甚至终生意识不到。 &emsp;&emsp;你自然会问，为什么许多人即使强制戒烟几个月，仍然会感觉到对香烟的渴望？原因就是下一章的主题——社会对人们的洗脑。单是生化层面的上瘾症状，其实很容易对付。 &emsp;&emsp;绝大多数吸烟者睡觉时都不会吸烟，而戒断症状甚至不会把他们弄醒。 &emsp;&emsp;许多吸烟者起床 后并不会立即点燃香烟，而是会先吃早饭，甚至先上班工作。睡眠时，他们可以轻松忍受10个小时的戒断症状，但在白天，10个小时不吸烟却会让他们抓狂。 &emsp;&emsp;许多吸烟者买了新车之后，都会忍住不在车里吸烟。他们会花几个小时看电影 、逛超市、乘坐地铁，尽管这些地方禁止吸烟，对他们也没什么影响。事实上，偶尔有这样的机会可以不用吸烟，他们甚至会非常高兴——只要不是永远禁止吸烟就好。 &emsp;&emsp;今天，绝大多数吸烟者在非吸烟者的家中或聚集场所都不会吸烟，而且不会感到任何不便。事实上，绝大多数吸烟者都有过较长时间远离香烟，却没有任何不适的经历。我自己当年还是个烟鬼时，从来不在晚上吸烟。烟瘾最严重的那几年，我甚至常常期待着晚上到来，这样我就可以不用让自己窒息（真是个荒谬的“习惯”）。 &emsp;&emsp;总之，生化层面的尼古丁上瘾症状很容易对付。许多吸烟者一辈子都只是偶尔抽支烟。他们的上瘾程度并不比地道的烟鬼轻多少。许多吸烟者在戒掉香烟之后，偶尔会来上一支雪茄，这样会维持他们的尼古丁上瘾症状，然而他们的烟瘾却并不一定会复发。 &emsp;&emsp;单纯的尼古丁上瘾绝不是主要的问题，只会起到催化剂的作用，让我们意识不到问题的真正所在：社会的洗脑作用。 &emsp;&emsp;即使是吸烟程度十分严重的烟鬼，戒烟的难度也不比轻度吸烟者更高。事实上，他们戒烟的难度甚至更低。染上烟瘾的时间越久，戒烟带来的收获就越大。 &emsp;&emsp;或许你会很高兴知道，那些一度流传甚广的谣言（例如，“吸烟残留在身体里的毒素要七年才能完全排出体外”，或者“每一支烟会导致生命减少五分钟”）其实并不是真的。 &emsp;&emsp;当然，吸烟的危害性绝不是夸大，甚至还经常被低估。“每支烟导致生命减少五分钟”的说法，用于形容因吸烟患上不治之症的人，可以说是恰如其分。 &emsp;&emsp;吸烟残留在身体里的毒素，永远无法完全排出体外。即使不吸的人也会沾染少量的毒素，因为但凡有人类生活的地方，空气都已经被吸烟者污染了。不过，我们的身体具有强大的恢复能力，只要没有患上不治之症，吸烟对健康的损害都是可逆的。如果你现在戒烟的话，只消几个星期，吸烟对你健康的影响就会彻底消失。 &emsp;&emsp;记住，任何时候戒烟都不会为时过晚。通过我的帮助摆脱烟瘾的人中，有许多已经年届花甲，甚至超过了古稀之年。一位91岁的老妪曾带着她66岁的儿子，前来拜访我们的诊所。我问她为什么要戒烟，她的回答是：“为了给我儿子做个榜样。”六个月后她联系我时，说她感觉仿佛回到了年轻时代。 &emsp;&emsp;吸烟对你的危害越大，戒烟的效果就越明显。我最终戒烟成功时，每天抽掉的香烟数目从100支瞬间下降到0，而且没有任何严重反应。事实上，戒烟过程是一种享受，就连三个星期的戒断期也是一样。 &emsp;&emsp;但是还有洗脑的问题需要处理。 第7章 吸烟的陷阱：洗脑&emsp;&emsp;我们最初是怎么开始吸烟的，原因又是什么？为了彻底理解这一点，你必须了解潜意识的重要性。 &emsp;&emsp;我们都自认为是有智力、有主观能动性的人，能够决定自己的生活方向。事实上，我们的决定99%都会受到各种各样因素的影响。我们是周围环境影响的产物——我们身上的服装样式、居住的住宅、基本生活规律，更不用提政见、文化观念等，这些都是社会影响的结果。 &emsp;&emsp;不说这些理念和习惯，即使是我们对事实的认知，也无法保证一定正确。哥伦布抵达美洲之前，大多数人都认为大地和海洋是平的。今天我们知道地球是个球体，就算我写下十几本书，努力说服你地球是平的，你也不会相信。然而，我们中有多少人真正去过太空，从远处观察过地球？就算你曾进行过环球旅行，你又怎么知道旅行轨迹不是平面上的一个圆？ &emsp;&emsp;广告商们非常清楚心理暗示对潜意识的影响力。你是否认为杂志广告完全是金钱的浪费？认为广告并不是你购买香烟的原因？那你就错了！试试看，下次在冷天跟朋友一起去酒吧的时候，如果他问你想喝什么，不要简单回答“白兰地”，而是告诉他：“你知道我今天最想享受什么吗？白兰地奇妙的温 暖滋味！”你会发现，即使不喜欢喝酒的人也会跟你一样点杯白兰地。 &emsp;&emsp;“你建议我读这本书的时候维持吸烟的习惯，这实在是一出妙招。读书的过程中，我发现我对抽掉的每一根烟都耿耿于怀。” ——科尔斯蒂?L &emsp;&emsp;自打我们懂事时起，潜意识无时无刻不遭到各种信息的狂轰滥炸，其中许多信息都告诉我们：香烟是世界上最好的东西，能让我们放松，给我们信心和勇气。你觉得我是在夸大？看电影 、话剧或动画片时，如果一个角色即将被处以死刑，他的最后遗愿通常是什么？没错，吸一支烟。这样的情节并不会对我们的意识造成任何影响，但是我们的潜意识却会吸收其中的隐含信息，也就是：“香烟是世界上最好的东西，所以我才会把它作为临终选择。”在绝大多数战争片中，受伤的人都会得到一支香烟。 &emsp;&emsp;年复一年，这样的信息轰炸并没有改变。今天青少年的潜意识，仍然要承受各种信息的狂轰滥炸。尽管电视香烟广告已遭禁止，但在播放电视剧的黄金时间，屏幕上的明星们却都在吞云吐雾。体育运动也是一样。许多参加一级方程式大赛的赛车都以香烟品牌命名——或者是反过来，香烟品牌是以赛车命名？我曾看到过这样的插播广告：一对裸体的夫妇在做愛之后，躺在床 上共吸一支香烟。广告的暗示意味再明显不过了。尽管我无法赞同广告商的动机，但却不得不佩服他们的宣传手段。经常会有这样的宣传片：一个人正面临危急关头——他的热气球即将起火坠落 ，或者摩托车侧厢即将栽进峡谷，或者他是哥伦布，他的船马上就要从海洋的尽头掉进深渊之中。轻音乐响起，没有任何话语说明，那个人点起一支烟，脸上洋溢着幸福的表情。我们的主观意识或许会直接忽略这样的场面，但是潜意识却难免受其影响。 &emsp;&emsp;的确，反对吸烟的宣传也不是不存在——强调吸烟有害健康，提倡大众戒烟的宣传——但是单纯强调吸烟的危害，并不能为吸烟者提供戒烟的动力，更无法阻止青少年尝试吸烟。我自己还是个烟鬼的时候一直以为，当年我如果知晓吸烟与肺癌之间的关系，绝对不会开始吸烟。事实是，就算那样也不会有任何区别。吸烟的陷阱在今天，跟在文艺复兴时代没有任何区别。反对吸烟的宣传不仅于事无补，反而会把事情弄糟。所有的烟盒上都印有“吸烟有害健康”的字样，然而有人会去看吗？ &emsp;&emsp;我相信，关于吸烟有害健康的宣传，甚至会增加香烟的销量。吸烟者看到这样的宣传，无疑会心情紧张，于是抽掉更多的烟。 &emsp;&emsp;讽刺的是，最强大的洗脑力量来源于吸烟者自己。吸烟者绝不是意志薄弱或身体虚弱的人，相反，只有身体强健才能抵抗香烟中的毒素。 &emsp;&emsp;极少数人尽管一辈子吸烟，却能活到80多岁高龄，而且身体硬朗。吸烟者就拿这样的个别例子作为借口，不去理会吸烟损害健康的事实。这是他们坚持吸烟的原因之一。 &emsp;&emsp;如果你在朋友和同事中间做个小小的统计，你会发现，绝大多数吸烟者都是意志坚强的人，包括自由 经营者、企业高层、医生、律师、警察、教师、推销商、护士 、秘书、带孩子的家庭主妇等——换句话说，就是生活压力较大的那些人。许多人误以为吸烟能缓解压力，所以责任和压力重大的人更倾向于吸烟，而我们通常会仰慕这样的人，所以也跟着吸烟。另一类吸烟者则是那些工作性质单调重复的人，因为他们误以为吸烟能够缓解无聊。不过当然，这也只是一种错觉。 &emsp;&emsp;周围环境的洗脑效果累积起来，作用相当惊人。现代社会对绝大多数吸毒行为都极端排斥。在英国，每年因吸胶毒而死的人数不到一百，因海洛因而死的人数也只有几百，与吸烟致死的人数相比简直是沧海一粟。 &emsp;&emsp;然而尼古丁这种毒品 ，让超过60%的英国人染上了毒瘾，大多数人终其一生都无法摆脱。他们把无数财富浪费在吸烟上，每年都有数十万人死于吸烟引发的疾病。吸烟已成为现代社会的第一大杀手。 &emsp;&emsp;我们为什么对其他吸毒行为深恶痛绝，唯独对吸烟网开一面，甚至直到前不久，都将吸烟当作一种可以接受的社会行为？近年来，尽管人们开始认识到吸烟有害健康，但是烟草制品的销售不仅没有被禁止，而且还更上一层楼。最大的受益者是政府。由于众多吸烟者的存在，英国政府每年从烟草销售中抽取80亿英镑的利税，而各大烟草公司每年的宣传经费就超过一亿英镑。 &emsp;&emsp;你必须主动抗拒周围环境的洗脑作用。正如购买二手车时一样，你可以听车贩子吹得天花乱坠，并且微笑点头，但是内心绝对不能相信他半句。 &emsp;&emsp;五彩缤纷的香烟包装之下，掩藏的是肮脏和毒害，你一定要看清楚这一点。不要被精美的烟灰缸、镀金的打火机，以及千百万人吸烟的事实给迷惑了。扪心自问： &emsp;&emsp;为什么我要吸烟？ &emsp;&emsp;我真的需要吗？ &emsp;&emsp;不，你当然不需要。 &emsp;&emsp;洗脑作用的原理非常不容易解释。为什么吸烟者在其他方面智力正常，唯独在尼古丁毒瘾方面表现得像个白痴？尽管很痛苦，但我不得不承认，在我的帮助下摆脱烟瘾的数千人中，我自己正是最大的那个白痴。 &emsp;&emsp;不仅我自己每天抽100支烟，我父亲也是个烟鬼。他本是个健壮的人，却因为吸烟英年早逝。还记得童年时，父亲每天早上总要剧烈地咳嗽。我能看出他很痛苦，当时的我以为，他一定是中了什么邪。我曾对母亲说：“永远不要让我吸烟。” &emsp;&emsp;15岁的时候，我成了个运动狂，充满了自信和勇气。如果那时有人告诉我，我将来会成为一个每天吸100支烟的烟鬼，那我一定会拿一辈子赚的钱跟他打赌，赌这样的事永远不会发生。 &emsp;&emsp;到了40岁，我被香烟折磨得形神俱损，无论打算干什么，事先必须要点支烟。大多数吸烟者都是在感觉到压力时才会吸烟，比如接电话时、跟人交 谈时等。而我如果不来一支烟，就没有动力换个电灯泡，甚至切换电视频道。 &emsp;&emsp;我知道自己这样下去，最终会因吸烟而死。我不可能欺骗自己。但我无法理解，为什么当时我居然没有意识到，吸烟对我的精神也造成了重大影响。大多数吸烟者认为吸烟是一种享受，然而我从来没有产生过这样的错觉。我吸烟是因为我觉得，吸烟可以帮我集中注意力，缓解神经的紧张。现在我很难相信，我居然经历过那样一段黑暗的日子。那段时光仿佛是一场噩梦，梦醒之后一切都无所谓了。尼古丁是一种毒品 ，毒瘾会扭曲你的感觉，尤其是味觉和嗅觉。吸烟最可怕的地方不在于对健康的损害，而在于对精神的影响：你会搜寻任何说得过去的理由，只为了能继续吸烟。 &emsp;&emsp;我还记得，有一次戒烟失败之后，我决定由抽香烟改抽烟斗。当时我觉得，烟斗的危害性比香烟要小，而且我的烟草消耗量也会下降。烟斗用的烟草十分糟糕，或许闻上去气味还能忍受，但是抽起来让人痛不欲生。一连三个月，我的舌尖布满了水疱。烟斗底部逐渐积满了黏稠的焦油。偶尔我会不小心抬起烟斗，让里面的焦油流进嘴里。每当这样的时候，我就会立即呕吐，无论身边有什么人在场。 &emsp;&emsp;我花了三个月时间练习 使用烟斗，而在那三个月中间，我没有一次停下来问自己，我为什么要承受这样的折磨。 &emsp;&emsp;当然，适应了烟斗之后，吸烟者可能会自我感觉相当良好，因为他们终于有了借口：吸烟是因为喜欢烟斗的感觉。但是他们当初为什么要费力练习 使用烟斗呢？ &emsp;&emsp;原因是，一旦你染上尼古丁毒瘾，社会的洗脑作用就会加重。在潜意识里，你知道毒瘾必须用更多的尼古丁来压制，这个念头占据了你的整个思想。我已经说过，人们吸烟的真正原因是恐惧，对尼古丁戒断症状的恐惧。尽管你意识不到这一点，却不表明恐惧不存在。你并不理解这种恐惧，正如一只猫不会理解地板下的暖气管道一样。它只知道如果它趴在某一个地方，就会感觉到暖和。 &emsp;&emsp;洗脑是导致戒烟困难的最主要因素——社会对我们的洗脑，再加上我们对自己的洗脑，以及身边亲友和同事们的洗脑。 &emsp;&emsp;你是否注意到，在前文中，我经常使用“放弃吸烟”这种说法？事实上，这就是洗脑的典型例子。看多了这样的说法，你就会觉得戒烟的确是一种放弃，尽管事实上你完全没有什么可放弃的。相反，通过戒烟，你不仅可以远离毒瘾，还能达到神奇的正面效应。从现在开始，让我们改变这种说法。我不会再用“放弃”这个字眼，而是“停止”“杜绝”，或者最准确的表达：从吸烟的陷阱中逃脱！ &emsp;&emsp;我们开始吸烟是因为无数人都在这样做，我们觉得只有跟着做才算合群。我们拼命努力“学习 ”吸烟，从来没人想过深层次的后果。每当我们遇见另一个吸烟者，他总是让我们相信，吸烟的确有其意义所在。就算他已经戒了烟，当看到别人点起一支烟的时候，仍然会有强烈的失落感。他也想来一支烟，仅仅一支，他觉得这样很安全。结果就是，之前戒烟的努力完全失败。 &emsp;&emsp;这一洗脑作用非常强势，你必须十分小心。在英国，绝大多数老烟槍都听过神探保罗?坦普的系列广播故事。其中一集讲的是大麻上瘾的事。坏人把大麻添加到香烟里出售，而吸烟者却并不知情。大麻并没有产生负面作用，不过但凡吸过含大麻香烟的人，都只能继续购买这种香烟（我亲自帮助的戒烟者中，有几百人承认自己曾吸食过大麻，但是他们都没有上瘾）。第一次听到这个故事时我只有七岁，那是我对毒品 和毒瘾的最初概念。一旦形成毒瘾就难以摆脱，这让我感到非常害怕。即使在今天，尽管我知道大麻不会上瘾，也决不敢抽一口大麻。讽刺的是，我却成了全世界头号毒品 的瘾君子。要是保罗?坦普当年警告过我吸烟的害处就好了。更讽刺的是，60多年后的今天，人类把数以百亿计的钱投入癌症研究，同时又把10倍的钱用于广告宣传，让健康的青少年沾染上烟瘾。 &emsp;&emsp;我们必须消除洗脑作用的影响。否则，吸烟者终其一生，都无法好好享受： &emsp;&emsp;?良好的健康 &emsp;&emsp;?充沛的精力 &emsp;&emsp;?心灵的安宁 &emsp;&emsp;?财富 &emsp;&emsp;?自信 &emsp;&emsp;?勇气 &emsp;&emsp;?自尊 &emsp;&emsp;?幸福 &emsp;&emsp;?自由 &emsp;&emsp;牺牲了这么多，吸烟者得到的又有什么？ &emsp;&emsp;什么都没有——除了幻想。幻想恢复正常的生活状态，摆脱烟瘾的困扰，而这是每个非吸烟者每天都在享受的。]]></content>
      <categories>
        <category>这书能让你戒烟</category>
      </categories>
      <tags>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Love essays]]></title>
    <url>%2F2019%2F09%2F20%2FLoves-essay%2F</url>
    <content type="text"><![CDATA[开篇： 为了自己欣赏自己喜欢的文章 不做多少评论 提升自身文学修养 北平的秋—老舍 ＜四世同堂＞节选&emsp;&emsp;中秋前后是北平最美丽的时候。天气正好不冷不热，昼夜的长短也划分得平匀。没有冬季从蒙古吹来的黄风，也没有伏天里挟着冰雹的暴雨。天是那么高，那么蓝，那么亮，好象是含着笑告诉北平的人们：在这些天里，大自然是不会给你们什么威胁与损害的。西山北山的蓝色都加深了一些，每天傍晚还披上各色的霞帔。 &emsp;&emsp;在太平年月，街上的高摊与地摊，和果店里，都陈列出只有北平人才能一一叫出名字来的水果。各种各样的葡萄，各种各样的梨，各种各样的苹果，已经叫人够看够闻够吃的了，偏偏又加上那些又好看好闻好吃的北平特有的葫芦形的大枣，清香甜脆的小白梨，象花红那样大的白海棠，还有只供闻香儿的海棠木瓜，与通体有金星的香槟子，再配上为拜月用的，贴着金纸条的枕形西瓜，与黄的红的鸡冠花，可就使人顾不得只去享口福，而是已经辨不清哪一种香味更好闻，哪一种颜色更好看，微微的有些醉意了！ &emsp;&emsp;那些水果，无论是在店里或摊子上，又都摆列的那么好看，果皮上的白霜一点也没蹭掉，而都被摆成放着香气的立体的图案画，使人感到那些果贩都是些艺术家，他们会使美的东西更美一些。况且，他们还会唱呢！他们精心的把摊子摆好，而后用清脆的嗓音唱出有腔调的”果赞”：”唉——一毛钱儿来耶，你就挑一堆我的小白梨儿，皮儿又嫩，水儿又甜，没有一个虫眼儿，我的小嫩白梨儿耶！”歌声在香气中颤动，给苹果葡萄的静丽配上音乐，使人们的脚步放慢，听着看着嗅着北平之秋的美丽。 &emsp;&emsp;同时，良乡的肥大的栗子，裹着细沙与糖蜜在路旁唰啦唰啦的炒着，连锅下的柴烟也是香的。”大酒缸”门外，雪白的葱白正拌炒着肥嫩的羊肉；一碗酒，四两肉，有两三毛钱就可以混个醉饱。高粱红的河蟹，用席篓装着，沿街叫卖，而会享受的人们会到正阳楼去用小小的木锤，轻轻敲裂那毛茸茸的蟹脚。 &emsp;&emsp;同时，在街上的”香艳的”果摊中间，还有多少个兔儿爷摊子，一层层的摆起粉面彩身，身后插着旗伞的兔儿爷——有大有小，都一样的漂亮工细，有的骑着老虎，有的坐着莲花，有的肩着剃头挑儿，有的背着鲜红的小木柜；这雕塑的小品给千千万万的儿童心中种下美的种子。 &emsp;&emsp;同时，以花为粮的丰台开始一挑一挑的往城里运送叶齐苞大的秋菊，而公园中的花匠，与爱美的艺菊家也准备给他们费了半年多的苦心与劳力所养成的奇葩异种开”菊展”。北平的菊种之多，式样之奇，足以甲天下。 &emsp;&emsp;同时，象春花一般骄傲与俊美的青年学生，从清华园，从出产莲花白酒的海甸，从东南西北城，到北海去划船；荷花久已残败，可是荷叶还给小船上的男女身上染上一些清香。 &emsp;&emsp;同时，那文化过熟的北平人，从一入八月就准备给亲友们送节礼了。街上的铺店用各式的酒瓶，各种馅子的月饼，把自己打扮得象鲜艳的新娘子；就是那不卖礼品的铺户也要凑个热闹，挂起秋节大减价的绸条，迎接北平之秋。 &emsp;&emsp;北平之秋就是人间的天堂，也许比天堂更繁荣一点呢！ 本文节选自《四世同堂》人民文学出版社2012年版 陋室铭山不在高，有仙则名。水不在深，有龙则灵。斯是陋室，惟吾德馨。苔痕上阶绿，草色入帘青。谈笑有鸿儒，往来无白丁。可以调素琴，阅金经。无丝竹之乱耳，无案牍之劳形。南阳诸葛庐，西蜀子云亭。孔子云：何陋之有？ 本文选自《陋室铭》【作者】刘禹锡 【朝代】唐]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>短篇</tag>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔日志]]></title>
    <url>%2F2019%2F09%2F19%2F%E9%9A%8F%E7%AC%94%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[开篇 任性，就是想随便写点 有感而发，想到哪是哪 没有规划可言，随心所欲 2019-09-19 将近两周了，上上周定下来需求，从上周开始搞，算下时间，上周由于中秋节上了4天班，放假了三天，今天周四，算下来是八天时间.几乎每天搞到九点半，说实话很累，没办法，上班做程序员就是这么辛苦。 需求下来-&gt;周一晚上提测开始想着这挺简单的，应该能提前完成任务，但是没想到啊… 上周一研究需求，开始搞，贴图商城+聊天贴纸发送，之前的界面有所能复用，第一次接触这个项目&lt;语玩&gt;的webApi和c++API，所以研究了一番。接下来开始画界面，这个简单，大部分能复用，然后开始搞数据，一直在做重复工作，搞数据-&gt;等接口-&gt;画UI，周五吧基本的商城界面搞完，下载贴纸写完，但是留下的坑不少，给自己的话：下周在搞吧。 这周开始搞了，周一问下进度，肯定搞不完，提测别想了，于是在放一天，接着同事帮我搞了一些东西，安卓做的快，因为他来的时间比较长，代码模块什么都比我熟悉，算是周一下来基本东西搞完了，bug和坑还不算少，周二周三都干啥了，是开发是改bug，我这都忘了，今天是改了一天bug算是完成了。提前回家7点多下去吃点饭，上来提交一下回家家。 2019-09-29昨天睡得太晚了，也不是不想睡，就是睡不着，心里面也不知道想的啥，乱七八糟，估计睡着至少是到夜里1点半，结果可闲而知，早上起来眼睛睁不开，困，脑袋感觉重重的。7点半起床，洗漱完成上班去。由于这也临近十一假期，好多同事都回贵阳办公去了，公司人不多，零零细细，而且上周项目上架完成后基本上没有紧急任务，所以比较不忙，嘿嘿~ 浏览苹果官方网站，看到管理层入口，点击进去看看，浏览管理层简介，CEO Tim Cook, Katherine Adams … 吧啦吧啦一堆，突然想到国外的先进的公司管理方式和运营模式，改革开放完成后，吸引外资技术才有40年的发展，现在就想思考一下公司团队管理，是真的很牛逼。中国式最原始的管理方式就是东家与雇员的形式一直存在。而下面我想了解下先进的管理方式。 什么是美国式管理美国式管理是指对美国公司管理方式的称谓。美国式管理是以“法”为重心的管理，强调个人价值，强调沿革的制度，理性决策技术和追求最大限度的利润等。 美国式管理的特点美国式管理的特点是鼓励个人英雄主义及以能力为主要考核特征的模式，它在管理上的主要表现就是规范管理、制度管理和条例管理，以法制为主体的科学化管理。 美国式管理与中国式管理“中国式管理最大的价值在于对人的尊重。”曾教授说，他认为管理就是做人做事的道理，而做人要排在更重要的位置。美国式管理是“我要-我成”，订立目标，拿出成果；日本式管理则是“同生-共荣”，合力追求团体的荣誉，不计较个人的荣辱；而中国式管理却是“修己-安人”。美国式管理的特征核心是制度，说是以制度治理企业的典范。中国式管理，核心特征是人情，是人情治理企业的样板。 美国式管理的问题美国式管理管理方式出了问题。很多企业高管已经与企业脱节，不再了解真实的运转情况。长此以往，在美国公司内部，只有一个高高在上的CEO，他们对基层事务很少问津，却对股票价格紧张透顶。真正好的领导者应该是关注公司的每个层面，并且确实能把握一线生意进展的真实状况。美国式管理出现的主要问题在于，没有一个CEO能够有效衡量对于公司长期发展所产生的影响。 2019-09-30干移动端的工作，其实就像个厨师，产品调研 用户点个菜，UI给食材，后端队友给炒锅颠勺，经过层层规划，做这道菜的流程规划好。终于开始炒菜。要想做出来色香味俱全的菜，首先食材质量是不能次的，然后锅得耐用好使，火可大可小，最主要看这个厨师的功底怎么样了，各种花式的炒，也许好的厨师就算烂的食材和工具也能做出来的一道美味的菜肴。但是好的食材配合好的厨师才能做出来最好的菜肴。测试人员先品尝菜品味道有没有什么问题，接下来看服务员运营端菜上盘的功夫好不好了。乱说八道哈哈哈~ 2019-10-19转眼间19号了 2019-10-31今天都31号了，好久没来这里逛逛我的小窝了， 2020-06-30吸烟并不会使我快乐，不吸烟不会使我恐惧，所以吸烟并没有什么意义。绝大多数人吸烟的原因是，尽管知道吸烟弊大于利，但他们相信吸烟是一种享受。他们认为戒烟是放弃这种享受的过程，会给他们的生活造成损失。这是一种错觉。吸烟无法提供任何享受，只能先制造痛苦，然后再部分缓解痛苦，造成享受的假象。后文中，我会详细解释这一机制。 吸烟对你的危害越大，戒烟的效果就越明显。我最终戒烟成功时，每天抽掉的香烟数目从100支瞬间下降到0，而且没有任何严重反应。事实上，戒烟过程是一种享受，就连三个星期的戒断期也是一样。]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Study English]]></title>
    <url>%2F2019%2F09%2F07%2F%E5%AD%A6%E4%B9%A0%E8%8B%B1%E6%96%87%2F</url>
    <content type="text"><![CDATA[编程和英文息息相关，不会英文对开发过程中造成的影响还是不小的。尤其在读一些文档方面，熟悉每个单词的中文意思对读懂整个文档帮助很大。我的英文水平在高中后退化就很大了，大学英语基本上也没学过，词汇量不大，对我的工作生活影响也很大，虽然听力不行，但是增大词汇量对读一些国外文章就不成问题。平时的开发经常查一些单词，捡起来一些东西了，以后还是把自己所查的东西给记录下来吧。便于自己以后看看。 每天记录一些自己不认识或者不熟悉的单词 单词 释意 读音 Diamond 金刚石;钻石;菱形;(纸牌的)方块 美 [ˈdaɪəmənd] Permission 准许;许可;批准;许可证;书面许可 美 [pərˈmɪʃn] External 外部的;外面的;外界的;外来的;在外的;来自(学校或机构)以外的 美 [ɪkˈstɜːrnl] Incompatible 不可兼容的;不相容;不相容的;不兼容的;不相容性 美 [ˌɪnkəmˈpætəbl] percent 百分之… 美 [pərˈsɛnt] Reorder 调整顺序;重新排序;重排序;重排;顺序调整 美 [ˌriːˈɔːrdər] Essay 文章，短文;(用来刊登的)论说文;小品文 美 [ˈeseɪ , eˈseɪ] platforms 站台;月台;讲台;舞台;平台 美 [ˈplætˌfɔrmz] contribution 捐款;捐资;贡献;促成作用 美 [ˌkɑːntrɪˈbjuːʃn] 记录一些自己喜欢的英文语句]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ipa 打包shell脚本]]></title>
    <url>%2F2019%2F09%2F05%2Fipa-%E6%89%93%E5%8C%85shell%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[问题描述当我们想打包一个IPA，为自己内部测试使用，或者IPA部署自己服务器，这时候我们使用shell脚本就方便点了。 Xcode scheme run set release， device set generic iOS device，  run done product 文件夹下就有我们想要的东西了 编写好shell脚本，自动化快速为我们打包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#!/bin/shecho '\033[32m xcodebuild----------------------------start-------------------------- \033[0m'#打包基础配置userName='ysc'appName='Vostic'svnVersion='1.1.1'serverConfig='BeiJing'#serverConfig='ShuBei'#debugMode='Debug'debugMode='Release'sandbox='eynjaojbmfxqukcbinxdlfasvkpi'savePath=/Users/$&#123;userName&#125;/Desktop/xcodebuildsvnCheckPath=/Users/$&#123;userName&#125;/Desktop/iOS/VosticsvnLocalPath=$&#123;svnCheckPath&#125;/$&#123;svnVersion&#125;svnRemotePath=svn://yeshichang@10.1.6.1/dev/issue/iOS/Vostic/2019/$&#123;svnVersion&#125;#检出svnecho "checkout svn $svnVersion"if [ ! -d "$svnLocalPath" ]; thencd $&#123;svnCheckPath&#125;svn checkout $&#123;svnRemotePath&#125;fiecho '\033[32m xcodebuild---------------------------build--------------------------- \033[0m'#输入版本号read -p "Build version:" buildVersion#检查测试包是否已存在if [ -d "$svnLocalPath/$buildVersion" ]; thenecho "check $buildVersion is exists!"exit 0fi#输入Git版本号read -p "Git version:" gitVersion#开始时间戳startTime=$(date +%s)#创建存放目录if [ ! -d "$savePath" ]; thenmkdir "$savePath"fi#判断目录存在if [ ! -d "$savePath" ]; thenecho "check $savePath is no exists!"exit 0fi#打开存放目录cd $&#123;savePath&#125;#移除目录文件rm -rf *#创建版本目录mkdir "$savePath/$buildVersion"#拷贝xxx.app到存放目录cp -rf /Users/$&#123;userName&#125;/Library/Developer/Xcode/DerivedData/$&#123;appName&#125;-$&#123;sandbox&#125;/Build/Products/$&#123;debugMode&#125;-iphoneos/$&#123;appName&#125;.app $&#123;savePath&#125;#拷贝xxx.app到存放目录cp -rf /Users/$&#123;userName&#125;/Library/Developer/Xcode/DerivedData/$&#123;appName&#125;-$&#123;sandbox&#125;/Build/Products/$&#123;debugMode&#125;-iphoneos/$&#123;appName&#125;.app.dSYM $&#123;savePath&#125;/$&#123;buildVersion&#125;echo '\033[32m xcodebuild----------------------------ipa-------------------------- \033[0m'#利用itues将xxx.app生成ipamkdir Payloadcp -rf $&#123;appName&#125;.app Payload/$&#123;appName&#125;.appcp Icon.png $&#123;appName&#125;/iTunesArtworkzip -r $&#123;appName&#125;.ipa Payload iTunesArtwork#移除临时文件rm -rf Payloadrm -rf $&#123;appName&#125;.app#移动xxx.ipa到版本目录packageName=iOS_$&#123;buildVersion&#125;_$(date "+%Y%m%d")_$&#123;serverConfig&#125;_$&#123;gitVersion:0:10&#125;mv $&#123;appName&#125;.ipa $&#123;packageName&#125;.ipamv $&#123;packageName&#125;.ipa ./$&#123;buildVersion&#125;echo '\033[32m xcodebuild----------------------------zip-------------------------- \033[0m'#打开版本目录cd $&#123;savePath&#125;/$&#123;buildVersion&#125;#压缩xxx.ipa、xxx.app.dSYMzip -r -m $&#123;buildVersion&#125;.zip ./#回到存放目录cd ..#拷贝测试包到svn目录if [ ! -d "$svnLocalPath/$buildVersion" ]; thenmv $&#123;buildVersion&#125; $&#123;svnLocalPath&#125;fiecho '\033[32m xcodebuild----------------------------svn-------------------------- \033[0m'#打开svn目录cd $&#123;svnLocalPath&#125;#提交测试包svn cleanupsvn add $&#123;buildVersion&#125;svn commit -m "提交iOS测试包$buildVersion" $&#123;buildVersion&#125;#结束时间戳endTime=$(date +%s)time=$(($endTime - $startTime))minute=$(($time/60))second=$(($time%60))echo "\033[44;37m 总用时：$&#123;minute&#125;分$&#123;second&#125;秒 \033[0m"echo '\033[32m xcodebuild----------------------------end-------------------------- \033[0m'exit 0]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS13 自定义返回键位置问题]]></title>
    <url>%2F2019%2F09%2F02%2FiOS13-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%94%E5%9B%9E%E9%94%AE%E4%BD%8D%E7%BD%AE%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[iOS13 beta7已经出来了，为了提前适配应用，测试机升级看看应用是否有问题，幸好坑不算多，主要问题就是用系统导航栏的位置返回按钮向右偏移过多。主要与原有项目中的一些自定义导航返回键不统一。之前项目已经对iOS11后导航栏的变化做过处理 iOS11以下通过UIBarButtonSystemItemFixedSpace进行处理，可以参考论坛的一篇文章，但是iOS13系统处理不了。 所以寻找新方法解决这个问题，让我们先删除原来项目代码，大刀阔斧的干，要有豁出去的精神。 因为是使用系统导航栏，况且项目很大，不容易去修改整个结构，遂就对系统导航进行修改网上参考，在寻找一些解决方案。觉得这篇最合适 iOS11 导航栏按钮位置问题的解决——新，简洁流畅无冗余，结合自己项目做一些修改。最主要同时解决iOS13导航栏返回键偏移的问题。使用layoutMargins这个属性遍历图层大致可以看到时这样的结构 1&lt;_UINavigationBarContentView: 0x7fc141607250; frame = (0 0; 414 44); layer = &lt;CALayer: 0x608000038cc0&gt;&gt; 这个UINavigationBarContentView平铺在导航栏中作为iOS11的各个按钮的父视图,该视图的所有的子视图都会有一个layoutMargins被占用,也就是系统调整的占位,我们只要把这个置空就行了.那样的话该视图下的所有的子视图的空间就会变成我们想要的那样,当然为了保险起见,该视图的父视图也就是bar的layoutMargins也置空,这样 整个bar就会跟一个普通视图一样了 左右的占位约束就不存在了 可以过代码处理 12345678910111213141516171819202122@implementation UINavigationBar (FixSpace)+(void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; [self swizzleInstanceMethodWithOriginSel:@selector(layoutSubviews) swizzledSel:@selector(vst_layoutSubviews)]; &#125;);&#125;-(void)vst_layoutSubviews&#123; [self vst_layoutSubviews]; if (deviceVersion &gt;= 11) &#123; self.layoutMargins = UIEdgeInsetsZero; for (UIView *subview in self.subviews) &#123; if ([NSStringFromClass(subview.class) containsString:@"ContentView"]) &#123; subview.layoutMargins = UIEdgeInsetsZero;//可修正iOS11之后的偏移 &#125; &#125; &#125;&#125;@end 最终代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215#import &lt;UIKit/UIKit.h&gt;@interface UINavigationConfig : NSObject@property (nonatomic, assign) CGFloat vst_defaultFixSpace; // item距离两端的间距,默认为0@property (nonatomic, assign) BOOL vst_disableFixSpace; // 是否禁止使用修正,默认为NO+ (instancetype)shared;- (instancetype)init NS_UNAVAILABLE;+ (instancetype)new NS_UNAVAILABLE;- (CGFloat)vst_systemSpace;@end@interface UINavigationItem (VSTFixSpace)@end@interface NSObject (VSTFixSpace)@end#import "UINavigationVSTFixSpace.h"#import &lt;objc/runtime.h&gt;void vst_swizzle(Class oldClass, NSString *oldSelector, Class newClass) &#123; NSString *newSelector = [NSString stringWithFormat:@"vst_%@", oldSelector]; Method old = class_getInstanceMethod(oldClass, NSSelectorFromString(oldSelector)); Method new = class_getInstanceMethod(newClass, NSSelectorFromString(newSelector)); method_exchangeImplementations(old, new);&#125;@implementation UINavigationConfig+ (instancetype)shared &#123; static UINavigationConfig *config; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; config = [[self alloc] init]; &#125;); return config;&#125;-(instancetype)init &#123; if (self = [super init]) &#123; self.vst_defaultFixSpace = 0; self.vst_disableFixSpace = NO; &#125; return self;&#125;- (CGFloat)vst_systemSpace &#123; return MIN([UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height) &gt; 375 ? 20 : 16;&#125;@end@implementation UINavigationItem (VSTFixSpace)+(void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; if (@available(iOS 11.0, *)) &#123;&#125; else &#123; NSArray &lt;NSString *&gt;*oriSels = @[@"setLeftBarButtonItem:", @"setLeftBarButtonItem:animated:", @"setLeftBarButtonItems:", @"setLeftBarButtonItems:animated:", @"setRightBarButtonItem:", @"setRightBarButtonItem:animated:", @"setRightBarButtonItems:", @"setRightBarButtonItems:animated:"]; [oriSels enumerateObjectsUsingBlock:^(NSString * _Nonnull oriSel, NSUInteger idx, BOOL * _Nonnull stop) &#123; vst_swizzle(self, oriSel, self); &#125;]; &#125; &#125;);&#125;-(void)vst_setLeftBarButtonItem:(UIBarButtonItem *)leftBarButtonItem &#123; [self setLeftBarButtonItem:leftBarButtonItem animated:NO];&#125;-(void)vst_setLeftBarButtonItem:(UIBarButtonItem *)leftBarButtonItem animated:(BOOL)animated &#123; if (!UINavigationConfig.shared.vst_disableFixSpace &amp;&amp; leftBarButtonItem) &#123;// 存在按钮且需要调节 [self setLeftBarButtonItems:@[leftBarButtonItem] animated:animated]; &#125; else &#123;// 不存在按钮,或者不需要调节 [self vst_setLeftBarButtonItem:leftBarButtonItem animated:animated]; &#125;&#125;-(void)vst_setLeftBarButtonItems:(NSArray&lt;UIBarButtonItem *&gt; *)leftBarButtonItems &#123; [self setLeftBarButtonItems:leftBarButtonItems animated:NO];&#125;-(void)vst_setLeftBarButtonItems:(NSArray&lt;UIBarButtonItem *&gt; *)leftBarButtonItems animated:(BOOL)animated &#123; if (!UINavigationConfig.shared.vst_disableFixSpace &amp;&amp; leftBarButtonItems.count) &#123;// 存在按钮且需要调节 UIBarButtonItem *firstItem = leftBarButtonItems.firstObject; CGFloat width = UINavigationConfig.shared.vst_defaultFixSpace - UINavigationConfig.shared.vst_systemSpace; if (firstItem.width == width) &#123;// 已经存在space [self vst_setLeftBarButtonItems:leftBarButtonItems animated:animated]; &#125; else &#123; NSMutableArray *items = [NSMutableArray arrayWithArray:leftBarButtonItems]; [items insertObject:[self fixedSpaceWithWidth:width] atIndex:0]; [self vst_setLeftBarButtonItems:items animated:animated]; &#125; &#125; else &#123;// 不存在按钮,或者不需要调节 [self vst_setLeftBarButtonItems:leftBarButtonItems animated:animated]; &#125;&#125;-(void)vst_setRightBarButtonItem:(UIBarButtonItem *)rightBarButtonItem&#123; [self setRightBarButtonItem:rightBarButtonItem animated:NO];&#125;- (void)vst_setRightBarButtonItem:(UIBarButtonItem *)rightBarButtonItem animated:(BOOL)animated &#123; if (![UINavigationConfig shared].vst_disableFixSpace &amp;&amp; rightBarButtonItem) &#123;// 存在按钮且需要调节 [self setRightBarButtonItems:@[rightBarButtonItem] animated:animated]; &#125; else &#123;// 不存在按钮,或者不需要调节 [self vst_setRightBarButtonItem:rightBarButtonItem animated:animated]; &#125;&#125;- (void)vst_setRightBarButtonItems:(NSArray&lt;UIBarButtonItem *&gt; *)rightBarButtonItems&#123; [self setRightBarButtonItems:rightBarButtonItems animated:NO];&#125;- (void)vst_setRightBarButtonItems:(NSArray&lt;UIBarButtonItem *&gt; *)rightBarButtonItems animated:(BOOL)animated &#123; if (!UINavigationConfig.shared.vst_disableFixSpace &amp;&amp; rightBarButtonItems.count) &#123;// 存在按钮且需要调节 UIBarButtonItem *firstItem = rightBarButtonItems.firstObject; CGFloat width = UINavigationConfig.shared.vst_defaultFixSpace - UINavigationConfig.shared.vst_systemSpace; if (firstItem.width == width) &#123;// 已经存在space [self vst_setRightBarButtonItems:rightBarButtonItems animated:animated]; &#125; else &#123; NSMutableArray *items = [NSMutableArray arrayWithArray:rightBarButtonItems]; [items insertObject:[self fixedSpaceWithWidth:width] atIndex:0]; [self vst_setRightBarButtonItems:items animated:animated]; &#125; &#125; else &#123;// 不存在按钮,或者不需要调节 [self vst_setRightBarButtonItems:rightBarButtonItems animated:animated]; &#125;&#125;- (UIBarButtonItem *)fixedSpaceWithWidth:(CGFloat)width &#123; UIBarButtonItem *fixedSpace = [[UIBarButtonItem alloc]initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil]; fixedSpace.width = width; return fixedSpace;&#125;@end@implementation NSObject (VSTFixSpace)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; if (@available(iOS 13.0, *)) &#123; NSDictionary &lt;NSString *, NSString *&gt;*oriSels = @&#123;@"_UINavigationBarContentView": @"layoutSubviews", @"_UINavigationBarContentViewLayout": @"_updateMarginConstraints"&#125;; [oriSels enumerateKeysAndObjectsUsingBlock:^(NSString * _Nonnull cls, NSString * _Nonnull oriSel, BOOL * _Nonnull stop) &#123; vst_swizzle(NSClassFromString(cls), oriSel, NSObject.class); &#125;]; &#125; &#125;);&#125;- (void)vst_layoutSubviews &#123; [self vst_layoutSubviews]; if (UINavigationConfig.shared.vst_disableFixSpace) return; if (![self isMemberOfClass:NSClassFromString(@"_UINavigationBarContentView")]) return; id layout = [self valueForKey:@"_layout"]; if (!layout) return; SEL selector = NSSelectorFromString(@"_updateMarginConstraints"); IMP imp = [layout methodForSelector:selector]; void (*func)(id, SEL) = (void *)imp; func(layout, selector);&#125;- (void)vst__updateMarginConstraints &#123; [self vst__updateMarginConstraints]; if (UINavigationConfig.shared.vst_disableFixSpace) return; if (![self isMemberOfClass:NSClassFromString(@"_UINavigationBarContentViewLayout")]) return; [self vst_adjustLeadingBarConstraints]; [self vst_adjustTrailingBarConstraints];&#125;- (void)vst_adjustLeadingBarConstraints &#123; if (UINavigationConfig.shared.vst_disableFixSpace) return; NSArray&lt;NSLayoutConstraint *&gt; *leadingBarConstraints = [self valueForKey:@"_leadingBarConstraints"]; if (!leadingBarConstraints) return; CGFloat constant = UINavigationConfig.shared.vst_defaultFixSpace - UINavigationConfig.shared.vst_systemSpace; for (NSLayoutConstraint *constraint in leadingBarConstraints) &#123; if (constraint.firstAttribute == NSLayoutAttributeLeading &amp;&amp; constraint.secondAttribute == NSLayoutAttributeLeading) &#123; constraint.constant = constant; &#125; &#125;&#125;- (void)vst_adjustTrailingBarConstraints &#123; if (UINavigationConfig.shared.vst_disableFixSpace) return; NSArray&lt;NSLayoutConstraint *&gt; *trailingBarConstraints = [self valueForKey:@"_trailingBarConstraints"]; if (!trailingBarConstraints) return; CGFloat constant = UINavigationConfig.shared.vst_systemSpace - UINavigationConfig.shared.vst_defaultFixSpace; for (NSLayoutConstraint *constraint in trailingBarConstraints) &#123; if (constraint.firstAttribute == NSLayoutAttributeTrailing &amp;&amp; constraint.secondAttribute == NSLayoutAttributeTrailing) &#123; constraint.constant = constant; &#125; &#125;&#125;@end 原文demo地址]]></content>
      <categories>
        <category>Coding日常problem</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[My life]]></title>
    <url>%2F2019%2F08%2F31%2FMy-life%2F</url>
    <content type="text"><![CDATA[购物清单 一次性水杯 西瓜 豆浆 可口可乐 小茗同学 吸烟并不会使我快乐，不吸烟不会使我恐惧，所以吸烟并没有什么意义。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iPhone A12芯片录制编码解码失败问题]]></title>
    <url>%2F2019%2F08%2F31%2FiPhone-A12%E8%8A%AF%E7%89%87%E5%BD%95%E5%88%B6%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[语玩项目中发布动态，有个录制视频功能，录制视频用的是公司底层库C++编写的代码，现在遇到个问题。 问题描述 用A12以下处理器来录制视频，没问题，可以再任何苹果设备和安卓设备上播放 用A12处理器设备录制视频，在A12以下处理器的设备可以播放，在安卓设备也可以播放，但是在用A12处理器设备播放不了视频 特点是黑屏 验证我用手机iPhone XR录制视频，确实在本设备上不能够播放，在Safari浏览器上也不能播放，在本地相册中也不能播放。在其他设备可播放， iPhone XS iPhone XS Max 不可播放。 解决 底层库开发人员修改代码，使用软编码录制，确实可解决问题，但是视频质量不佳 不使用原生AVPlayer，使用其他第三方播放器如&lt;KSYMediaPlayer&gt;可播放，自己实现解码可播放。 经查明，是苹果系统的问题，从iOS12开始，这个bug一直未修复，听说是在iOS13 beta7版本中修复了此bug，但是苦于没有设备，别人的设备也不能够给人家升级beta版，无法做验证。]]></content>
      <categories>
        <category>Coding日常problem</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构 & 算法 in Swift （二）：算法概述和排序算法]]></title>
    <url>%2F2019%2F08%2F30%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%26%20%E7%AE%97%E6%B3%95%20in%20Swift%20%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0%E5%92%8C%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本篇是《数据结构 &amp; 算法 in Swift》系列连载的第二篇，内容分为如下两个部分： 算法基础：简单介绍算法的概念，时间复杂度与空间复杂度，递归，作为本文第二部分的背景知识。 排序算法：结合Swift的代码实现来讲解冒泡排序，选择排序，插入排序，归并排序，快速排序。 算法基础 该部分是给那些对算法以及相关知识不了解的读者准备的，如果已经对算法的相关知识有所了解，可以略过该部分，直接看本文的第二部分：排序算法。 关于该部分的讨论不属于本文介绍的重点，因此没有过多非常专业的论述，只是让那些对算法不了解的读者可以对算法先有一个基本的认识，为阅读和理解本文的第二部分做好准备。 算法的概念算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。 摘自《大话数据结构》 简单说来，算法就是“一个问题的解法”。对于相同一个问题，可能会有多种不同的解法。这些解法虽然可以得到相同的结果，但是每个算法的执行所需要的时间和空间资源却可以是千差万别的。 以消耗的时间的角度为出发点，我们看一下对于同一个问题，两种不同的解法的效率会相差多大： 现在让我们解决这个问题：计算从1到100数字的总和。 把比较容易想到的下面两种方法作为比较： 1到100循环遍历逐步相加 等差数列求和 用Swift函数来分别实现一下： 12345678910111213141516171819func sumOpration1(_ n:Int) -&gt; Int&#123; var sum = 0 for i in 1 ... n &#123; sum += i &#125; return sum&#125;sumOpration1(100)//5050func sumOpration2(_ n:Int) -&gt; Int&#123; return (1 + n) * n/2&#125;sumOpration2(100)//5050 上面的代码中，sumOpration1使用的是循环遍历的方式；sumOpration2使用的是等差数列求和的公式。 虽然两个函数都能得到正确的结果，但是不难看出两个函数实现的效率是有区别的: 遍历求和所需要的时间是依赖于传入函数的n的大小的，而等差数列求和的方法所需要的时间对传入的n的大小是完全不依赖的。 在遍历求和中，如果传入的n值是100，则需要遍历100次并相加才能得到结果，那么如果传入的n值是一百万呢？ 而在等差数列求和的函数中，无论n值有多大，只需要一个公式就可以解决。 我们对此可以以小见大：世上千千万万种问题（算法题）可能也有类似的情况：相同的问题，相同的结果，但是执行效率缺差之千里。那么有没有什么方法可以度量某种算法的执行效率以方便人们去选择或是衡量算法之间的差异呢？ 答案是肯定的。 下面笔者就向大家介绍算法所消耗资源的两个维度：时间复杂度和空间复杂度。 时间复杂度与空间复杂度时间复杂度算法的时间复杂度是指算法需要消耗的时间资源。一般来说，计算机算法是问题规模!n的函数f(n)，算法的时间复杂度也因此记做： $$ T(n)=o(f(n)) $$ 常见的时间复杂度有：常数阶O(1)，对数阶O(log n），线性阶 O(n)，线性对数阶O(nlog n)，平方阶O(n^{2})，立方阶O(n^{3})，!k次方阶O(n^{k})，指数阶 O(2^{n})}。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。 拿其中几个复杂度做对比： 从上图中我们可以看到，平方阶O(n^{2})随着n值的增大，其复杂度近乎直线飙升；而线性阶 O(n)随着n的增大，复杂度是线性增长的；我们还可以看到常数阶 O(1)随着n增大，其复杂度是不变的。 参考上一节的求和问题，我们可以看出来遍历求和的算法复杂度是线性阶O(n)：随着求和的最大数值的大小而线性增长；而等差数列求和算法的复杂度为常数阶 O(1)其算法复杂度与输入n值的大小无关。 读者可以试着想一个算法的复杂度与输入值n的平方成正比的算法。 在这里笔者举一个例子：求一个数组中某两个元素和为某个值的元素index的算法。数组为[0,2,1,3,6]，和为8： 1234567891011121314151617181920212223242526func findTwoSum(_ array: [Int], target: Int) -&gt; (Int, Int)? &#123; guard array.count &gt; 1 else &#123; return nil &#125; for i in 0..&lt;array.count &#123; let left = array[i] for j in (i + 1)..&lt;array.count &#123; let right = array[j] if left + right == target &#123; return (i, j) &#125; &#125; &#125; return nil&#125;let array = [0,2,1,3,6]if let indexes = findTwoSum(array, target: 8) &#123; print(indexes) //1， 4&#125; else &#123; print("No pairs are found")&#125; 上面的算法准确地计算出了两个元素的index为1和4。因为使用了两层的遍历，所以这里算法的复杂度是平方阶O(n^{2}。关于算法复杂度的详细推倒方法，可以参考网上和算法相关书籍的资料。 而其实，不需要遍历两层，只需要遍历一层即可：在遍历的时候，我么知道当前元素的值a，那么只要其余元素里面有值等于（target - a）的值即可。所以这次算法的复杂度就是线性阶O(n)了。 同样地，上面两种算法虽然可以达到相同的效果，但是当n非常大的时候，二者的计算效率就会相差更大：n = 1000的时候，二者得到结果所需要的时间可能会差好几百倍。可以说平方阶O(n^{2})复杂度的算法在数据量很大的时候是无法让人接受的。 空间复杂度算法的空间复杂度是指算法需要消耗的空间资源。其计算和表示方法与时间复杂度类似，一般都用复杂度的渐近性来表示。同时间复杂度相比，空间复杂度的分析要简单得多。而且控件复杂度不属于本文讨论的重点，因此在这里不展开介绍了。 递归在算法的实现中，遍历与递归是经常出现的两种操作。 对于遍历，无非就是使用一个for循环来遍历集合里的元素，相信大家已经非常熟悉了。但是对于递归操作就可能比较陌生。而且由于本文第二部分讲解算法的是时候有两个算法（也是比较重要）的算法使用了递归操作，所以为了能帮助大家理解这两个算法，笔者觉得有必要将递归单独拿出来讲解。 先看一下递归的概念。 递归的概念递归的概念是：在数学与计算机科学中，是指在函数的定义中使用函数自身的方法摘自维基百科 摘自维基百科 通过使用递归，可以把一个大型复杂的问题逐层转化为一个与原问题相似的规模较小的问题来求解。因此如果使用递归，可以达到使用少量的代码就可描述出解题过程所需的多次重复计算的目的，减少了程序的代码量 。 下面用一个例子来具体感受一下递归操作： 大家应该都比较熟悉阶乘的算法：3！= 3 2 1 ； 4！= 4 3 2 * 1 不难看出，在这里反复执行了一个逐渐-1和相乘的操作，如果可以使用某段代码达到重复调用的效果就很方便了，在这里就可以使用递归： 12345func factorial(_ n:Int) -&gt; Int&#123; return n &lt; 2 ? 1: n * factorial(n-1)&#125;factorial(3) //6 在上面的代码里，factorial函数调用了它自己，并且在n&lt;2的时候返回了1；否则继续调用自己。 从代码本身其实不难理解函数调用的方式，但是这个6究竟是怎么算出来的呢？这就涉及到递归的实现原理了。 递归的实现原理递归的调用实际上是通过调用栈（callback stack）来实现的，笔者用一张图从factorial(3)开始调用到最后得出6这个顺序之间发生的事情画了出来： 由上图可以看出，整个递归的过程和栈的入栈出栈的操作非常类似：橘黄色背景的圆角矩形代表了栈顶元素，也就是正在执行的操作，而灰色背景的圆角矩形则代表了其余的元素，它们的顺序就是当初被调用的顺序，而且在内容上保持了当时被调用时执行的代码。 现在笔者按照时间顺序从左到右来说明一下整个调用的过程： 最开始传入3之后，3满足了n&gt;=2的条件，继续调用自己：3 * factorial(2) ，入栈。 传入2之后，2满足了n&gt;=2的条件，继续调用自己：2 * factorial(1) ，入栈。 传入1之后，1满足了n&lt;2的条件，停止调用自己，返回了1，出栈。 此时的栈顶元素为2 factorial(1) ，而刚刚factorial(1)返回了1，所以现在这里变成了2 1 = 2，出栈。 同样地，此时栈顶元素为3 factorial(2)里的 factorial(2)返回了2，所以现在这里变成了3 2 = 6，出栈。 最后，factorial(3)返回了6，出栈，递归结束。 按照笔者个人的理解：整个递归的过程可以大致理解为：在使递归继续的条件为false之前，持续递归调用，以栈的形式保存调用上下文（临时变量，函数等）。一旦这个条件变为true，则立即按照出栈的顺序（入栈顺序的逆序）来返回值，逐个传递，最终传递到最开始调用的那一层返回最终结果。 再简单点，递归中的“递”就是入栈，传递调用信息；“归”就是出栈，输出返回值。 而这个分界线就是递归的终止条件。很显然，这个终止条件在整个递归过程中起着举足轻重的作用。试想一下，如果这个条件永远不会改变，那么就会一直入栈，就会发生栈溢出的情况。 使用递归时需要注意的问题基于上面递归的例子，我们将递归终止条件去掉： 12345func factorialInfinite(_ n:Int) -&gt; Int&#123; return n * factorialInfinite(n-1)&#125;factorialInfinite(3) 这段代码如果放在playground里，经过一小段时间（几秒钟或更多）后，会报一个运行时错误。也可以在return语句上面写一个print函数打印一些字符串，接着就会看到不停的打印，直到运行时错误，栈溢出。 所以说在今后写关于递归的代码的时候，一定要注意递归的终止条件是否合理，因为即使条件存在也不一定就是合理的条件。我们看一下下面这个例子： 12345678func sumOperation( _ n:Int) -&gt; Int &#123; if n == 0 &#123; return 0 &#125; return n + sumOperation(n - 1)&#125;sumOperation(2) //3 上面的代码跟阶乘类似，也是和小于当前参数的值相加，如果传入2，那么知道 n=0时就开始出栈， 2 + 1 + 0 = 3。看似没什么问题，但是如果一开始传入 - 1 呢？结果就是不停的入栈，直到栈溢出。因为 n == 0 这个条件在传入 - 1 的时候是无法终止入栈的，因为 - 1 之后的 -1 操作都是非0的。 所以说这个条件就不是合理的，一个比较合理的条件是 n &lt; = 0。 12345678func sumOperation( _ n:Int) -&gt; Int &#123; if n &lt;= 0 &#123; return 0 &#125; return n + sumOperation(n - 1)&#125;sumOperation(-1) //0 相信到这里，读者应该对递归的使用，调用过程以及注意事项有个基本的认识了。 那么到这里，关于算法的基本介绍已经讲完了，下面正式开始讲解排序算法。 排序算法讲解算法之前，我们先来看一下几个常见的排序算法的对比： 排序算法 平均情况下 最好情况 最坏情况 稳定性 空间复杂度 冒泡 O(n^2) O(n） O(n^2) 稳定 1 选择排序 O(n^2) O(n^2) O(n^2) 不稳定 1 插入排序 O(n^2) O(n） O(n^2) 稳定 1 希尔排序 O(nlogn) 依赖步长 依赖步长 稳定 1 堆排序 O(nlogn) O(nlogn) O(nlogn) 稳定 1 归并排序 O(nlogn) O(nlogn) O(nlogn) 稳定 O(n） 快速排序 O(nlogn) O(nlogn) O(n^2) 不稳定 O(logn) 最好情况和最坏情况以及稳定性的概念不在本文的讨论范围之内，有兴趣的读者可以查阅相关资料。 现在只看平均情况下的性能： 冒泡排序，选择排序，插入排序的时间复杂度为平方阶O(n^{2}) 希尔排序，堆排序，归并排序，快速排序的时间复杂度为线性对数阶O(nlog n) 本篇要给大家介绍的是冒泡排序，选择排序，插入排序，归并排序和快速排序。 希尔排序是基于插入排序，理解了插入排序以后，理解希尔排序会很容易，故在本文不做介绍。堆排序涉及到一个全新的数据结构：堆，所以笔者将堆这个数据结构和堆排序放在下一篇来做介绍。 排序初探在讲排序算法之前，我们先看一种最简单的排序算法（也是性能最低的，也是最好理解的），在这里先称之为“交换排序”。 注意，这个名称是笔者自己起的，在互联网和相关技术书籍上面没有对该算法起名。 算法讲解用两个循环来嵌套遍历： 外层遍历数组从0到末尾的元素，索引为i. 里层遍历数组从i+1至数组末尾的元素，索引为j。 当i上的元素比j上的元素大的时候，交换i和j的元素，目的是保持index为i的元素是最小的。 我们用一个例子看一下是怎么做交换的： 给定一个初始数组：array = [4, 1, 2, 5, 0] i = 0 时： array[0] &gt; array[1] : 交换4和1：[1, 4, 2, 5, 0]，内层的j继续遍历，j++。 array[0] &gt; array[4] : 交换0和1：[0, 4, 2, 5, 1]，i = 0的外层循环结束，i++。 i = 1时： array[1] &gt; array[2] : 交换2和4：[0, 2, 4, 5, 1]，内层的j继续遍历，j++。 array[1] &gt; array[4] : 交换1和2：[0, 1, 4, 5, 2]，i = 1的外层循环结束，i++。 i = 2 时： array[2] &gt; array[4] : 交换2和4：[0, 1, 2, 5, 4]，i = 2的外层循环结束，i++。 i = 3 时： array[3] &gt; array[4] : 交换5和4：[0, 1, 2, 4, 5]，i = 3的外层循环结束，i++。 i = 4 时：不符合内循环的边界条件，不进行内循环，排序结束。 那么用代码如何实现呢？ 代码实现1234567891011121314151617func switchSort(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; for i in 0 ..&lt; array.count &#123; for j in i + 1 ..&lt; array.count &#123; if array[i] &gt; array[j] &#123; array.swapAt(i, j) print("\(array)") &#125; &#125; &#125; return array &#125; 这里面swapAt函数是使用了Swift内置的数组内部交换两个index的函数，在后面会经常用到。 为了用代码验证上面所讲解的交换过程，可以在swapAt函数下面将交换元素后的数组打印出来： 1234567891011121314151617181920212223var originalArray = [4,1,2,5,0]print("original array:\n\(originalArray)\n")func switchSort(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; for i in 0 ..&lt; array.count &#123; for j in i + 1 ..&lt; array.count &#123; if array[i] &gt; array[j] &#123; array.swapAt(i, j) print("\(array)") &#125; &#125; &#125; return array &#125;switchSort(&amp;originalArray) 打印结果： 1234567891011original array:[4, 1, 2, 5, 0]switch sort...[1, 4, 2, 5, 0][0, 4, 2, 5, 1][0, 2, 4, 5, 1][0, 1, 4, 5, 2][0, 1, 2, 5, 4][0, 1, 2, 4, 5] 验证后我们可以看到，结果和上面分析的结果是一样的。 各位读者也可以自己设置原数组，然后在运行代码之前按照自己的理解，把每一次交换的结果写出来，接着和运行算法之后进行对比。该方法对算法的理解很有帮助，推荐大家使用~ 请务必理解好上面的逻辑，可以通过动笔写结果的方式来帮助理解和巩固，有助于对下面讲解的排序算法的理解。 大家看上面的交换过程（排序过程）有没有什么问题？相信细致的读者已经看出来了：在原数组中，1和2都是比较靠前的位置，但是经过中间的排序以后，被放在了数组后方，然后再次又交换回来。这显然是比较低效的，给人的感觉像是做了无用功。 那么有没有什么方法可以优化一下交换的过程，让交换后的结果与元素最终在数组的位置基本保持一致呢？ 答案是肯定的，这就引出了笔者要第一个正式介绍的排序算法冒泡排序： 冒泡排序算法讲解与上面讲的交换排序类似的是，冒泡排序也是用两层的循环来实现的；但与其不同的是： 循环的边界条件：冒泡排序的外层是[0,array.count-1);内层是[0,array.count-1-i)。可以看到内层的范围是不断缩小的，而且范围的前端不变，后端在向前移。 交换排序比较的是内外层索引的元素（array[i] 和 array[j]）,但是冒泡排序比较的是两个相邻的内层索引的元素：array[j]和array[j+1]。 笔者用和上面交换排序使用的同一个数组来演示下元素是如何交换的： 初始数组：array = [4, 1, 2, 5, 0] i = 0 时： array[0] &gt; array[1] : 交换4和1：[1, 4, 2, 5, 0]，内层的j继续遍历，j++。 array[1] &gt; array[2] : 交换4和2：[1, 2, 4, 5, 0]，内层的j继续遍历，j++。 array[2] &lt; array[3] : 不交换，内层的j继续遍历，j++。 array[3] &gt; array[4] : 交换5和0：[1, 2, 4, 0, 5]，i = 0的外层循环结束，i++。 i = 1时： array[2] &gt; array[3] : 交换2和4：[1, 2, 0, 4, 5]，内层的j继续遍历，j++。 array[3] &lt; array[4] : 不交换，i = 1的外层循环结束，i++。 i = 2 时： array[1] &gt; array[2] : 交换2和0：[1, 0, 2, 4, 5]，内层的j继续遍历，j++，直到退出i=2的外层循环，i++。 i = 3 时： array[0] &gt; array[1] : 交换1和0：[0, 1, 2, 4, 5]，内层的j继续遍历，j++，直到退出i=3的外层循环，i++。 i = 4 时：不符合外层循环的边界条件，不进行外层循环，排序结束。 代码实现我们来看一下冒泡排序的代码： 123456789101112131415func bubbleSort(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; for i in 0 ..&lt; array.count - 1 &#123; for j in 0 ..&lt; array.count - 1 - i &#123; if array[j] &gt; array[j+1] &#123; array.swapAt(j, j+1) &#125; &#125; &#125; return array&#125; 从上面的代码我们可以清楚地看到循环遍历的边界条件和交换时机。同样地，我们添加上log，将冒泡排序每次交换后的数组打印出来（为了进行对比，笔者将交换排序的log也打印了出来）： 123456789101112131415161718original array:[4, 1, 2, 5, 0]switch sort...[1, 4, 2, 5, 0][0, 4, 2, 5, 1][0, 2, 4, 5, 1][0, 1, 4, 5, 2][0, 1, 2, 5, 4][0, 1, 2, 4, 5]bubble sort...[1, 4, 2, 5, 0][1, 2, 4, 5, 0][1, 2, 4, 0, 5][1, 2, 0, 4, 5][1, 0, 2, 4, 5][0, 1, 2, 4, 5] 从上面两组打印可以看出，冒泡排序算法解决了交换排序算法的不足： 原来就处于靠前位置的1，2两个元素，在排序的过程中一直是靠前的。 原来处于末尾的0元素，在冒泡排序的过程中一点一点地向前移动，最终到了应该处于的位置。 现在我们知道冒泡排序是好于交换排序的，而且它的做法是相邻元素的两两比较：如果是逆序（左大右小）的话就做交换。 那么如果在排序过程中，数组已经变成有序的了，那么再进行两两比较就很不划算了。 为了证实上面这个排序算法的局限性，我们用新的测试用例来看一下： 1var originalArray = [2,1,3,4,5] 而且这次我们不仅仅在交换以后打log，也记录一下作比较的次数： 123456789101112131415161718192021func bubbleSort(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; var compareCount = 0 for i in 0 ..&lt; array.count - 1 &#123; for j in 0 ..&lt; array.count - 1 - i &#123; compareCount += 1 print("No.\(compareCount) compare \(array[j]) and \(array[j+1])") if array[j] &gt; array[j+1] &#123; array.swapAt(j, j+1) //keeping index of j is the smaller one print("after swap: \(array)") &#125; &#125; &#125; return array&#125; 打印结果： 12345678910111213141516original array:[2, 1, 3, 4, 5]bubble sort...No.1 compare 2 and 1after swap: [1, 2, 3, 4, 5] //already sorted, but keep comparingNo.2 compare 2 and 3No.3 compare 3 and 4No.4 compare 4 and 5No.5 compare 1 and 2No.6 compare 2 and 3No.7 compare 3 and 4No.8 compare 1 and 2No.9 compare 2 and 3No.10 compare 1 and 2` 从打印的结果可以看出，其实在第一次交换过之后，数组已经是有序的了，但是该算法还是继续在比较，做了很多无用功，能不能有个办法可以让这种两两比较在已知有序的情况下提前结束呢？答案是肯定的。 提前结束这个操作很容易，我们只需要跳出最外层的循环就好了。关键是这个时机：我们需要让算法自己知道什么时候数组已经是有序的了。 是否已经想到了呢？就是在一次内循环过后，如果没有发生元素交换，就说明数组已经是有序的，不需要再次缩小内循环的范围继续比较了。所以我们需要在外部设置一个布尔值的变量来标记“该数组是否有序”： 我们将这个算法称为：advanced bubble sort 12345678910111213141516171819202122232425func bubbleSortAdvanced(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; for i in 0 ..&lt; array.count - 1 &#123; //bool switch var swapped = false for j in 0 ..&lt; array.count - i - 1 &#123; if array[j] &gt; array [j+1] &#123; array.swapAt(j, j+1) swapped = true; &#125; &#125; //if there is no swapping in inner loop, it means the the part looped is already sorted, //so it's time to break if (swapped == false)&#123; break &#125; &#125; return array &#125; 从上面的代码可以看出，在第一个冒泡排序的算法之内，只添加了一个swapped这个布尔值，默认为false： 如果在当前内循环里面没有发生过元素交换，则说明当前内循环范围的元素都是有序的；那么就说明后续的内循环范围的元素也是有序的（因为内循环每次迭代后都会缩小），就可以跳出循环了。 反之，如果在当前内循环里发生过元素交换，则说明当前内循环很可能是无序的（也可能是有序的，但是有序性需要在下一个内循环中验证，所以还是不能提前退出，还需要进行一次内循环）。 为了验证上面这个改进冒泡排序是否能解决最初给出的冒泡排序的问题，我们添加上对比次数的log： 123456789101112131415161718192021222324252627original array:[2, 1, 3, 4, 5]bubble sort...No.1 compare 2 and 1after swap: [1, 2, 3, 4, 5]No.2 compare 2 and 3No.3 compare 3 and 4No.4 compare 4 and 5No.5 compare 1 and 2No.6 compare 2 and 3No.7 compare 3 and 4No.8 compare 1 and 2No.9 compare 2 and 3No.10 compare 1 and 2bubble sort time duration : 1.96msadvanced bubble sort...No.1 compare 2 and 1after swap: [1, 2, 3, 4, 5]No.2 compare 2 and 3No.3 compare 3 and 4No.4 compare 4 and 5No.5 compare 1 and 2No.6 compare 2 and 3No.7 compare 3 and 4 我们可以看到，在使用改进的冒泡排序后，对比的次数少了3次。之所以没有立即返回，是因为即使在交换完变成有序数组以后，也无法在当前内循环判断出是有序的。需要在下次内循环才能验证出来。 因为数组的元素数量比较小，所以可能对这个改进所达到的效果体会得不是很明显。现在我们增加一下数组元素的个数，并用记录比较总和的方式来看一下二者的区别： 123456789original array:[2, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]bubble sort...total compare count： 91advanced bubble sort...total compare count： 25 从比较结果可以看出，这两种算法在该测试样本下的差距是比较大的，而且随着元素个数的增多这个差距会越来越大（因为做了更多没有意义的比较）。 虽然这种测试样本比较极端，但是在某种意义上还是优化了最初的冒泡排序算法。一般在网上的冒泡排序算法应该都能看到这个优化版的。 现在我们知道这个优化版的冒泡排序算法可以在知道当前数组已经有序的时候提前结束，但是毕竟不断的交换还是比较耗费性能的，有没有什么方法可以只移动一次就能做好当前元素的排序呢？答案又是肯定的，这就引出了笔者即将介绍的选择排序算法。 选择排序算法讲解选择排序也是两层循环： 外层循环的边界是[0,array.count-1)，index为i。 内层循环的边界是[i+1,array.count)，index为j。可以看到内层的范围也是不断缩小的，而且范围的前端一直后移，后端保持不变。 具体做法是： 在外层循环的开始，将i作为最小值index（很可能不是该数组的最小值）。 在内层循环里面找到当前内层循环范围内的最小值，并与已经记录的最小值作比较： 如果与当前记录的最小值index不同，则替换 如果与当前记录的最小值index相同，则不替换 我们还是用手写迭代的方式看一下选择排序的机制，使用的数组和上面交换排序和冒泡排序（非优化版）的数组一致：[4, 1, 2, 5, 0] i = 0 时： 记录当前的最小值的index为0，当前最小值为4。 内层循环开始，找到[1,5)之间的最小值为0，0的index为4，与当前最小值的index0不同，所以二者要做交换。交换后的数组：[0, 1, 2, 5, 4]。当前内层循环结束，i++。 i = 1 时： 记录当前的最小值的index为1，当前最小值为1。 内层循环开始，找到[2,5)之间的最小值为1，与当前记录的最小值index相同。也就是说后面没有比1还要小的了，不做交换。当前内层循环结束，i++。 i = 2 时： 记录当前的最小值的index为2，当前最小值为2。 内层循环开始，找到[3,5)之间的最小值为2，与当前记录的最小值index相同。也就是说后面没有比1还要小的了，不做交换。当前内层循环结束，i++。 i = 3 时： 记录当前的最小值的index为3，当前最小值为2。 内层循环开始，找到[4,5)之间的最小值为4，4的index为4，与当前记录的最小值index3不同，所以二者要做交换。交换后的数组：[0, 1, 2, 4, 5]。当前内层循环结束，i++。 i = 4 时：不符合外层循环的边界条件，不进行外层循环，排序结束。 我们可以看到，同样的初始序列，使用选择排序只进行了2次交换，因为它知道需要替换的最小值是什么，做了很少没意义的交换。 代码实现我们用代码来实现一下上面选择排序的算法： 1234567891011121314151617181920212223func selectionSort(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; for i in 0 ..&lt; array.count - 1&#123; var min = i for j in i + 1 ..&lt; array.count &#123; if array[j] &lt; array[min] &#123; min = j &#125; &#125; //if min has changed, it means there is value smaller than array[min] //if min has not changed, it means there is no value smallter than array[min] if i != min &#123; array.swapAt(i, min) &#125; &#125; return array&#125; 从上面的代码可以看到，在这里使用了min这个变量记录了当前外层循环所需要被比较的index值，如果当前外层循环的内层循环内部找到了比这个最小值还小的值，就替换他们。 下面我们使用log来看一下此时选择排序作替换的次数： 1234567891011121314original array:[4, 1, 2, 5, 0]advanced bubble sort...after swap: [1, 4, 2, 5, 0]after swap: [1, 2, 4, 5, 0]after swap: [1, 2, 4, 0, 5]after swap: [1, 2, 0, 4, 5]after swap: [1, 0, 2, 4, 5]after swap: [0, 1, 2, 4, 5]selection sort...after swap: [0, 1, 2, 5, 4]after swap: [0, 1, 2, 4, 5] 从上面的log可以看出二者的对比应该比较明显了。 为了进一步验证选择排序的性能，笔者在网上找到了两个工具： 计算程序运行时间的类：executionTimeInterval.swift 生成各种类型随机数的Array的分类：Array+Extension.swift 首先看executionTimeInterval.swift的实现： 1234567891011121314151617181920//time intervalpublic func executionTimeInterval(block: () -&gt; ()) -&gt; CFTimeInterval &#123; let start = CACurrentMediaTime() block(); let end = CACurrentMediaTime() return end - start&#125;//formatted timepublic extension CFTimeInterval &#123; public var formattedTime: String &#123; return self &gt;= 1000 ? String(Int(self)) + "s" : self &gt;= 1 ? String(format: "%.3gs", self) : self &gt;= 1e-3 ? String(format: "%.3gms", self * 1e3) : self &gt;= 1e-6 ? String(format: "%.3gµs", self * 1e6) : self &lt; 1e-9 ? "0s" : String(format: "%.3gns", self * 1e9) &#125;&#125; 第一个函数以block的形式传入需要测试运行时间的函数，返回了函数运行的时间。 第二个函数是CFTimeInterval的分类，将秒数添加了单位：毫秒级的以毫秒显示，微秒级的以微秒显示，大于1秒的以秒单位显示。 使用方法是：将两个swift文件拖进playground里面的Sources文件夹里，并点击二者后，进入playground内部： 123456var selectionSortedArray = [Int]()var time4 = executionTimeInterval&#123; selectionSortedArray = selectionSort(&amp;originalArray4) //要测试的函数&#125;print("selection sort time duration : \(time4.formattedTime)") //打印出时间 再来看一下Array+Extension.swift类： 先介绍其中的一个方法，生成随机数组： 1234567891011121314import Foundationextension Array &#123; static public func randomArray(size: Int, maxValue: UInt) -&gt; [Int] &#123; var result = [Int](repeating: 0, count:size) for i in 0 ..&lt; size &#123; result[i] = Int(arc4random_uniform(UInt32(maxValue))) &#125; return result &#125;&#125; 这个方法只需要传入数组的大小以及最大值就可以生成一个不超过这个最大值的随机数组。 比如我们要生成一个数组长度为10，最大值为100的数组： 12var originalArray = Array&lt;Int&gt;.randomArray(size: inputSize, maxValue:100)//originalArray:[87, 56, 54, 20, 86, 33, 41, 9, 88, 55] 那么现在有了上面两个工具，我们就可以按照我们自己的意愿来生成测试用例数组，并且打印出所用算法的执行时间。我们现在生成一个数组长度为10，最大值为100的数组，然后分别用优化的冒泡排序和选择排序来看一下二者的性能： 12345678original array:[1, 4, 80, 83, 92, 63, 83, 23, 9, 85]advanced bubble sort...advanced bubble sort result: [1, 4, 9, 23, 63, 80, 83, 83, 85, 92] time duration : 8.53msselection sort...selection sort result: [1, 4, 9, 23, 63, 80, 83, 83, 85, 92] time duration : 3.4ms 我们现在让数组长度更长一点:一个长度为100，最大值为200： 12345advanced bubble sort...advanced bubble sort sorted elemets: 100 time duration : 6.27sselection sort...selection sort sorted elemets: 100 time duration : 414ms 可以看到，二者的差别大概在12倍左右。这个差别已经很大了，如果说用选择排序需要1天的话，冒泡排序需要12天。 现在我们学习了选择排序，知道了它是通过减少交换次数来提高排序算法的性能的。 但是关于排序，除了交换操作以外，对比操作也是需要时间的：选择排序通过内层循环的不断对比才得到了当前内层循环的最小值，然后进行后续的判断和操作。 那么有什么办法可以减少对比的次数呢？猜对了，答案又是肯定的。这就引出了笔者下面要说的算法：插入排序算法。 插入排序算法讲解插入排序的基本思想是：从数组中拿出一个元素（通常就是第一个元素）以后，再从数组中按顺序拿出其他元素。如果拿出来的这个元素比这个元素小，就放在这个元素左侧；反之，则放在右侧。整体上看来有点和玩儿扑克牌的时候将刚拿好的牌来做排序差不多。 选择排序也是两层循环： 外层循环的边界是[1,array.count)，index为i。 内层循环开始的时候初始index j = i，然后使用一个while循环，循环条件是j&gt;0 &amp;&amp; array[j] &lt; array[j - 1],循环内侧是交换j-1和j的元素，并使得j-1。可以简单理解为如果当前的元素比前一个元素小，则调换位置；反之进行下一个外层循环。 下面我们还是用手写迭代的方式看一下插入排序的机制，使用的数组和上面选择排序的数组一致：[4, 1, 2, 5, 0] i = 1 时： j = 1：array[1] &lt; array[0]， 交换4和1：[1, 4, 2, 5, 0]，j-1之后不符合内层循环条件，退出内层循环，i+1。 i = 2 时： j = 2，array[3] &lt; array[2]，交换4和2：[1, 2, 4, 5, 0]，j向左移动，array[2] &gt; array[1]，不符合内层循环条件，退出内层循环，i+1。 i = 3 时： j = 3，array[3] &gt; array[2]，不符合内层循环条件，退出内层循环，i+1。 i = 4 时： j = 4，array[4] &lt; array[3]，交换5和0：[1, 2, 4, 0, 5]，j -1。 j = 3，array[3] &lt; array[2]，交换4和0：[1, 2, 0, 4, 5]，j -1。 j = 2，array[2] &lt; array[1]，交换4和0：[1, 0, 2, 4, 5]，j -1。 j = 1，array[1] &lt; array[0]，交换1和0：[0, 1, 2, 4, 5]，j -1 = 0，不符合内层循环条件，退出内层循环，i+1 = 5，不符合外层循环条件，排序终止。 从上面的描述可以看出，和选择排序相比，插入排序的内层循环是可以提前推出的，其条件就是array[j] &gt;= array[j - 1],也就是说，当前index为j的元素只要比前面的元素大，那么该内层循环就立即退出，不需要再排序了，因为该算法从一开始就是小的放前面，大的放后面。 代码实现下面我们通过代码来看一下如何实现插入排序算法: 1234567891011121314func insertionSort(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; for i in 1..&lt;array.count &#123; var j = i while j &gt; 0 &amp;&amp; array[j] &lt; array[j - 1] &#123; array.swapAt(j - 1, j) j -= 1 &#125; &#125; return array&#125; 从上面的代码可以看出插入排序内层循环的条件：j &gt; 0 &amp;&amp; array[j] &lt; array[j - 1]。只要当前元素比前面的元素小，就会一直交换下去；反之，当大于等于前面的元素，就会立即跳出循环。 之前笔者有提到相对于选择排序，说插入排序可以减少元素之间对比的次数，下面我们通过打印对比次数来对比一下两种算法： 使用元素个数为50，最大值为50的随机数组： 1234567selection sort...compare times:1225selection sort time duration : 178msinsertion sort...compare times:519insertion sort time duration : 676ms 我们可以看到，使用选择排序的比较次数比插入排序的比较次数多了2倍。但是遗憾的是整体的性能选择排序要高于插入排序。 也就是说虽然插入排序的比较次数少了，但是交换的次数却比选择排序要多，所以性能上有时可能不如选择排序。 注意，这不与笔者之前的意思相矛盾，笔者只是说在减少比较次数上插入排序是优于选择排序的，但没有说插入排序整体上优于选择排序。 那么有何种特性的数组可以让排序算法有其用武之地呢？ 从上面使用插入排序来排序[4, 1, 2, 5, 0]这个数组的时候，我们可以看到，因为0这个元素已经在末尾了，所以在j=4的时候我们费了好大劲才把它移到前面去。 那么将这个情况作为一个极端，我们可以这样想：如果这个数组里的元素里的index大致于最终顺序差不多的情况是不是就不用做这么多的搬移了？。这句话听起来像是理所当然的话，但是有一种数组属于“基本有序”的数组，这种数组也是无需的，但是它在整体上是有序的，比如： 1[2,1,3,6,4,5,9,7,8] 用笔者的话就叫做整体有序，部分无序。 我们可以简单用这个数组来分别进行选择排序和插入排序做个比较： 1234567selection sort...compare times:36selection sort time duration : 4.7msinsertion sort...compare times:5insertion sort time duration : 3.2ms 我们可以看到插入排序在基本有序的测试用例下表现更好。为了让差距更明显，笔者在Array+Extension.swift文件里增加了一个生成基本有序随机数组的方法： 12345678910111213141516171819202122static public func nearlySortedArray(size: Int, gap:Int) -&gt; [Int] &#123; var result = [Int](repeating: 0, count:size) for i in 0 ..&lt; size &#123; result[i] = i &#125; let count : Int = size / gap var arr = [Int]() for i in 0 ..&lt; count &#123; arr.append(i*gap) &#125; for j in 0 ..&lt; arr.count &#123; let swapIndex = arr[j] result.swapAt(swapIndex,swapIndex+1) &#125; return result&#125; 该函数需要传入数组的长度以及需要打乱顺序的index的跨度，它的实现是这样子的： 首先生成一个完全有序的序列。 将数组长度除以跨度来得出需要交换的index的个数count。 根据这个count可以得出需要交换的index，把这些index放在一个新的arr里面 便利这个arr来取出index，将之前生成好的w安全有序的数组的index于index+1做交换。 举个例子，如果我们生成一个数组长度为12，跨度为3的基本有序的数组，就可以这么调用： 12var originalArray = Array&lt;Int&gt;.nearlySortedArray(size: 12, gap: 3)//[1, 0, 2, 4, 3, 5, 7, 6, 8, 10, 9, 11] 跨度为3，说明有12/3 = 4 - 1 = 3 个元素需要调换位置，序号分别为0，3，6，9。所以序号为0，1；3，4；6，7；9，10的元素被调换了位置，可以看到调换后的数组还是基本有序的。 现在我们可以用一个比较大的数组来验证了： 1var originalArray = Array&lt;Int&gt;.nearlySortedArray(size: 100, gap: 10) 结果为： 1234567selection sort...compare times:4950selection sort time duration : 422msinsertion sort...compare times:10insertion sort time duration : 56.4ms 我们可以看到差距是非常明显的，插入排序的性能是选择排序的性能的近乎10倍 归并排序算法讲解归并排序使用了算法思想里的分治思想（divide conquer）。顾名思义，就是将一个大问题，分成类似的小问题来逐个攻破。在归并排序的算法实现上，首先逐步将要排序的数组等分成最小的组成部分（通常是1各元素），然后再反过来逐步合并。 用一张图来体会一下归并算法的实现过程： 上图面的虚线箭头代表拆分的过程；实线代表合并的过程。仔细看可以发现，拆分和归并的操作都是重复进行的，在这里面我们可以使用递归来操作。 首先看一下归并的操作： 归并的操作就是把两个数组（在这里这两个数组的元素个数通常是一致的）合并成一个完全有序数组。 归并操作的实现步骤是： 新建一个空数组，该数组用于存放合并后的有序数组。 两个传入的数组从index 0 开始两两比较，较小的元素放在新建的空数组中，index + 1; 较大的元素不作操作，index 不变，然后继续两两比较。知道index移到末尾为止。 个别情况当两个数组长度不一致的情况下需要将数组里剩余的元素放在新建的数组中。 代码实现我们来看一下归并排序算法的代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546func _merge(leftPile: [Int], rightPile: [Int]) -&gt; [Int] &#123; var leftIndex = 0 //left pile index, start from 0 var rightIndex = 0 //right pile index, start from 0 var sortedPile = [Int]() //sorted pile, empty in the first place while leftIndex &lt; leftPile.count &amp;&amp; rightIndex &lt; rightPile.count &#123; //append the smaller value into sortedPile if leftPile[leftIndex] &lt; rightPile[rightIndex] &#123; sortedPile.append(leftPile[leftIndex]) leftIndex += 1 &#125; else if leftPile[leftIndex] &gt; rightPile[rightIndex] &#123; sortedPile.append(rightPile[rightIndex]) rightIndex += 1 &#125; else &#123; //same value, append both of them and move the corresponding index sortedPile.append(leftPile[leftIndex]) leftIndex += 1 sortedPile.append(rightPile[rightIndex]) rightIndex += 1 &#125; &#125; //left pile is not empty while leftIndex &lt; leftPile.count &#123; sortedPile.append(leftPile[leftIndex]) leftIndex += 1 &#125; //right pile is not empty while rightIndex &lt; rightPile.count &#123; sortedPile.append(rightPile[rightIndex]) rightIndex += 1 &#125; return sortedPile&#125; 因为该函数是归并排序函数内部调用的函数，所以在函数名称的前面添加了下划线。仅仅是为了区分，并不是必须的。 从上面代码可以看出合并的实现逻辑： 新建空数组，初始化两个传入数组的index为0 两两比较两个数组index上的值，较小的放在新建数组里面并且index+1。 最后检查是否有剩余元素，如果有则添加到新建数组里面。 理解了合并的算法，下面我们看一下拆分的算法。拆分算法使用了递归： 12345678910func mergeSort(_ array: [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; let middleIndex = array.count / 2 let leftArray = mergeSort(Array(array[0..&lt;middleIndex])) // recursively split left part of original array let rightArray = mergeSort(Array(array[middleIndex..&lt;array.count])) // recursively split right part of original array return _merge(leftPile: leftArray, rightPile: rightArray) // merge left part and right part&#125; 我们可以看到mergeSort调用了自身，它的递归终止条件是!(array.count &gt;1)，也就是说当数组元素个数 = 1的时候就会返回，会触发调用栈的出栈。 从这个递归函数的实现可以看到它的作用是不断以中心店拆分传入的数组。根据他的递归终止条件，当数组元素 &gt; 1的时候，拆分会继续进行。而下面的合并函数只有在递归终止，开始出栈的时候才开始真正执行。也就是说在拆分结束后才开始进行合并，这样符合了上面笔者介绍的归并算法的实现过程。 上段文字需要反复体会。 为了更形象体现出归并排序的实现过程，可以在合并函数(_merge)内部添加log来验证上面的说法： 123456789func _merge(leftPile: [Int], rightPile: [Int]) -&gt; [Int] &#123; print("\nmerge left pile:\(leftPile) | right pile:\(rightPile)") ... print("sorted pile：\(sortedPile)") return sortedPile&#125; 而且为了方便和上图作比较，初始数组可以取图中的[3, 5, 9, 2, 7, 4, 8, 0]。运行一下看看效果： 12345678910111213141516171819202122232425original array:[3, 5, 9, 2, 7, 4, 8, 0]merge sort...merge left pile:[3] | right pile:[5]sorted pile：[3, 5]merge left pile:[9] | right pile:[2]sorted pile：[2, 9]merge left pile:[3, 5] | right pile:[2, 9]sorted pile：[2, 3, 5, 9]merge left pile:[7] | right pile:[4]sorted pile：[4, 7]merge left pile:[8] | right pile:[0]sorted pile：[0, 8]merge left pile:[4, 7] | right pile:[0, 8]sorted pile：[0, 4, 7, 8]merge left pile:[2, 3, 5, 9] | right pile:[0, 4, 7, 8]sorted pile：[0, 2, 3, 4, 5, 7, 8, 9] 我们可以看到，拆分归并的操作是先处理原数组的左侧部分，然后处理原数组的右侧部分。这是为什么呢？ 我们来看下最初函数是怎么调用的： 最开始我们调用函数： 12345678910func mergeSort(_ array: [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; let middleIndex = array.count / 2 let leftArray = mergeSort(Array(array[0..&lt;middleIndex])) //1 let rightArray = mergeSort(Array(array[middleIndex..&lt;array.count])) //2 return _merge(leftPile: leftArray, rightPile: rightArray) //3&#125; 在//1这一行开始了递归，这个时候数组是原数组，元素个数是8，而调用mergeSort时原数组被拆分了一半，是4。而4&gt;1，不满足递归终止的条件，继续递归，直到符合了终止条件（[3]）,递归开始返回。以为此时最初被拆分的是数组的左半部分，所以左半部分的拆分会逐步合并，最终得到了[2,3,5,9]。 同理，再回到了最初被拆分的数组的右半部分（上面代码段中的//2），也是和左测一样的拆分和归并，得到了右侧部分的归并结果：[0,4,7,8。 而此时的递归调用栈只有一个mergeSort函数了，mergeSort会进行最终的合并（上面代码段中的//3），调用_merge函数，得到了最终的结果：[0, 2, 3, 4, 5, 7, 8, 9]。 关于归并排序的性能：由于使用了分治和递归并且利用了一些其他的内存空间，所以其性能是高于上述介绍的所有排序的，不过前提是初始元素量不小的情况下。 我们可以将选择排序和归并排序做个比较：初始数组为长度500，最大值为500的随机数组： 12345selection sort...selection sort time duration : 12.7smerge sort...merge sort time duration : 5.21s 可以看到归并排序的算法是优与选择排序的。 现在我们知道归并排序使用了分治思想而且使用了递归，能够高效地将数组排序。其实还有一个也是用分治思想和递归，但是却比归并排序还要优秀的算法 - 快速排序算法。 快速排序快速排序算法被称之为20世纪十大算法之一，也是各大公司面试比较喜欢考察的算法。 算法讲解快速排序的基本思想是：通过一趟排序将带排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。 上述文字摘自《大话数据结构》 它的实现步骤为： 从数列中挑出一个元素（挑选的算法可以是随机，也可以作其他的优化），称为”基准”（pivot）。 重新对数组进行排序：所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面，相同的放两边。 递归地进行分区操作，继续把小于基准值元素的子数列和大于基准值元素的子数列排序。 从上面的描述可以看出，分区操作是快速排序中的核心算法。下面笔者结合实例来描述一下分区操作的过程。 首先拿到初始的数组：[5,4,9,1,3,6,7,8,2] 选择5作为pivot。 从剩下部分的两端开始：左侧1的标记为low，最右侧2的标记为high。 先看j：2 &lt; 5 , 交换5和2，j不变 ：[2,4,9,1,3,6,7,8,5] ； 再看i：2 &lt; 5 , i ++ ；4 &lt; 5, i++；9 &gt; 5，交换 9 和 5，i不变[2,4,5,1,3,6,7,8,9]。 代码实现使用Swift的filter函数因为在Swift中有一个数组的filter函数可以找出数组中符合某范围的一些数值，所以笔者先介绍一个会用该函数的简单的快速排序的实现： 12345678910func quickSort0&lt;T: Comparable&gt;(_ array: [T]) -&gt; [T] &#123; guard array.count &gt; 1 else &#123; return array &#125; let pivot = array[array.count/2] let less = array.filter &#123; $0 &lt; pivot &#125; let greater = array.filter &#123; $0 &gt; pivot &#125; return quickSort0(less) + quickSort0(greater)&#125; 不难看出这里面使用了递归：选中pivot以后，将数组分成了两个部分，最后将它们合并在一起。虽然这里面使用了Swift里面内置的函数来找出符合这两个个部分的元素，但是读者可以通过这个例子更好地理解快速排序的实现方式。 使用取index = 0 的partition函数除了使用swift内置的filter函数，当然我们也可以自己实现分区的功能，通常使用的是自定义的partition函数。 123456789101112131415161718192021222324func _partition(_ array: inout [Int], low: Int, high: Int) -&gt; Int&#123; var low = low var high = high let pivotValue = array[low] while low &lt; high &#123; while low &lt; high &amp;&amp; array[high] &gt;= pivotValue &#123; high -= 1 &#125; array[low] = array[high] while low &lt; high &amp;&amp; array[low] &lt;= pivotValue &#123; low += 1 &#125; array[high] = array[low] &#125; array[low] = pivotValue return low&#125; 从代码实现可以看出，最初在这里选择的pivotValue是当前数组的第一个元素。 然后从数组的最右侧的index逐渐向左侧移动，如果值大于pivotValue，那么index-1；否则直接将high与low位置上的元素调换；同样左侧的index也是类似的操作。 该函数执行的最终效果就是将最初的array按照选定的pivotValue前后划分。 那么_partition如何使用呢？ 1234567891011func quickSort1(_ array: inout [Int], low: Int, high: Int)&#123; guard array.count &gt; 1 else &#123; return &#125; if low &lt; high &#123; let pivotIndex = _partition(&amp;array, low: low, high: high) quickSort1(&amp;array, low: low, high: pivotIndex - 1) quickSort1(&amp;array, low: pivotIndex + 1, high: high) &#125; &#125; 外层调用的quickSort1是一个递归函数，不断地进行分区操作，最终得到排好序的结果。 我们将上面实现的归并排序，使用swift内置函数的快速排序，以及自定义partition函数的快速排序的性能作对比： 123456merge sort...merge sort time duration : 4.85squick sort...quick sort0 time duration : 984ms //swift filter functionquick sort1 time duration : 2.64s //custom partition 上面的测试用例是选择随机数组的，我们看一下测试用例为元素个数一致的基本有序的数组试一下： 123456merge sort...merge sort time duration : 4.88squick sort...quick sort0 time duration : 921msquick sort1 time duration : 11.3s 虽然元素个数一致，但是性能却差了很多，是为什么呢？因为我们在分区的时候，pivot的index强制为第一个。那么如果这个第一个元素的值本来就非常小，那么就会造成分区不均的情况（前重后轻），而且由于是迭代操作，每次分区都会造成分区不均，导致性能直线下降。所以有一个相对合理的方案就是在选取pivot的index的时候随机选取。 使用随机选择pivotValue的partition函数实现方法肯简单，只需在分区函数里将pivotValue的index随机生成即可： 12345678910func _partitionRandom(_ array: inout [Int], low: Int, high: Int) -&gt; Int&#123; let x = UInt32(low) let y = UInt32(high) let pivotIndex = Int(arc4random() % (y - x)) + Int(x) let pivotValue = array[pivotIndex] ...&#125; 现在用一个数组长度和上面的测试用例一致的基本有序的数组来测试一下随机选取pivotValue的算法： 1234567merge sort...merge sort time duration : 4.73squick sort...quick sort0 time duration : 866msquick sort1 time duration : 15.1s //fixed pivote indexquick sort2 time duration : 4.28s //random pivote index 我们可以看到当随机抽取pivot的index的时候，其运行速度速度是上面方案的3倍。 现在我们知道了3种快速排序的实现，都是根据pivotValue将原数组一分为二。但是如果数组中有大量的重复的元素，而且pivotValue很有可能落在这些元素里，那么显然上面这些算法对于这些可能出现多次于pivotValue重复的情况没有单独做处理。而为了很好解决存在与pivot值相等的元素很多的数组的排序，使用三路排序算法会比较有效果。 三路快速排序三路快速排序将大于，等于，小于pivotValue的元素都区分开，我们看一下具体的实现。先看一下partition函数的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455func swap(_ arr: inout [Int], _ j: Int, _ k: Int) &#123; guard j != k else &#123; return; &#125; let temp = arr[j] arr[j] = arr[k] arr[k] = temp&#125;func quickSort3W(_ array: inout [Int], low: Int, high: Int) &#123; if high &lt;= low &#123; return &#125; var lt = low // arr[low+1...lt] &lt; v var gt = high + 1 // arr[gt...high] &gt; v var i = low + 1 // arr[lt+1...i) == v let pivoteIndex = low let pivoteValue = array[pivoteIndex] while i &lt; gt &#123; if array[i] &lt; pivoteValue &#123; swap(&amp;array, i, lt + 1) i += 1 lt += 1 &#125;else if pivoteValue &lt; array[i]&#123; swap(&amp;array, i, gt - 1) gt -= 1 &#125;else &#123; i += 1 &#125; &#125; swap(&amp;array, low, lt) quickSort3W(&amp;array, low: low, high: lt - 1) quickSort3W(&amp;array, low: gt, high: high) &#125;func quickSort3(_ array: inout [Int] )&#123; quickSort3W(&amp;array, low: 0, high: array.count - 1) &#125; 主要看quickSort3W方法，这里将数组分成了三个区间，分别是大于，等于，小于pivote的值，对有大量重复元素的数组做了比较好的处理。 我们生成一个元素数量为500，最大值为5的随机数组看一下这些快速排序算法的性能： 123quick sort1 time duration : 6.19s //fixed pivote indexquick sort2 time duration : 8.1s //random pivote indexquick sort3 time duration : 4.81s //quick sort 3 way 可以看到三路快速排序（quick sort 3 way）在处理大量重复元素的数组的表现最好。 对于三路快速排序，我们也可以使用Swift内置的filter函数来实现: 1234567891011func quicksort4(_ array: [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; let pivot = array[array.count/2] let less = array.filter &#123; $0 &lt; pivot &#125; let equal = array.filter &#123; $0 == pivot &#125; let greater = array.filter &#123; $0 &gt; pivot &#125; return quicksort4(less) + equal + quicksort4(greater)&#125; 以上，介绍完了快速排序在Swift中的5中实现方式。 最后的话总结本文讲解了算法的一些基本概念以及结合了Swift代码的实现讲解了冒泡排序，选择排序，插入排序，归并排序，快速排序。相信认真阅读本文的读者能对这些算法有进一步的了解。 关于算法学习的思考关于算法的学习，笔者有一些思考想分享出来，也有可能有不对的地方，但笔者觉得有必要在这里说出来，希望可以引发读者的思考： 上图的Question是指问题；Mind是指想法，或者解决问题的思路；Code是指代码实现。 在阅读资料或书籍的算法学习过程，往往是按照图中1，2，3这些实线的路径进行的： 路径1：给出一个既定的问题后，马上给出解题策略 路径2：给出一个既定的问题后，马上给出算法实现 路径3：给出一个算法实现后，马上告诉你这些实现代码的意思 这些路径在算法的学习中虽然也是必不可少的，但是很容易给人一个错觉，这个错觉就是“我已经学会了这个算法了”。但是，仅仅是通过这些路径，对于真正理解算法，和今后对算法的应用还是远远不够的，原因是： 今后遇到的问题，几乎不可能与现在学习的问题一模一样，所以应该知其所以然，将问题本身抽象出来，达到触类旁通，举一反三。 有了一个新想法，如果没有足够的代码实现经验，很难以非常合理的方式用代码将其实现出来。所以应该增强将想法转化为代码的能力。 上面所说的两点的第一点，对应的是上图的路径4：给定一个策略或是设计，要思考这个策略或是设计是解决什么样的问题的，这样也就理解了这个策略或是设计的意义在哪里；而第二点对应的是上图中的路径5：怎样根据一个给定的策略来正确地，合理地用代码地实现出来；而上图中的路径6，笔者觉得也很重要：给定一份解决问题的代码，是否可以想到它所对应的问题是什么。 综上所述，笔者认为对于算法的学习，需要经常反复在问题，策略以及代码之间反复思考，这样才能真正地达到学以致用。]]></content>
      <categories>
        <category>Data Structure &amp; Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构 & 算法 in Swift （一）：Swift基础和数据结构]]></title>
    <url>%2F2019%2F08%2F29%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%26%20%E7%AE%97%E6%B3%95%20in%20Swift%20%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ASwift%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[写在前面从本文标题中的序号可以看出，本文是一个连载的开篇。而且这个连载的标题是：数据结构 &amp; 算法 in Swift。从这个连载的标题中可以看出，笔者分享的是使用Swift语言来实现所学的的数据结构和算法的知识。这里面需要解释两点：第一：为什么学习数据结构和算法？学习通用性知识，突破技能瓶颈：笔者做iOS开发也有两年了，这期间通过从项目，第三方源码，相关应用类的编程书籍提高了些技术水平。而作为没学过数据结构和算法的非科班大军中的一员，这些知识始终是绕不过去的。因为对此类知识的掌握程度会对今后编程技能的提高有着无可估量的影响，所以就决定学习了。 第二：为什么用Swift语言来实现？ 选择哪个语言并不重要，重要的是数据结构和算法本身的理解：通过两个星期的学习，如今笔者已经可以使用Swift语言来实现几种数据结构和算法了，但我相信如果我使用C语言或者Objective-C语言的话会学得更快些，因为在实现的时候由于对该语言的不熟悉导致在实现过程中踩了不少坑。不过可以反过来思考：如果我可以使用Swift来实现这些，那么我今后用C，Objective-C，甚至是Java就容易多了，再加上我还顺便学习了Swift不是么？ 如今Swift的势头还在上涨：笔者已经观察到很多新的库，教学都使用了Swift语言。而且听说一些面试的朋友在面试过程中多少有问过Swift相关的知识，一些公司的新项目也有用Swift写了。 该系列的最佳受众是那些已经会Swift，但是对数据结构和算法还没有过多接触过的iOS开发者。其次是那些不会Swift也不会数据结构和算法的iOS开发者，毕竟Swift是大势所趋。 不过对于那些非iOS开发者来说也同样适合，因为还是那句话：重点不在于使用哪种语言，而是数据结构和算法本身。除了第一篇会讲解一些在这个系列文章会使用到的Swift基础语法以外，后续的文章我会逐渐弱化对Swift语言的讲解，将重点放在数据结构和算法这里。而且后续我还会不断增加其他语言的实现（Java语言是肯定要加的，其他的语言还待定）。 好了，背景介绍完了，现在正式开始： 作为该系列的开篇，本文分为两个部分： Swift语法基础：讲解一下后续连载中讲到的数据结构和算法所涉及到的Swift语法知识（并不是很全面，也不是很深入，但是在实现数据结构和算法这块应该是够了）。 数据结构：简单介绍数据结构和算法的相关概念，以及用Swift来实现几个简单的数据结构（链表，栈，队列） 注：该系列涉及到的Swift语法最低基于Swift4.0。 Swift 语法基础Swift语法基础从以下几点来展开： 循环语句 泛型 guard 函数 集合 循环语句循环条件的开闭区间Swift将循环的开闭区间做了语法上的简化： 闭区间：12345678for index in 1...5 &#123; print("index: \(index)")&#125;// index : 1// index : 2// index : 3// index : 4// index : 5 半开闭区间：1234567for index in 1..&lt;5 &#123; print("index: \(index)")&#125;// index : 1// index : 2// index : 3// index : 4 循环的升序与降序上面两个例子都是升序的（index从小到大），我们来看一下降序的写法： 1234567for index in (1..&lt;5).reversed() &#123; print("index: \(index)")&#125;// index : 4// index : 3// index : 2// index : 1 降序的应用可以在下篇的冒泡排序算法中可以看到。 泛型使用泛型可以定义一些可复用的函数或类型，Swift中的Array和Dictionary都是泛型的集合。 为了体现出泛型的意义，下面举一个例子来说明一下： 实现这样一个功能:将传入该函数的两个参数互换。 整型的交换： 12345func swapTwoInts(_ a: inout Int, _ b: inout Int) &#123; let tmp = a a = b b = tmp&#125; 字符串的交换： 12345func swapTwoStrings(_ a: inout String, _ b: inout String) &#123; let tmp = a a = b b = tmp&#125; 浮点型的交换： 12345func swapTwoDoubles(_ a: inout Double, _ b: inout Double) &#123; let tmp = a a = b b = tmp&#125; 上面这三种情况的实现部分其实都是一样的，但仅仅是因为传入类型的不一致，导致对于不同的类型还要定义一个新的函数。所以如果类型有很多的话，定义的新函数也会很多，这样显然是不够优雅的。 此类问题可以使用泛型来解决： 12345func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) &#123; let tmp = a a = b b = tmp&#125; 上面函数中的T是泛型的固定写法，可以理解为“所有类型”。这样一来，我们可以传入任何相同的类型来作交换了。 泛型还有其他比较强大的功能，由于在后续的数据结构和算法的讲解里面可能不会涉及到，所以在这里先不赘述了。有兴趣的朋友可以参考官方文档：Swift：Generics guard guard是 swift 2.0推出的新的判断语句的用法。 与if语句相同的是，guard也是基于一个表达式的布尔值去判断一段代码是否该被执行。与if语句不同的是，guard只有在条件不满足的时候才会执行这段代码。你可以把guard近似的看做是Assert，但是你可以优雅的退出而非崩溃 使用guard语法，可以先对每个条件逐一做检查，如果不符合条件判断就退出（或者进行其他某些操作）。这就会让人容易看出来什么条件会让这个函数退出（或者进行其他某些操作）。 可以用一个例子来分别使用if和guard来实现，体会二者的区别： 使用if-else1234567891011121314151617181920212223242526//money: holding moneny (用户持有的钱数)//price: product price (商品的价格)//capacity: bag capacity (用户用来装商品的袋子容量)//volume: product size (商品的大小)func buying1( money: Int , price: Int , capacity: Int , volume: Int)&#123; if money &gt;= price&#123; if capacity &gt;= volume&#123; print("Start buying...") print("\(money-price) money left after buying.") print("\(capacity-volume) capacity left after buying.") &#125;else&#123; print("No enough capacity") &#125; &#125;else&#123; print("No enough money") &#125;&#125; 从上面的逻辑可以看出，当同时满足： 用户的钱数&gt;商品价格 用户用来装商品的袋子容量&gt;商品的大小 这两个情况的时候，购买才会进行，其他所有情况都无法引发购买。 对于大多数习惯使用if-else的朋友来说，上面的代码立即起来并没有难度，但是相同的逻辑，我们看一下使用guard之后的效果： 使用guard12345678910111213141516func buying2( money: Int , price: Int , capacity: Int , volume: Int)&#123; guard money &gt;= price else&#123; print("No enough money") return &#125; guard capacity &gt;= volume else&#123; print("No enough capacity") return &#125; print("Start buying...") print("\(money-price) money after buying.") print("\(capacity-volume) capacity left after buying.")&#125; 从上面的实现可以看出： 使用guard以后，将money &lt; price和capacity &lt; volume 这两个情况首先排除掉并填上了相应的处理代码。 在两个guard下面才是真正正确逻辑后的处理代码。 因此通过两个guard判断的语句，我们知道该函数所处理的正确逻辑是什么，非常清晰。 函数因为后续的数据结构和算法的讲解是离不开函数的使用的，所以在这里简单介绍一下Swift中函数的使用。 无返回值的函数 有返回值的函数 省略函数的外部参数名 值传递和引用传递 无返回值的函数123456func log(message: String) &#123; print("log: \(message)!")&#125;log(message: "memory warning")// output: log: memory warning! 有返回值的函数1234567func logString(string: String) -&gt; String &#123; return "log: " + string&#125;let logStr = logString(string: "memory warning!")print("\(logStr)")// output: log: memory warning! 省略函数外部参数名通过在函数形参前面加上_,可以起到在调用时省略外部参数的作用： 123456func logMessage(_ message: String) &#123; print("log: \(message)!")&#125;logMessage("memory warning")// output: log: memory warning! 再来看一下两个参数的情况： 123456func addInt(_ a : Int ,_ b : Int)&#123; print("sum is \(a + b)")&#125;addInt(3, 4)//output : sum is 7 值传递和引用传递Swift中，struct是按值传递，class是按引用传递。数组和字典在Swift里是属于struct，所以需要如果在一个函数里要修改传入的数组，需要做特殊处理： 123456789101112var originalArr = [2,1,3]func removeLastInArray(_ array: inout [Int])&#123; array.removeLast()&#125;print("\n============ before removing: \(originalArr)")//[2, 1, 3]removeLastInArray(&amp;originalArr)print("============ after removing: \(originalArr)")//[2, 1] 在这里使用的inout关键字就是将传入的数组改为引用传递了。 集合Swift里的集合类型有：数组，集合，字典，下面来分别讲一下。 这三种类型都支持泛型，也就是说里面的元素可以是整数，字符串，浮点等等。 数组 Swift’s Array type is bridged to Foundation’s NSArray class. 可变数组与不可变数组12345// immutable arraylet immutableNumbers: [Int] = [1, 3, 5, 4, 4, 1]// mutable arrayvar mutableNumbers : [Int] = [2, 1, 5, 4, 1, 3] Swift中可以用let和var来分别声明可变和不可变数组：数组的添加删除等操作只能作用于可变数组。 数组的遍历123456789101112131415161718// iteration 1for value in mutableNumbers &#123; if let index = mutableNumbers.index(of: value) &#123; print("Index of \(value) is \(index)") &#125;&#125;// iteration 2mutableNumbers.forEach &#123; value in if let index = mutableNumbers.index(of: value) &#123; print("Index of \(value) is \(index)") &#125;&#125;// iteration 3for (index, value) in mutableNumbers.enumerated() &#123; print("Item \(index + 1): \(value)")&#125; 数组的操作1234567891011121314151617181920mutableNumbers.append(11)// Output: [2, 1, 5, 4, 1, 3, 11]mutableNumbers.insert(42, at: 4)// Output: [2, 1, 5, 4, 42, 1, 3, 11]mutableNumbers.swapAt(0, 1)// Output: [1, 2, 5, 4, 42, 1, 3, 11]mutableNumbers.remove(at: 1)// Output: [2, 5, 4, 42, 1, 3, 11]mutableNumbers.removeFirst()// Output: [5, 4, 42, 1, 3, 11]mutableNumbers.removeLast()// Output: [5, 4, 42, 1, 3]mutableNumbers.removeAll()//[] append函数的作用是在数组的末尾添加元素 swapAt函数的作用是交换在传入的两个index上的元素，该方法在下篇的排序算法中使用得非常频繁。 集合 Swift’s Set type is bridged to Foundation’s NSSet class. 集合的无序性，值的唯一性关于集合与数组的区别，除了数组有序，集合无序以外，数组内部的元素的数值可以不是唯一的；但是集合里元素的数值必须是唯一的，如果有重复的数值会算作是一个： 12345678//value in set is uniquelet onesSet: Set = [1, 1, 1, 1]print(onesSet)// Output: [1]let onesArray: Array = [1, 1, 1, 1]print(onesArray)// Output: [1, 1, 1, 1] 集合的遍历1234567891011121314151617let numbersSet: Set = [1, 2, 3, 4, 5]print(numbersSet)// Output: undefined order, e.g. [5, 2, 3, 1, 4]// iteration 1for value in numbersSet &#123; print(value)&#125;// output is in undefined order// iteration 2numbersSet.forEach &#123; value in print(value)&#125;// output is in undefined order 集合的操作123456789101112131415161718192021222324252627282930313233343536373839var mutableStringSet: Set = ["One", "Two", "Three"]let item = "Two"//containsif mutableStringSet.contains(item) &#123; print("\(item) found in the set")&#125; else &#123; print("\(item) not found in the set")&#125;//isEmptylet strings = Set&lt;String&gt;()if strings.isEmpty &#123; print("Set is empty")&#125;//countlet emptyStrings = Set&lt;String&gt;()if emptyStrings.count == 0 &#123; print("Set has no elements")&#125;//insertmutableStringSet.insert("Four")//remove 1mutableStringSet.remove("Three")//remove 2if let removedElement = mutableStringSet.remove("Six") &#123; print("\(removedElement) was removed from the Set")&#125; else &#123; print("Six is not found in the Set")&#125;//removeAll()mutableStringSet.removeAll()// [] 字典 A dictionary Key type must conform to the Hashable protocol, like a set’s value type. 字典的声明12345678//empty dictionaryvar dayOfWeek = Dictionary&lt;Int, String&gt;()var dayOfWeek2 = [Int: String]()//not empty dictionaryvar dayOfWeek3: [Int: String] = [0: "Sun", 1: "Mon", 2: "Tue"]print(dayOfWeek3)//output:[2: "Tue", 0: "Sun", 1: "Mon"] 可以看到字典的键值对也是无序的，它与声明时的顺序不一定一致。 字典的遍历1234567891011121314// iteration 1for (key, value) in dayOfWeek &#123; print("\(key): \(value)")&#125;// iteration 2for key in dayOfWeek.keys &#123; print(key)&#125;// iteration 3for value in dayOfWeek.values &#123; print(value)&#125; 字典的操作123456789101112131415161718192021222324252627282930313233343536// find valuedayOfWeek = [0: "Sun", 1: "Mon", 2: "Tue"]if let day = dayOfWeek[2] &#123; print(day)&#125;// addValue 1dayOfWeek[3] = "Wed"print(dayOfWeek)// Prints: [2: "Tue", 0: "Sun", 1: "Mon", 3: "Wed"]// updateValue 1dayOfWeek[2] = "Mardi"print(dayOfWeek)// Prints: [2: "Mardi", 0: "Sun", 1: "Mon", 3: "Wed"]// updateValue 2dayOfWeek.updateValue("Tue", forKey: 2)print(dayOfWeek)// Prints: [2: "Tue", 0: "Sun", 1: "Mon", 3: "Wed"]// removeValue 1dayOfWeek[1] = nilprint(dayOfWeek)// Prints: [2: "Tue", 0: "Sun", 3: "Wed"]// removeValue 2dayOfWeek.removeValue(forKey: 2)print(dayOfWeek)// Prints: [0: "Sun", 3: "Wed"]// removeAlldayOfWeek.removeAll()print(dayOfWeek)// Output: [:] 可以看到从字典里面删除某个键值对有两个方法： 使用removeValue方法并传入要删除的键值对里的键。 将字典取下标之后将nil赋给它。 数据结构这一部分内容主要是对连载的后续文章作铺垫，让大家对数据结构先有一个基本的认识，因此在概念上不会深入讲解。该部分由以下三点展开： 数据结构的基本概念 抽象数据类型 链表，栈和队列的实现 概念首先我们来看一下数据结构的概念： 数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。 由数据结构这个词汇的本身（数据的结构）以及它的概念可以看出，它的重点在于“结构”和“关系”。所以说，数据是何种数据并不重要，重要的是这些数据是如何联系起来的。 而这些联系，可以从两个维度来展开： 逻辑结构：指数据对象中元素之间的相互关系。 物理结构：指数据的逻辑结构在计算机中的存储形式。 可以看出，逻辑结构是抽象的联系，而物理结构是实际在计算机内存里的具体联系。那么它们自己又细分为哪些结构呢？ 逻辑结构： 集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。 线性结构：线性结构中的数据元素之间是一对一的关系。 树形结构：数据结构中的元素存在一对多的相互关系。 图形结构：数据结构中的元素存在多对多的相互关系。 物理结构： 顺序存储结构：把数据元素粗放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的（数组）。 链式存储结构：把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。 为了便于记忆，用思维导图总结一下上面所说的： 而通过结合这两个维度中的某个结构，可以定义出来一个实际的数据结构的实现： 比如线性表就是线性结构的一种实现： 顺序存储结构的线性表就是数组：它的内存分布是连续的，元素之间可以通过内存地址来做关联； 链式存储结构的线性表就是 链表 ：它的内存分布可以是不连续的，元素之间通过指针来做关联： 如果每个元素（在链表中称作节点）只持有指向后面节点的指针，那此链表就是单链表。 如果每个元素（在链表中称作节点）持有指向前后节点的两个指针，那此链表就是双链表。 为什么会有链表这么麻烦的东西？像数组这样，所有内存地址都是连续的不是很方便么？既生瑜何生亮呢？ 对于获取元素（节点）这一操作，使用数组这个数据结构确实非常方便：因为所有元素在内存中是连续的，所以只需要知道数组中第一个元素的地址以及要获取元素的index就能算出该index内存的地址，一步到位非常方便。 但是对于向数组中某个index中插入新的元素的操作恐怕就没有这么方便了：恰恰是因为数组中所有元素的内存是连续的，所以如果想在中间插入一个新的元素，那么这个位置后面的所有元素都要后移，显然是非常低效的。如果插在数组尾部还好，如果插在第一位的话成本就太高了。 而如果使用链表，只要把要插入到的index前后节点的指针赋给这个新的节点就可以了，不需要移动原有节点在内存中的位置。 关于链表的这种插入操作会在后面用代码的形式体现出来。 既然有这么多的数据结构，那么有没有一个标准的格式来将这些特定的数据结构（也可以说是数学模型）抽象出来呢？答案是肯定的，它就是我们下一节要讲的抽象数据类型。 抽象数据类型首先来看一下抽象数据类型的概念，摘自《大话数据结构》: 抽象数据类型（Abstract Data Type，ADT）：是指一个数学模型及定义在该模型上的一组操作。 需要注意的是：抽象数据类型的定义仅仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现没有关系。而且，抽象数据类型不仅仅指那些已经定义并实现的数据类型，还尅是计算机编程者自己定义的数据类型。 我们看一下数据类型的标准格式： 1234567891011121314151617ADT 抽象数据类型名Data 数据元素之间逻辑关系的定义 Operation 操作1 初始条件 操作结果描述 操作2 初始条件 操作结果描述 操作nendADT 其实看上去和面向对象编程里的类的定义相似： 可以把抽象数据类型的Data 和 类的成员变量联系起来。 可以把抽象数据类型的操作和类的函数联系起来。 简单来说，抽象数据类型描述了一个数据模型所使用的数据和数据之间的逻辑关系，以及它可以执行的一些操作。因此，如果知道了一个数学模型的抽象数据类型，那么在真正接触数学模型的实现（代码）之前，就可以对该数学模型能做的事情有一个大致的了解。 下一章笔者会介绍链表，栈和队列这三个数学模型，在讲解每个数学模型的实现之前都会给出它们各自的抽象数据类型，让读者可以先对当前数学模型有个大致的了解。 注意：书本文归纳的所有抽象数据类型是笔者自己根据网上资料和相关书籍而定下来的，所以严格来说它们并不是“最官方”的抽象数据类型。读者也可以参考网上的资料或是相关书籍，结合自己的思考来定义自己对着三个数据模型的抽象数据类型。 链表，栈和队列的实现通过上一节的介绍，我们知道了数据结构的概念以及分类，还知道了不同的数据结构在不同的场景下会发挥不同的优势，我们要根据实际的场景来选择合适的数据结构。 下面就来介绍几种在实际应用中使用的比较多的数学模型： 链表 栈 队列 链表（Linked list）说到链表就不得不提线性表这一数据结构，在介绍链表之前，首先看一下线性表的定义： 线性表：零个或多个数据元素的有限序列。 而根据物理结构的不同，线性表有两种具体的实现方式： 线性表的顺序存储结构：线性表的数据元素是被一段地址连续的存储单存储起来的。 线性表的链式存储结构: 线性表的数据元素是被用一组连续或不连续的存储单元存储起来的，这些元素通过指针来作为逻辑上的连接。 注：上面两个概念是笔者用自己的话总结出来的。 在这里，线性表的顺序存储结构的实现就是我们熟悉的数组；而线性表的链式存储结构的实现就是笔者即将要介绍的链表。 链表的定义相信对于读完上一节的朋友来说，应该对链表有一个比较清晰的认识了。关于链表的定义有很多不同的版本，笔者个人比较喜欢百度百科里的定义： 链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。 而且由于数据元素所持有的指针个数和链接特性可以将链表分为： 单向链表：单向链表的链接方向是单向的，其中每个结点都有指针成员变量指向列表中的下一个结点； 双向链表：双向链表的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点，它的链接方向是双向的。 循环链表：循环链表是另一种形式的链式存贮结构。它的特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。 笔者从中挑选出双向链表来进行讲解，它的难度适中，而且能够很好地让读者体会出链表的优势。 双向链表的抽象数据类型因为节点是链表的基本组成单元，所以想要实现链表，必须先要介绍链表的组成部分-节点。 节点： 1234567891011ADT 节点(node)Data value:持有的数据Operation init:初始化 previous:指向上一节点的指针 next:指向下一节点的指针 endADT 再来看一下链表的抽象数据类型： 1234567891011121314151617181920ADT 链表（linked list）Data linked list:持有的线性表Operation init:初始化 count:持有节点总个数 isEmpty:是否为空 first:头节点 last:尾节点 node:传入index返回节点 insert:插入node到指定index insertToHead:插入节点到表头 appendToTail:插入节点到表尾 removeAll:移除所有节点 remove:移除传入的节点 removeAt:移除传入index的节点 endADT 双向链表的实现节点1234567891011121314151617public class LinkedListNode&lt;T&gt; &#123; //value of a node var value: T //pointer to previous node weak var previous: LinkedListNode? //pointer to next node var next: LinkedListNode? //init public init(value: T) &#123; self.value = value &#125;&#125; 再来看一下链表的实现： 因为整个链表的插入，删除等操作比较多，整个链表的定义超过了200行代码，所以为了看着方便一点，在这里来分段说明一下。 首先看一下链表的成员变量: 成员变量12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class LinkedList&lt;T&gt; &#123; public typealias Node = LinkedListNode&lt;T&gt; //if empty public var isEmpty: Bool &#123; return head == nil &#125; //total count of nodes public var count: Int &#123; guard var node = head else &#123; return 0 &#125; var count = 1 while let next = node.next &#123; node = next count += 1 &#125; return count &#125; //pointer to the first node, private private var head: Node? //pointer to the first node, public public var first: Node? &#123; return head &#125; //pointer to the last node public var last: Node? &#123; guard var node = head else &#123; return nil &#125; //until node.next is nil while let next = node.next &#123; node = next &#125; return node &#125; ... &#125; 相信看上面的命名以及注释大家可以对链表的成员变量有个初步的理解，这里面需要说三点： typealias是用来重新为已经存在的类型命名的：这里用Node代替了LinkedListNode&lt;T&gt;（节点类型），降低了不少阅读代码的成本。 在获取count和last的实现，都先判断了head这个指针是否为nil，如果是则判定为空链表，自然也就不存在节点个数和最后的节点对象了。 同样地，也是在获取count和last的实现里，使用了while控制语句来判断node.next节点是否存在：如果存在，则继续+1或者继续往下寻找，直到node.next为nil时才停止。在这里我们可以看到链表的寻址方式：是通过头结点开始，以节点的.next指针来寻找下一个节点的。而且作为链表的尾节点，它的.next指针不指向任何对象，因为它本来就是链表的最后一项。 最下方的…代表即将在下面介绍的一些函数，这些函数都定义在的LinkedList这个class里面。 获取index上node1234567891011121314151617181920212223242526//get node of indexpublic func node(atIndex index: Int) -&gt; Node? &#123; if index == 0 &#123; //head node return head! &#125; else &#123; var node = head!.next guard index &lt; count else &#123; return nil; &#125; for _ in 1..&lt;index &#123; // go on finding by .next node = node?.next if node == nil &#123; break &#125; &#125; return node! &#125;&#125; 注意在这里返回的node是可以为nil的，而且在这里可以看出来，链表在寻找特定node的时候，是根据节点的.next指针来一个一个寻找的。这个与顺序存储结构的数组是不同的，在后面我会重点讲解一下这二者的不同。 插入节点12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//insert node to last indexpublic func appendToTail(value: T) &#123; let newNode = Node(value: value) if let lastNode = last &#123; //update last node: newNode becomes new last node; //the previous last node becomes the second-last node newNode.previous = lastNode lastNode.next = newNode &#125; else &#123; //blank linked list head = newNode &#125;&#125;//insert node to index 0public func insertToHead(value: T) &#123; let newHead = Node(value: value) if head == nil &#123; //blank linked list head = newHead &#125;else &#123; newHead.next = head head?.previous = newHead head = newHead &#125;&#125;//insert node in specific indexpublic func insert(_ node: Node, atIndex index: Int) &#123; if index &lt; 0 &#123; print("invalid input index") return &#125; let newNode = node if count == 0 &#123; head = newNode &#125;else &#123; if index == 0 &#123; newNode.next = head head?.previous = newNode head = newNode &#125; else &#123; if index &gt; count &#123; print("out of range") return &#125; let prev = self.node(atIndex: index-1) let next = prev?.next newNode.previous = prev newNode.next = prev?.next prev?.next = newNode next?.previous = newNode &#125; &#125;&#125; 链表的插入节点的操作分为三种，按照从上到下的顺序依次是： 在头部插入 在尾部插入 指定index插入 需要注意的是 在前两种插入函数中，需要先判断该链表是否是空的，如果是，则要将链表的该节点赋给链表的head指针。 在第三种插入函数中，还是先判断该链表是否是空的，如果是，则无论index是多少(只要不小于0)，都插在链表的头部。如果不是空的，再判断index是否为0，如果是，则直接插在头部；如果index不为0，则判断index是否大于count，如果是，则无法插入；如果不是，则获取插入位置的前后节点进行重连。 在这里判断链表为空链表后的处理是笔者自己加上去的，笔者在网上的资料里没有看到过。大家不必纠结于这种处理方式，毕竟链表操作的重点在于前后节点的重连。 移除节点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//removing all nodespublic func removeAll() &#123; head = nil&#125;//remove the last nodepublic func removeLast() -&gt; T? &#123; guard !isEmpty else &#123; return nil &#125; return remove(node: last!)&#125;//remove a node by it's refrencepublic func remove(node: Node) -&gt; T? &#123; guard head != nil else &#123; print("linked list is empty") return nil &#125; let prev = node.previous let next = node.next if let prev = prev &#123; prev.next = next &#125; else &#123; head = next &#125; next?.previous = prev node.previous = nil node.next = nil return node.value&#125;//remove a node by it's indexpublic func removeAt(_ index: Int) -&gt; T? &#123; guard head != nil else &#123; print("linked list is empty") return nil &#125; let node = self.node(atIndex: index) guard node != nil else &#123; return nil &#125; return remove(node: node!)&#125; 如果要移除链表上所有节点，只需要将head指针置空就可以了，因为它是所有节点的“源头”，是链表寻址的第一个节点。 在持有某个节点的指针的时候可以指定链表来移除这个节点（使用remove函数）。在这个函数内部，首先需要将该节点的前后节点对接，然后将该几点的前后指针置空。 当有要移除节点的指针但是知道该节点在链表中的index，可以使用removeAt函数。在这个函数内部，首先根据index来获取对应的node的指针，然后再调用remove函数删除这个node。 打印所有节点12345678910111213141516171819202122public func printAllNodes()&#123; guard head != nil else &#123; print("linked list is empty") return &#125; var node = head print("\nstart printing all nodes:") for index in 0..&lt;count &#123; if node == nil &#123; break &#125; print("[\(index)]\(node!.value)") node = node!.next &#125;&#125; 该函数只是为了方便调试，为了跟踪链表的状态而定义的，它并不存在于链表的模型里。 为了验证上面这些方法的有效性，我们来实例化一个链表后实际操作一下，读者可以结合注释来看一下每一步对应的结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879let list = LinkedList&lt;String&gt;()list.isEmpty // truelist.first // nillist.count // 0list.appendToTail(value: "Swift")list.isEmpty // falselist.first!.value // "Swift"list.last!.value // "Swift"list.count //1list.appendToTail(value:"is")list.first!.value // "Swift"list.last!.value // "is"list.count // 2list.appendToTail(value:"great")list.first!.value // "Swift"list.last!.value // "great"list.count // 3list.printAllNodes()//[0]Swift//[1]is//[2]Greatlist.node(atIndex: 0)?.value // Swiftlist.node(atIndex: 1)?.value // islist.node(atIndex: 2)?.value // greatlist.node(atIndex: 3)?.value // nillist.insert(LinkedListNode.init(value: "language"), atIndex: 1)list.printAllNodes()//[0]Swift//[1]language//[2]is//[3]greatlist.remove(node: list.first!)list.printAllNodes()//[0]language//[1]is//[2]greatlist.removeAt(1)list.printAllNodes()//[0]language//[1]greatlist.removeLast()list.printAllNodes()//[0]languagelist.insertToHead(value: "study")list.count // 2list.printAllNodes()//[0]study//[1]languagelist.removeAll()list.printAllNodes()//linked list is emptylist.insert(LinkedListNode.init(value: "new"), atIndex: 3)list.printAllNodes()//[0]newlist.insert(LinkedListNode.init(value: "new"), atIndex: 3) //out of rangelist.printAllNodes()//[0]newlist.insert(LinkedListNode.init(value: "new"), atIndex: 1)list.printAllNodes()//[0]new//[1]new 栈（Stack）栈的讲解从 栈的定义 栈的抽象数据类型 栈的实现 三个部分来展开。 栈的定义首先来看一下栈的定义： 栈是限定仅在表的尾部进行插入和删除操作的线性表。 从定义中可以看出，我们知道我们只能在栈的一端来操作栈： 允许插入和删除的一端成为栈顶 另一端成为栈底 用一张图来看一下栈的操作： 图源：《维基百科：Stack (abstract data type)》 从上图可以看出，最先压入栈里面的只能最后访问，也就是说，栈遵循后进先出（Last In First Out, LIFO）的原则。 栈的抽象数据类型1234567891011121314ADT 栈（Stack）Data linked list:持有的线性表Operation init:初始化 count:栈的元素个数 isEmpty:是否为空 push:入栈 pop:出栈 top:返回顶部元素 endADT 上面的operation可能不全，但是涵盖了栈的一些最基本的操作。那么基于这个抽象数据类型，我们来看一下如何使用Swift来实现它。 栈的实现笔者将数组（顺序存储）作为栈的线性表的实现，同时支持泛型。 123456789101112131415ADT 栈（Stack）Data linked list:持有的线性表Operation init:初始化 count:栈的元素个数 isEmpty:是否为空 push:入栈 pop:出栈 top:返回顶部元素 endADT上面的operation可能不全，但是涵盖了栈的一些最基本的操作。那么基于这个抽象数据类型，我们来看一下如何使用Swift来实现它。 栈的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public struct Stack&lt;T&gt; &#123; //array fileprivate var stackArray = [T]() //count public var count: Int &#123; return stackArray.count &#125; //is empty ? public var isEmpty: Bool &#123; return stackArray.isEmpty &#125; //top element public var top: T? &#123; if isEmpty&#123; return nil &#125;else &#123; return stackArray.last &#125; &#125; //push operation public mutating func push(_ element: T) &#123; stackArray.append(element) &#125; //pop operation public mutating func pop() -&gt; T? &#123; if isEmpty&#123; print("stack is empty") return nil &#125;else &#123; return stackArray.removeLast() &#125; &#125; //print all public mutating func printAllElements() &#123; guard count &gt; 0 else &#123; print("stack is empty") return &#125; print("\nprint all stack elemets:") for (index, value) in stackArray.enumerated() &#123; print("[\(index)]\(value)") &#125; &#125;&#125; fileprivate：是Swift3.0新增的访问控制，表示在定义的声明文件里可访问。它代替了过去意义上的private。而有了fileprivate以后，新的private则代表了真正的私有：在这个类或结构体的外部无法访问。 这里printAllElements方法也不属于抽象数据类型里的方法，也是为了方便调试，可以打印出所有的数据元素。 我们来实例化上面定义的栈实际操作一下： 1234567891011121314151617181920212223242526272829303132333435var stack = Stack.init(stackArray: [])stack.printAllElements() //stack is emptystack.isEmpty //truestack.push(2)stack.printAllElements()//[0]2stack.isEmpty //falsestack.top //2stack.push(3)stack.printAllElements()//[0]2//[1]3stack.isEmpty //falsestack.top //3stack.pop()stack.printAllElements()//[0]2stack.isEmpty //falsestack.top //2stack.pop()stack.printAllElements() //stack is emptystack.top //nilstack.isEmpty //truestack.pop() //stack is empty 队列（Queue）队列的讲解从 队列的定义 队列的抽象数据类型 队列的实现 三个部分来展开。 队列的定义 图源：《维基百科：FIFO (computing and electronics)》 队列的抽象数据类型1234567891011121314ADT 队列（Queue）Data linked list:持有的线性表Operation init:初始化 count:栈的元素个数 isEmpty:是否为空 front:获取队列头元素 enqueue:插入到队尾 dequeue:删除队列头元素并返回 endADT 和上面的栈的实现一致，队列的实现也使用数组来实现队列内部的线性表。 队列的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public struct Queue&lt;T&gt; &#123; //array fileprivate var queueArray = [T]() //count public var count: Int &#123; return queueArray.count &#125; //is empty? public var isEmpty: Bool &#123; return queueArray.isEmpty &#125; //front element public var front: T? &#123; if isEmpty &#123; print("queue is empty") return nil &#125; else &#123; return queueArray.first &#125; &#125; //add element public mutating func enqueue(_ element: T) &#123; queueArray.append(element) &#125; //remove element public mutating func dequeue() -&gt; T? &#123; if isEmpty &#123; print("queue is empty") return nil &#125; else &#123; return queueArray.removeFirst() &#125; &#125; //print all public mutating func printAllElements() &#123; guard count &gt; 0 else &#123; print("queue is empty") return &#125; print("\nprint all queue elemets:") for (index, value) in queueArray.enumerated() &#123; print("[\(index)]\(value)") &#125; &#125; &#125; 我们初始化一个队列后实际操作一下： 123456789101112131415161718192021222324252627282930313233343536373839404142var queue = Queue.init(queueArray: [])queue.printAllElements()//queue is emptyqueue.isEmpty //truequeue.count //0queue.enqueue(2)queue.printAllElements()queue.isEmpty //false//[0]2queue.enqueue(3)queue.printAllElements()//[0]2//[1]3queue.enqueue(4)queue.printAllElements()//[0]2//[1]3//[2]4queue.front //2queue.dequeue()queue.printAllElements()//[0]3//[1]4queue.front //3queue.dequeue()queue.printAllElements()//[0]4queue.front //4queue.dequeue()queue.printAllElements() //queue is emptyqueue.front //return nil, and print : queue is emptyqueue.isEmpty //truequeue.count//0]]></content>
      <categories>
        <category>Data Structure &amp; Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[代码规范]]></title>
    <url>%2F2019%2F08%2F28%2F%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[这篇规范一共分为三个部分： 核心原则：介绍了这篇代码规范所遵循的核心原则。 通用规范：不局限于iOS的通用性的代码规范（使用C语言和Swift语言）。 iOS规范：仅适用于iOS的代码规范（使用Objc语言）。 一. 核心原则原则一：代码应该简洁易懂，逻辑清晰因为软件是需要人来维护的。这个人在未来很可能不是你。所以首先是为人编写程序，其次才是计算机： 不要过分追求技巧，降低程序的可读性。 简洁的代码可以让bug无处藏身。要写出明显没有bug的代码，而不是没有明显bug的代码。 原则二：面向变化编程，而不是面向需求编程。需求是暂时的，只有变化才是永恒的。本次迭代不能仅仅为了当前的需求，写出扩展性强，易修改的程序才是负责任的做法，对自己负责，对公司负责。 原则三：先保证程序的正确性，防止过度工程过度工程（over-engineering）：在正确可用的代码写出之前就过度地考虑扩展，重用的问题，使得工程过度复杂。引用《王垠：编程的智慧》里的话： 先把眼前的问题解决掉，解决好，再考虑将来的扩展问题。 先写出可用的代码，反复推敲，再考虑是否需要重用的问题。 先写出可用，简单，明显没有bug的代码，再考虑测试的问题。 二. 通用规范关于大括号 控制语句(if,for,while,switch)中，大括号开始与行尾 函数中，大括号要开始于行首 推荐这样写： 12345678910//控制语句white(someCondition)&#123;&#125;//函数void function(param1,param2)&#123;&#125; 运算符 1. 运算符与变量之间的间隔1.1 一元运算符与变量之间没有空格：12345!bValue~iValue++iCount*strSource&amp;fSum 1.2 二元运算符与变量之间必须有空格1234fWidth = 5 + 5;fLength = fWidth * 2;fHeight = fWidth + fLength;for(int i = 0; i &lt; 10; i++) 2. 多个不同的运算符同时存在时应该使用括号来明确优先级在多个不同的运算符同时存在的时候应该合理使用括号，不要盲目依赖操作符优先级。因为有的时候不能保证阅读你代码的人就一定能了解你写的算式里面所有操作符的优先级。 来看一下这个算式：2 &lt;&lt; 2 + 1 * 3 - 4 这里的&lt;&lt;是移位操作直观上却很容易认为它的优先级很高，所以就把这个算式误认为：(2 &lt;&lt; 2) + 1 3 - 4但事实上，它的优先级是比加减法还要低的，所以该算式应该等同于：2 &lt;&lt; (2 + 1 3 - 4)。所以在以后写这种复杂一点的算式的时候，尽量多加一点括号，避免让其他人误解（甚至是自己）。 变量 1. 一个变量有且只有一个功能，尽量不要把一个变量用作多种用途2. 变量在使用前应初始化，防止未初始化的变量被引用3. 局部变量应该尽量接近使用它的地方推荐这样写： 123456789101112func someFunction() &#123; let index = ...; //Do something With index ... ... let count = ...; //Do something With count &#125; 不推荐这样写： 1234567891011func someFunction() &#123; let index = ...; let count = ...; //Do something With index ... ... //Do something With count&#125; if语句 1. 必须列出所有分支（穷举所有的情况），而且每个分支都必须给出明确的结果。推荐这样写： 123456var hintStr;if (count &lt; 3) &#123; hintStr = "Good";&#125; else &#123; hintStr = "";&#125; 不推荐这样写： 1234var hintStr;if (count &lt; 3) &#123; hintStr = "Good";&#125; 2. 不要使用过多的分支，要善于使用return来提前返回错误的情况推荐这样写： 123456- (void)someMethod &#123; if (!goodCondition) &#123; return; &#125; //Do something&#125; 不推荐这样写： 12345- (void)someMethod &#123; if (goodCondition) &#123; //Do something &#125;&#125; 比较典型的例子我在JSONModel里遇到过： 12345678910111213141516171819202122232425262728293031323334353637383940-(id)initWithDictionary:(NSDictionary*)dict error:(NSError)err&#123; //方法1. 参数为nil if (!dict) &#123; if (err) *err = [JSONModelError errorInputIsNil]; return nil; &#125; //方法2. 参数不是nil，但也不是字典 if (![dict isKindOfClass:[NSDictionary class]]) &#123; if (err) *err = [JSONModelError errorInvalidDataWithMessage:@"Attempt to initialize JSONModel object using initWithDictionary:error: but the dictionary parameter was not an 'NSDictionary'."]; return nil; &#125; //方法3. 初始化 self = [self init]; if (!self) &#123; //初始化失败 if (err) *err = [JSONModelError errorModelIsInvalid]; return nil; &#125; //方法4. 检查用户定义的模型里的属性集合是否大于传入的字典里的key集合（如果大于，则返回NO） if (![self __doesDictionary:dict matchModelWithKeyMapper:self.__keyMapper error:err]) &#123; return nil; &#125; //方法5. 核心方法：字典的key与模型的属性的映射 if (![self __importDictionary:dict withKeyMapper:self.__keyMapper validation:YES error:err]) &#123; return nil; &#125; //方法6. 可以重写[self validate:err]方法并返回NO，让用户自定义错误并阻拦model的返回 if (![self validate:err]) &#123; return nil; &#125; //方法7. 终于通过了！成功返回model return self;&#125; 可以看到，在这里，首先判断出各种错误的情况然后提前返回，把最正确的情况放到最后返回。 3. 条件表达式如果很长，则需要将他们提取出来赋给一个BOOL值推荐这样写： 123456let nameContainsSwift = sessionName.hasPrefix("Swift")let isCurrentYear = sessionDateCompontents.year == 2014let isSwiftSession = nameContainsSwift &amp;&amp; isCurrentYearif (isSwiftSession) &#123; // Do something&#125; 不推荐这样写： 123if ( sessionName.hasPrefix("Swift") &amp;&amp; (sessionDateCompontents.year == 2014) ) &#123; // Do something&#125; 4. 条件语句的判断应该是变量在左，常量在右推荐这样写： 12if ( count == 6) &#123;&#125; 或者 12if ( object == nil) &#123;&#125; 或者 12if ( !object ) &#123;&#125; 不推荐这样写： 12if ( 6 == count) &#123;&#125; 或者 12if ( nil == object ) &#123;&#125; 5. 每个分支的实现代码都必须被大括号包围推荐这样写： 12if ( nil == object ) &#123;&#125; 不推荐这样写： 12if (!error) return success; 或者 1if (!error) return success; 6. 条件过多，过长的时候应该换行推荐这样写： 123456if (condition1() &amp;&amp; condition2() &amp;&amp; condition3() &amp;&amp; condition4()) &#123; // Do something&#125; 不推荐这样写： 123if (condition1() &amp;&amp; condition2() &amp;&amp; condition3() &amp;&amp; condition4()) &#123; // Do something&#125; for语句 1. 不可在for循环内修改循环变量，防止for循环失去控制。1234for (int index = 0; index &lt; 10; index++)&#123; ... logicToChange(index)&#125; 2. 避免使用continue和break。continue和break所描述的是“什么时候不做什么”，所以为了读懂二者所在的代码，我们需要在头脑里将他们取反。 其实最好不要让这两个东西出现，因为我们的代码只要体现出“什么时候做什么”就好了，而且通过适当的方法，是可以将这两个东西消灭掉的： 2.1 如果出现了continue，只需要把continue的条件取反即可1234567var filteredProducts = Array&lt;String&gt;()for level in products &#123; if level.hasPrefix("bad") &#123; continue &#125; filteredProducts.append(level)&#125; 我们可以看到，通过判断字符串里是否含有“bad”这个prefix来过滤掉一些值。其实我们是可以通过取反，来避免使用continue的： 12345for level in products &#123; if !level.hasPrefix("bad") &#123; filteredProducts.append(level) &#125;&#125; 2.2 消除while里的break：将break的条件取反，并合并到主循环里在while里的block其实就相当于“不存在”，既然是不存在的东西就完全可以在最开始的条件语句中将其排除。 while里的break： 123456while (condition1) &#123; ... if (condition2) &#123; break; &#125;&#125; 取反并合并到主条件： 123while (condition1 &amp;&amp; !condition2) &#123; ...&#125; 2.3 在有返回值的方法里消除break：将break转换为return立即返回有些朋友喜欢这样做：在有返回值的方法里break之后，再返回某个值。其实完全可以在break的那一行直接返回。 12345678910func hasBadProductIn(products: Array&lt;String&gt;) -&gt; Bool &#123; var result = false for level in products &#123; if level.hasPrefix("bad") &#123; result = true &#125; &#125; return result&#125; 遇到错误条件直接返回： 12345678func hasBadProductIn(products: Array&lt;String&gt;) -&gt; Bool &#123; for level in products &#123; if level.hasPrefix("bad") &#123; return true &#125; &#125; return false&#125; 这样写的话不用特意声明一个变量来特意保存需要返回的值，看起来非常简洁，可读性高。 Switch语句 1. 每个分支都必须用大括号括起来推荐这样写： 123456789101112131415161718switch (integer) &#123; case 1: &#123; // ... &#125; break; case 2: &#123; // ... break; &#125; case 3: &#123; // ... break; &#125; default:&#123; // ... break; &#125;&#125; 2. 使用枚举类型时，不能有default分支， 除了使用枚举类型以外，都必须有default分支123456789101112131415RWTLeftMenuTopItemType menuType = RWTLeftMenuTopItemMain; switch (menuType) &#123; case RWTLeftMenuTopItemMain: &#123; // ... break; &#125; case RWTLeftMenuTopItemShows: &#123; // ... break; &#125; case RWTLeftMenuTopItemSchedule: &#123; // ... break; &#125;&#125; 在Switch语句使用枚举类型的时候，如果使用了default分支，在将来就无法通过编译器来检查新增的枚举类型了。 函数 1. 一个函数的长度必须限制在50行以内通常来说，在阅读一个函数的时候，如果视需要跨过很长的垂直距离会非常影响代码的阅读体验。如果需要来回滚动眼球或代码才能看全一个方法，就会很影响思维的连贯性，对阅读代码的速度造成比较大的影响。最好的情况是在不滚动眼球或代码的情况下一眼就能将该方法的全部代码映入眼帘。 2. 一个函数只做一件事（单一原则）每个函数的职责都应该划分的很明确（就像类一样）。 推荐这样写： 12dataConfiguration()viewConfiguration() 不推荐这样写： 12345void dataConfiguration()&#123; ... viewConfiguration()&#125; 3. 对于有返回值的函数（方法），每一个分支都必须有返回值推荐这样写： 12345678910int function()&#123; if(condition1)&#123; return count1 &#125;else if(condition2)&#123; return count2 &#125;else&#123; return defaultCount &#125; &#125; 不推荐这样写： 12345678int function()&#123; if(condition1)&#123; return count1 &#125;else if(condition2)&#123; return count2 &#125;&#125; 4. 对输入参数的正确性和有效性进行检查，参数错误立即返回推荐这样写： 123456789101112void function(param1,param2)&#123; if(param1 is unavailable)&#123; return; &#125; if(param2 is unavailable)&#123; return; &#125; //Do some right thing&#125; 5. 如果在不同的函数内部有相同的功能，应该把相同的功能抽取出来单独作为另一个函数原来的调用： 123456789void logic() &#123; a(); b()； if (logic1 condition) &#123; c(); &#125; else &#123; d(); &#125;&#125; 将a，b函数抽取出来作为单独的函数 1234567891011121314void basicConfig() &#123; a(); b();&#125; void logic1() &#123; basicConfig(); c();&#125;void logic2() &#123; basicConfig(); d();&#125; 6. 将函数内部比较复杂的逻辑提取出来作为单独的函数一个函数内的不清晰（逻辑判断比较多，行数较多）的那片代码，往往可以被提取出去，构成一个新的函数，然后在原来的地方调用它这样你就可以使用有意义的函数名来代替注释，增加程序的可读性。 举一个发送邮件的例子： 123456789openEmailSite();login();writeTitle(title);writeContent(content);writeReceiver(receiver);addAttachment(attachment);send(); 中间的部分稍微长一些，我们可以将它们提取出来： 1234567void writeEmail(title, content,receiver,attachment)&#123; writeTitle(title); writeContent(content); writeReceiver(receiver); addAttachment(attachment); &#125; 然后再看一下原来的代码： 1234openEmailSite();login();writeEmail(title, content,receiver,attachment)send(); 8. 避免使用全局变量，类成员（class member）来传递信息，尽量使用局部变量和参数。在一个类里面，经常会有传递某些变量的情况。而如果需要传递的变量是某个全局变量或者属性的时候，有些朋友不喜欢将它们作为参数，而是在方法内部就直接访问了： 12345678910111213class A &#123; var x; func updateX() &#123; ... x = ...; &#125; func printX() &#123; updateX(); print(x); &#125;&#125; 我们可以看到，在printX方法里面，updateX和print方法之间并没有值的传递，乍一看我们可能不知道x从哪里来的，导致程序的可读性降低了。 而如果你使用局部变量而不是类成员来传递信息，那么这两个函数就不需要依赖于某一个类，而且更加容易理解，不易出错： 123456789func updateX() -&gt; String&#123; x = ...; return x; &#125; func printX() &#123; String x = updateX(); print(x); &#125; 注释 优秀的代码大部分是可以自描述的，我们完全可以用程代码本身来表达它到底在干什么，而不需要注释的辅助。 但并不是说一定不能写注释，有以下三种情况比较适合写注释： 公共接口（注释要告诉阅读代码的人，当前类能实现什么功能）。 涉及到比较深层专业知识的代码（注释要体现出实现原理和思想）。 容易产生歧义的代码（但是严格来说，容易让人产生歧义的代码是不允许存在的）。 除了上述这三种情况，如果别人只能依靠注释才能读懂你的代码的时候，就要反思代码出现了什么问题。 最后，对于注释的内容，相对于“做了什么”，更应该说明“为什么这么做”。 Code Review 换行、注释、方法长度、代码重复等这些是通过机器检查出来的问题，是无需通过人来做的。 而且除了审查需求的实现的程度，bug是否无处藏身以外，更应该关注代码的设计。比如类与类之间的耦合程度，设计的可扩展性，复用性，是否可以将某些方法抽出来作为接口等等。 三. iOS规范变量 1. 变量名必须使用驼峰格式类，协议使用大驼峰： 12HomePageViewController.h&lt;HeaderViewDelegate&gt; 对象等局部变量使用小驼峰： 12NSString *personName = @"";NSUInteger totalCount = 0; 2. 变量的名称必须同时包含功能与类型123UIButton *addBtn //添加按钮UILabel *nameLbl //名字标签NSString *addressStr//地址字符串 3. 系统常用类作实例变量声明时加入后缀 类型 后缀 UIViewController VC UIView View UILabel Lbl UIButton Btn UIImage Img UIImageView ImagView NSArray Array NSMutableArray Marray NSDictionary Dict NSMutableDictionary Mdict NSString Str NSMutableString MStr NSSet Set NSMutableSet Mset 常量 1. 常量以相关类名作为前缀推荐这样写： 1static const NSTimeInterval ZOCSignInViewControllerFadeOutAnimationDuration = 0.4; 不推荐这样写： 1static const NSTimeInterval fadeOutTime = 0.4; 2. 建议使用类型常量，不建议使用#define预处理命令首先比较一下这两种声明常量的区别： 预处理命令：简单的文本替换，不包括类型信息，并且可被任意修改。 类型常量：包括类型信息，并且可以设置其使用范围，而且不可被修改。 使用预处理虽然能达到替换文本的目的，但是本身还是有局限性的： 不具备类型信息。 可以被任意修改。 3. 对外公开某个常量：如果我们需要发送通知，那么就需要在不同的地方拿到通知的“频道”字符串（通知的名称），那么显然这个字符串是不能被轻易更改，而且可以在不同的地方获取。这个时候就需要定义一个外界可见的字符串常量。 推荐这样写： 123456//头文件extern NSString *const ZOCCacheControllerDidClearCacheNotification;//实现文件static NSString * const ZOCCacheControllerDidClearCacheNotification = @"ZOCCacheControllerDidClearCacheNotification";static const CGFloat ZOCImageThumbnailHeight = 50.0f; 不推荐这样写： 12#define CompanyName @"Apple Inc." #define magicNumber 42 宏 1. 宏、常量名都要使用大写字母，用下划线‘_’分割单词。123#define URL_GAIN_QUOTE_LIST @"/v1/quote/list"#define URL_UPDATE_QUOTE_LIST @"/v1/quote/update"#define URL_LOGIN @"/v1/user/login” 2. 宏定义中如果包含表达式或变量，表达式和变量必须用小括号括起来。1#define MY_MIN(A, B) ((A)&gt;(B)?(B):(A)) CGRect函数 其实iOS内部已经提供了相应的获取CGRect各个部分的函数了，它们的可读性比较高，而且简短，推荐使用： 推荐这样写： 123456CGRect frame = self.view.frame; CGFloat x = CGRectGetMinX(frame); CGFloat y = CGRectGetMinY(frame); CGFloat width = CGRectGetWidth(frame); CGFloat height = CGRectGetHeight(frame); CGRect frame = CGRectMake(0.0, 0.0, width, height); 而不是 123456CGRect frame = self.view.frame; CGFloat x = frame.origin.x; CGFloat y = frame.origin.y; CGFloat width = frame.size.width; CGFloat height = frame.size.height; CGRect frame = (CGRect)&#123; .origin = CGPointZero, .size = frame.size &#125;; 范型 建议在定义NSArray和NSDictionary时使用泛型，可以保证程序的安全性： 12NSArray&lt;NSString *&gt; *testArr = [NSArray arrayWithObjects:@"Hello", @"world", nil];NSDictionary&lt;NSString *, NSNumber *&gt; *dic = @&#123;@"key":@(1), @"age":@(10)&#125;; Block 为常用的Block类型创建typedef 如果我们需要重复创建某种block（相同参数，返回值）的变量，我们就可以通过typedef来给某一种块定义属于它自己的新类型 例如： 1234int (^variableName)(BOOL flag, int value) =^(BOOL flag, int value)&#123; // Implementation return someInt;&#125; 这个Block有一个bool参数和一个int参数，并返回int类型。我们可以给它定义类型： 1int(^EOCSomeBlock)(BOOL flag, int value); 再次定义的时候，就可以通过简单的赋值来实现： 123EOCSomeBlock block = ^(BOOL flag, int value)&#123;// Implementation&#125;; 定义作为参数的Block： 1- (void)startWithCompletionHandler: (void(^)(NSData *data, NSError* error))completion; 这里的Block有一个NSData参数，一个NSError参数并没有返回值 12typedef void(^EOCCompletionHandler)(NSData *data, NSError* error);(void)startWithCompletionHandler:(EOCCompletionHandler)completion;” 通过typedef定义Block签名的好处是:如果要某种块增加参数，那么只修改定义签名的那行代码即可。 字面量语法 尽量使用字面量值来创建 NSString , NSDictionary , NSArray , NSNumber 这些不可变对象： 123NSArray *names = @[@"Brian", @"Matt", @"Chris", @"Alex", @"Steve", @"Paul"];NSDictionary *productManagers = @&#123;@"iPhone" : @"Kate", @"iPad" : @"Kamal", @"Mobile Web" : @"Bill"&#125;;NSNumber *shouldUseLiterals = @YES;NSNumber *buildingZIPCode = @10018; 不推荐这样写： 123NSArray *names = [NSArray arrayWithObjects:@"Brian", @"Matt", @"Chris", @"Alex", @"Steve", @"Paul", nil];NSDictionary *productManagers = [NSDictionary dictionaryWithObjectsAndKeys: @"Kate", @"iPhone", @"Kamal", @"iPad", @"Bill" ];NSNumber *shouldUseLiterals = [NSNumber numberWithBool:YES];NSNumber *buildingZIPCode = [NSNumber numberWithInteger:10018]; 属性 1. 属性的命名使用小驼峰推荐这样写： 1@property (nonatomic, readwrite, strong) UIButton *confirmButton; 2. 属性的关键字推荐按照 原子性，读写，内存管理的顺序排列推荐这样写： 123@property (nonatomic, readwrite, copy) NSString *name;@property (nonatomic, readonly, copy) NSString *gender;@property (nonatomic, readwrite, strong) UIView *headerView; 3. Block属性应该使用copy关键字推荐这样写： 12typedef void (^ErrorCodeBlock) (id errorCode,NSString *message);@property (nonatomic, readwrite, copy) ErrorCodeBlock errorBlock;//将block拷贝到堆中 4. 形容词性的BOOL属性的getter应该加上is前缀推荐这样写： 1@property (assign, getter=isEditable) BOOL editable; 5. 使用getter方法做懒加载实例化一个对象是需要耗费资源的，如果这个对象里的某个属性的实例化要调用很多配置和计算，就需要懒加载它，在使用它的前一刻对它进行实例化： 123456789- (NSDateFormatter *)dateFormatter &#123; if (!_dateFormatter) &#123; _dateFormatter = [[NSDateFormatter alloc] init]; NSLocale *enUSPOSIXLocale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"]; [_dateFormatter setLocale:enUSPOSIXLocale]; [_dateFormatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ss.SSS"]; &#125; return _dateFormatter;&#125; 但是也有对这种做法的争议：getter方法可能会产生某些副作用，例如如果它修改了全局变量，可能会产生难以排查的错误。 6. 除了init和dealloc方法，建议都使用点语法访问属性使用点语法的好处： setter： setter会遵守内存管理语义(strong, copy, weak)。 通过在内部设置断点，有助于调试bug。 可以过滤一些外部传入的值。 捕捉KVO通知。 getter： 允许子类化。 通过在内部设置断点，有助于调试bug。 实现懒加载（lazy initialization）。 注意： 懒加载的属性，必须通过点语法来读取数据。因为懒加载是通过重写getter方法来初始化实例变量的，如果不通过属性来读取该实例变量，那么这个实例变量就永远不会被初始化。 在init和dealloc方法里面使用点语法的后果是：因为没有绕过setter和getter，在setter和getter里面可能会有很多其他的操作。而且如果它的子类重载了它的setter和getter方法，那么就可能导致该子类调用其他的方法。 7. 不要滥用点语法，要区分好方法调用和属性访问推荐这样写： 12view.backgroundColor = [UIColor orangeColor]; [UIApplication sharedApplication].delegate; 不推荐这样写： 12[view setBackgroundColor:[UIColor orangeColor]]; UIApplication.sharedApplication.delegate; 8. 尽量使用不可变对象建议尽量把对外公布出来的属性设置为只读，在实现文件内部设为读写。具体做法是： 在头文件中，设置对象属性为 在实现文件中设置为readwrite。 这样一来，在外部就只能读取该数据，而不能修改它，使得这个类的实例所持有的数据更加安全。而且，对于集合类的对象，更应该仔细考虑是否可以将其设为可变的。 如果在公开部分只能设置其为只读属性，那么就在非公开部分存储一个可变型。所以当在外部获取这个属性时，获取的只是内部可变型的一个不可变版本,例如： 在公共API中： 12345678910@interface EOCPerson : NSObject@property (nonatomic, copy, readonly) NSString firstName;@property (nonatomic, copy, readonly) NSString lastName;@property (nonatomic, strong, readonly) NSSet *friends //向外公开的不可变集合(id)initWithFirstName:(NSString)firstName andLastName:(NSString)lastName;(void)addFriend:(EOCPerson*)person;(void)removeFriend:(EOCPerson*)person;@end 在这里，我们将friends属性设置为不可变的set。然后，提供了来增加和删除这个set里的元素的公共接口。 在实现文件里： 12345678910111213141516171819202122232425262728293031@interface EOCPerson ()@property (nonatomic, copy, readwrite) NSString *firstName;@property (nonatomic, copy, readwrite) NSString* lastName;@end@implementation EOCPerson &#123; NSMutableSet *_internalFriends; //实现文件里的可变集合&#125;- (NSSet*)friends &#123; return [_internalFriends copy]; //get方法返回的永远是可变set的不可变型&#125;- (void)addFriend:(EOCPerson*)person &#123; [_internalFriends addObject:person]; //在外部增加集合元素的操作 //do something when add element&#125;- (void)removeFriend:(EOCPerson*)person &#123; [_internalFriends removeObject:person]; //在外部移除元素的操作 //do something when remove element&#125;- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName &#123; if ((self = [super init])) &#123; ... &#125; return self;&#125; 我们可以看到，在实现文件里，保存一个可变set来记录外部的增删操作。 这里最重要的代码是： 123- (NSSet *)friends &#123; return [_internalFriends copy];&#125; 这个是friends属性的获取方法：它将当前保存的可变set复制了一不可变的set并返回。因此，外部读取到的set都将是不可变的版本。 方法 1. 方法名中不应使用and，而且签名要与对应的参数名保持高度一致推荐这样写： 1- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height; 不推荐这样写： 12- (instancetype)initWithWidth:(CGFloat)width andHeight:(CGFloat)height;- (instancetype)initWith:(int)width and:(int)height; 2. 方法实现时，如果参数过长，则令每个参数占用一行，以冒号对齐。123456- (void)doSomethingWith:(NSString *)theFoo rect:(CGRect)theRect interval:(CGFloat)theInterval&#123; //Implementation&#125; 3. 私有方法应该在实现文件中申明。12345678910@interface ViewController ()- (void)basicConfiguration;@end@implementation ViewController- (void)basicConfiguration&#123; //Do some basic configuration&#125;@end 4. 方法名用小写字母开头的单词组合而成1- (NSString *)descriptionWithLocale:(id)locale; 5. 方法名前缀 刷新视图的方法名要以refresh为首。 更新数据的方法名要以update为首。 推荐这样写： 12- (void)updateDataSourceWithViewModel:(ViewModel*)viewModel;- (void)updateDataSourceWithViewModel:(ViewModel*)viewModel; 面向协议编程 如果某些功能（方法）具备可复用性，我们就需要将它们抽取出来放入一个抽象接口文件中（在iOS中，抽象接口即协议），让不同类型的对象遵循这个协议，从而拥有相同的功能。 因为协议是不依赖于某个对象的，所以通过协议，我们可以解开两个对象之间的耦合。如何理解呢？我们来看一下下面这个例子： 现在有一个需求：在一个UITableViewController里面拉取feed并展示出来。 方案一：定义一个拉取feed的类ZOCFeedParser，这个类有一些代理方法实现feed相关功能： 12345678910111213141516@protocol ZOCFeedParserDelegate &lt;NSObject&gt;@optional- (void)feedParserDidStart:(ZOCFeedParser *)parser;- (void)feedParser:(ZOCFeedParser *)parser didParseFeedInfo:(ZOCFeedInfoDTO *)info; - (void)feedParser:(ZOCFeedParser *)parser didParseFeedItem:(ZOCFeedItemDTO *)item; - (void)feedParserDidFinish:(ZOCFeedParser *)parser;- (void)feedParser:(ZOCFeedParser *)parser didFailWithError:(NSError *)error;@end @interface ZOCFeedParser : NSObject@property (nonatomic, weak) id &lt;ZOCFeedParserDelegate&gt; delegate; @property (nonatomic, strong) NSURL *url; - (id)initWithURL:(NSURL *)url; - (BOOL)start; - (void)stop; @end 然后在ZOCTableViewController里面传入ZOCFeedParser，并遵循其代理方法，实现feed的拉取功能。 123@interface ZOCTableViewController : UITableViewController&lt;ZOCFeedParserDelegate&gt;- (instancetype)initWithFeedParser:(ZOCFeedParser *)feedParser; @end 具体应用： 1234NSURL *feedURL = [NSURL URLWithString:@"http://bbc.co.uk/feed.rss"]; ZOCFeedParser *feedParser = [[ZOCFeedParser alloc] initWithURL:feedURL]; ZOCTableViewController *tableViewController = [[ZOCTableViewController alloc] initWithFeedParser:feedParser]; feedParser.delegate = tableViewController; OK，现在我们实现了需求：在ZOCTableViewController里面存放了一个ZOCFeedParser对象来处理feed的拉取功能。 但这里有一个严重的耦合问题：ZOCTableViewController只能通过ZOCFeedParser对象来处理feed的拉取功能。于是我们重新审视一下这个需求：其实我们实际上只需要ZOCTableViewController拉取feed就可以了，而具体是由哪个对象来拉取，ZOCTableViewController并不需要关心。 也就是说，我们需要提供给ZOCTableViewController的是一个更范型的对象，这个对象具备了拉取feed的功能就好了，而不应该仅仅局限于某个具体的对象（ZOCFeedParser）。所以，刚才的设计需要重新做一次修改： 方案二：首先需要在一个接口文件ZOCFeedParserProtocol.h里面定义抽象的，具有拉取feed功能的协议： 12345678910111213141516@protocol ZOCFeedParserDelegate &lt;NSObject&gt;@optional- (void)feedParserDidStart:(id&lt;ZOCFeedParserProtocol&gt;)parser;- (void)feedParser:(id&lt;ZOCFeedParserProtocol&gt;)parser didParseFeedInfo:(ZOCFeedInfoDTO *)info; - (void)feedParser:(id&lt;ZOCFeedParserProtocol&gt;)parser didParseFeedItem:(ZOCFeedItemDTO *)item; - (void)feedParserDidFinish:(id&lt;ZOCFeedParserProtocol&gt;)parser;- (void)feedParser:(id&lt;ZOCFeedParserProtocol&gt;)parser didFailWithError:(NSError *)error;@end @protocol ZOCFeedParserProtocol &lt;NSObject&gt;@property (nonatomic, weak) id &lt;ZOCFeedParserDelegate&gt; delegate; @property (nonatomic, strong) NSURL *url;- (BOOL)start;- (void)stop;@end 而原来的ZOCFeedParser仅仅是需要遵循上面这个协议就具备了拉取feed的功能： 123@interface ZOCFeedParser : NSObject &lt;ZOCFeedParserProtocol&gt; - (id)initWithURL:(NSURL *)url;//仅仅需要通过传入url即可，其他事情都交给ZOCFeedParserProtocol@end 而且，ZOCTableViewController也不直接依赖于ZOCFeedParser对象，我们只需要传给它一个遵循&lt;ZOCFeedParserProtocol&gt;的对象即可。 123@interface ZOCTableViewController : UITableViewController &lt;ZOCFeedParserDelegate&gt;- (instancetype)initWithFeedParser:(id&lt;ZOCFeedParserProtocol&gt;)feedParser;@end 这样一来，ZOCTableViewController和ZOCFeedParser之间就没有直接的关系了。以后，如果我们想： 给这个feed拉取器增加新的功能：仅需要修改ZOCFeedParserProtocol.h文件。 更换一个feed拉取器实例：创建一个新类型来遵循ZOCFeedParserProtocol.h即可。 iOS 中委托的设计 1. 要区分好代理和数据源的区别在iOS开发中的委托模式包含了delegate（代理）和datasource（数据源）。虽然二者同属于委托模式，但是这两者是有区别的。这个区别就是二者的信息流方向是不同的： delegate ：事件发生的时候，委托者需要通知代理。（信息流从委托者到代理） datasource：委托者需要从数据源拉取数据。（信息流从数据源到委托者） 然而包括苹果也没有做好榜样，将它们彻底的区分开。就拿UITableView来说，在它的delegate方法中有一个方法： 1- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath; 这个方法正确地体现了代理的作用：委托者（tableview）告诉代理（控制器）“我的某个cell被点击了”。但是，UITableViewDelegate的方法列表里还有这个方法： 1- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath; 该方法的作用是 由控制器来告诉tabievlew的行高，也就是说，它的信息流是从控制器（数据源）到委托者（tableview）的。准确来讲，它应该是一个数据源方法，而不是代理方法。 在UITableViewDataSource中，就有标准的数据源方法： 1- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView; 这个方法的作用就是让tableview向控制器拉取一个section数量的数据。 所以，在我们设计一个视图控件的代理和数据源时，一定要区分好二者的区别，合理地划分哪些方法属于代理方法，哪些方法属于数据源方法。 2. 代理方法的第一个参数必须为委托者代理方法必须以委托者作为第一个参数（参考UITableViewDelegate）的方法。其目的是为了区分不同委托着的实例。因为同一个控制器是可以作为多个tableview的代理的。若要区分到底是哪个tableview的cell被点击了，就需要在 1- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath* )indexPath 方法中做个区分。 向代理发送消息时需要判断其是否实现该方法最后，在委托着向代理发送消息的时候，需要判断委托着是否实现了这个代理方法: 123if ([self.delegate respondsToSelector:@selector(signUpViewControllerDidPressSignUpButton:)]) &#123; [self.delegate signUpViewControllerDidPressSignUpButton:self];&#125; 3. 遵循代理过多的时候，换行对齐显示1234@interface ShopViewController () &lt;UIGestureRecognizerDelegate, HXSClickEventDelegate, UITableViewDelegate, UITableViewDataSource&gt; 4. 代理的方法需要明确必须执行和可不执行代理方法在默认情况下都是必须执行的，然而在设计一组代理方法的时候，有些方法可以不是必须执行（是因为存在默认配置），这些方法就需要使用@optional关键字来修饰： 12@protocol ZOCServiceDelegate &lt;NSObject&gt;@optional- (void)generalService:(ZOCGeneralService *)service didRetrieveEntries:(NSArray *)entries; @end 类 1. 类的名称应该以三个大写字母为前缀；创建子类的时候，应该把代表子类特点的部分放在前缀和父类名的中间推荐这样写： 123456//父类ZOCSalesListViewController//子类ZOCDaySalesListViewControllerZOCMonthSalesListViewController 2. initializer &amp;&amp; dealloc推荐： 将 dealloc 方法放在实现文件的最前面 将init方法放在dealloc方法后面。如果有多个初始化方法，应该将指定初始化方法放在最前面，其他初始化方法放在其后。 2.1 dealloc方法里面应该直接访问实例变量，不应该用点语法访问2.2 init方法的写法： init方法返回类型必须是instancetype，不能是id。 必须先实现[super init]。 1234567- (instancetype)init &#123; self = [super init]; // call the designated initializer if (self) &#123; // Custom initialization &#125; return self; &#125; 2.3 指定初始化方法指定初始化方法(designated initializer)是提供所有的（最多的）参数的初始化方法，间接初始化方法(secondary initializer)有一个或部分参数的初始化方法。 注意事项1：间接初始化方法必须调用指定初始化方法。 123456789101112131415161718192021222324252627@implementation ZOCEvent //指定初始化方法- (instancetype)initWithTitle:(NSString *)title date:(NSDate *)date location:(CLLocation *)location&#123; self = [super init]; if (self) &#123; _title = title; _date = date; _location = location; &#125; return self; &#125; //间接初始化方法- (instancetype)initWithTitle:(NSString *)title date:(NSDate *)date&#123; return [self initWithTitle:title date:date location:nil];&#125;//间接初始化方法- (instancetype)initWithTitle:(NSString *)title &#123; return [self initWithTitle:title date:[NSDate date] location:nil];&#125;@end 注意事项2：如果直接父类有指定初始化方法，则必须调用其指定初始化方法 123456- (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil &#123; self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil]; if (self) &#123; &#125; return self; &#125; 注意事项3：如果想在当前类自定义一个新的全能初始化方法，则需要如下几个步骤 定义新的指定初始化方法，并确保调用了直接父类的初始化方法。 重载直接父类的初始化方法，在内部调用新定义的指定初始化方法。 为新的指定初始化方法写文档。 看一个标准的例子： 12345678910111213141516@implementation ZOCNewsViewController//新的指定初始化方法- (id)initWithNews:(ZOCNews *)news &#123; self = [super initWithNibName:nil bundle:nil]; if (self) &#123; _news = news; &#125; return self;&#125; // 重载父类的初始化方法- (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil&#123; return [self initWithNews:nil]; &#125;@end 在这里，重载父类的初始化方法并在内部调用新定义的指定初始化方法的原因是你不能确定调用者调用的就一定是你定义的这个新的指定初始化方法，而不是原来从父类继承来的指定初始化方法。 假设你没有重载父类的指定初始化方法，而调用者却恰恰调用了父类的初始化方法。那么调用者可能永远都调用不到你自己定义的新指定初始化方法了。 而如果你成功定义了一个新的指定初始化方法并能保证调用者一定能调用它，你最好要在文档中明确写出哪一个才是你定义的新初始化方法。或者你也可以使用编译器指令__attribute__((objc_designated_initializer))来标记它。 3. 所有返回类对象和实例对象的方法都应该使用instancetype将instancetype关键字作为返回值的时候，可以让编译器进行类型检查，同时适用于子类的检查，这样就保证了返回类型的正确性（一定为当前的类对象或实例对象） 推荐这样写： 123@interface ZOCPerson+ (instancetype)personWithName:(NSString *)name; @end 不推荐这样写： 123@interface ZOCPerson+ (id)personWithName:(NSString *)name; @end 4. 在类的头文件中尽量少引用其他头文件有时，类A需要将类B的实例变量作为它公共API的属性。这个时候，我们不应该引入类B的头文件，而应该使用向前声明（forward declaring）使用class关键字，并且在A的实现文件引用B的头文件。 123456789101112131415// EOCPerson.h#import &lt;Foundation/Foundation.h&gt;@class EOCEmployer;@interface EOCPerson : NSObject@property (nonatomic, copy) NSString *firstName;@property (nonatomic, copy) NSString *lastName;@property (nonatomic, strong) EOCEmployer *employer;//将EOCEmployer作为属性@end// EOCPerson.m#import "EOCEmployer.h" 这样做有什么优点呢： 不在A的头文件中引入B的头文件，就不会一并引入B的全部内容，这样就减少了编译时间。 可以避免循环引用：因为如果两个类在自己的头文件中都引入了对方的头文件，那么就会导致其中一个类无法被正确编译。 但是个别的时候，必须在头文件中引入其他类的头文件: 主要有两种情况： 该类继承于某个类，则应该引入父类的头文件。 该类遵从某个协议，则应该引入该协议的头文件。而且最好将协议单独放在一个头文件中。 5. 类的布局1234567891011121314151617181920212223242526272829#pragma mark - Life Cycle Methods- (instancetype)init- (void)dealloc- (void)viewWillAppear:(BOOL)animated- (void)viewDidAppear:(BOOL)animated- (void)viewWillDisappear:(BOOL)animated- (void)viewDidDisappear:(BOOL)animated#pragma mark - Override Methods#pragma mark - Intial Methods#pragma mark - Network Methods#pragma mark - Target Methods#pragma mark - Public Methods#pragma mark - Private Methods#pragma mark - UITableViewDataSource #pragma mark - UITableViewDelegate #pragma mark - Lazy Loads#pragma mark - NSCopying #pragma mark - NSObject Methods 分类 1. 分类添加的方法需要添加前缀和下划线推荐这样写： 123@interface NSDate (ZOCTimeExtensions) - (NSString *)zoc_timeAgoShort;@end 不推荐这样写： 123@interface NSDate (ZOCTimeExtensions) - (NSString *)timeAgoShort;@end 2. 把类的实现代码分散到便于管理的多个分类中一个类可能会有很多公共方法，而且这些方法往往可以用某种特有的逻辑来分组。我们可以利用Objecctive-C的分类机制，将类的这些方法按一定的逻辑划入几个分区中。 举个🌰： 先看一个没有使用无分类的类： 123456789101112131415161718192021222324#import &lt;Foundation/Foundation.h&gt;@interface EOCPerson : NSObject@property (nonatomic, copy, readonly) NSString *firstName;@property (nonatomic, copy, readonly) NSString *lastName;@property (nonatomic, strong, readonly) NSArray *friends;- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName;/* Friendship methods */- (void)addFriend:(EOCPerson*)person;- (void)removeFriend:(EOCPerson*)person;- (BOOL)isFriendsWith:(EOCPerson*)person;/* Work methods */- (void)performDaysWork;- (void)takeVacationFromWork;/* Play methods */- (void)goToTheCinema;- (void)goToSportsGame;@end 分类之后： 1234567891011121314151617181920212223242526272829303132333435#import &lt;Foundation/Foundation.h&gt;@interface EOCPerson : NSObject@property (nonatomic, copy, readonly) NSString *firstName;@property (nonatomic, copy, readonly) NSString *lastName;@property (nonatomic, strong, readonly) NSArray *friends;- (id)initWithFirstName:(NSString*)firstNameandLastName:(NSString*)lastName;@end@interface EOCPerson (Friendship)- (void)addFriend:(EOCPerson*)person;- (void)removeFriend:(EOCPerson*)person;- (BOOL)isFriendsWith:(EOCPerson*)person;@end@interface EOCPerson (Work)- (void)performDaysWork;- (void)takeVacationFromWork;@end@interface EOCPerson (Play)- (void)goToTheCinema;- (void)goToSportsGame;@end 其中，FriendShip分类的实现代码可以这么写： 1234567891011121314151617181920212223242526272829// EOCPerson+Friendship.h#import "EOCPerson.h"@interface EOCPerson (Friendship)- (void)addFriend:(EOCPerson*)person;- (void)removeFriend:(EOCPerson*)person;- (BOOL)isFriendsWith:(EOCPerson*)person;@end// EOCPerson+Friendship.m#import "EOCPerson+Friendship.h"@implementation EOCPerson (Friendship)- (void)addFriend:(EOCPerson*)person &#123; /* ... */&#125;- (void)removeFriend:(EOCPerson*)person &#123; /* ... */&#125;- (BOOL)isFriendsWith:(EOCPerson*)person &#123; /* ... */&#125;@end 注意：在新建分类文件时，一定要引入被分类的类文件。 通过分类机制，可以把类代码分成很多个易于管理的功能区，同时也便于调试。因为分类的方法名称会包含分类的名称，可以马上看到该方法属于哪个分类中。 利用这一点，我们可以创建名为Private的分类，将所有私有方法都放在该类里。这样一来，我们就可以根据private一词的出现位置来判断调用的合理性，这也是一种编写“自我描述式代码（self-documenting）”的办法。 单例 1. 单例不能作为容器对象来使用单例对象不应该暴露出任何属性，也就是说它不能作为让外部存放对象的容器。它应该是一个处理某些特定任务的工具，比如在iOS中的GPS和加速度传感器。我们只能从他们那里得到一些特定的数据。 2. 使用dispatch_once来生成单例推荐这样写： 12345678+ (instancetype)sharedInstance &#123; static id sharedInstance = nil; static dispatch_once_t onceToken = 0; dispatch_once(&amp;onceToken, ^&#123; sharedInstance = [[self alloc] init]; &#125;); return sharedInstance; &#125; 不推荐这样写： 1234567+ (instancetype)sharedInstance &#123; static id sharedInstance; @synchronized(self) &#123; if (sharedInstance == nil) &#123; sharedInstance = [[MyClass alloc] init]; &#125; &#125; return sharedInstance; &#125; 相等性的判断 判断两个person类是否相等的合理做法： 1234567891011121314- (BOOL)isEqual:(id)object &#123; if (self == object) &#123; return YES; //判断内存地址 &#125; if (![object isKindOfClass:[ZOCPerson class]]) &#123; return NO; //是否为当前类或派生类 &#125; return [self isEqualToPerson:(ZOCPerson *)object]; &#125;//自定义的判断相等性的方法- (BOOL)isEqualToPerson:(Person *)person &#123; if (!person) &#123; return NO; &#125; BOOL namesMatch = (!self.name &amp;&amp; !person.name) || [self.name isEqualToString:person.name]; BOOL birthdaysMatch = (!self.birthday &amp;&amp; !person.birthday) || [self.birthday isEqualToDate:person.birthday]; return haveEqualNames &amp;&amp; haveEqualBirthdays; &#125; 方法文档 一个函数(方法)必须有一个字符串文档来解释，除非它： 非公开，私有函数。 很短。 显而易见。 而其余的，包括公开接口，重要的方法，分类，以及协议，都应该伴随文档（注释）： 以/开始 第二行识总结性的语句 第三行永远是空行 在与第二行开头对齐的位置写剩下的注释。 建议这样写： 12345/This comment serves to demonstrate the format of a doc string.Note that the summary line is always at most one line long, and after the opening block comment,and each line of text is preceded by a single space.*/ 看一个指定初始化方法的注释： 1234567/ * Designated initializer. * * @param store The store for CRUD operations. * @param searchService The search service used to query the store. * @return A ZOCCRUDOperationsStore object. */ - (instancetype)initWithOperationsStore:(id&lt;ZOCGenericStoreProtocol&gt;)store searchService:(id&lt;ZOCGenericSearchServiceProtocol&gt;)searchService; 多用队列，少用同步锁来避免资源抢夺 多个线程执行同一份代码时，很可能会造成数据不同步。建议使用GCD来为代码加锁的方式解决这个问题。 方案一：使用串行同步队列来将读写操作都安排到同一个队列里：1234567891011121314151617181920_syncQueue = dispatch_queue_create("com.effectiveobjectivec.syncQueue", NULL);//读取字符串- (NSString*)someString &#123; __block NSString *localSomeString; dispatch_sync(_syncQueue, ^&#123; localSomeString = _someString; &#125;); return localSomeString;&#125;//设置字符串- (void)setSomeString:(NSString*)someString &#123; dispatch_sync(_syncQueue, ^&#123; _someString = someString; &#125;);&#125; 这样一来，读写操作都在串行队列进行，就不容易出错。 但是，还有一种方法可以让性能更高： 方案二：将写操作放入栅栏快中，让他们单独执行；将读取操作并发执行。12345678910111213141516171819_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);//读取字符串- (NSString*)someString &#123; __block NSString *localSomeString; dispatch_sync(_syncQueue, ^&#123; localSomeString = _someString; &#125;); return localSomeString;&#125;//设置字符串- (void)setSomeString:(NSString*)someString &#123; dispatch_barrier_async(_syncQueue, ^&#123; _someString = someString; &#125;);&#125; 显然，数据的正确性主要取决于写入操作，那么只要保证写入时，线程是安全的，那么即便读取操作是并发的，也可以保证数据是同步的。这里的dispatch_barrier_async方法使得操作放在了同步队列里“有序进行”，保证了写入操作的任务是在串行队列里。 实现description方法打印自定义对象信息 在打印我们自己定义的类的实例对象时，在控制台输出的结果往往是这样的：object = &lt;EOCPerson: 0x7fd9a1600600&gt; 这里只包含了类名和内存地址，它的信息显然是不具体的,远达不到调试的要求。 但是！如果在我们自己定义的类覆写description方法，我们就可以在打印这个类的实例时输出我们想要的信息。 例如： 123- (NSString*)description &#123; return [NSString stringWithFormat:@"&lt;%@: %p, %@ %@&gt;", [self class], self, firstName, lastName];&#125; 在这里，显示了内存地址，还有该类的所有属性。 而且，如果我们将这些属性值放在字典里打印，则更具有可读性： 123456789- (NSString*)description &#123; return [NSString stringWithFormat:@"&lt;%@: %p, %@&gt;",[self class],self, @&#123; @"title":_title, @"latitude":@(_latitude), @"longitude":@(_longitude)&#125; ];&#125; 输出结果： 123456location = &lt;EOCLocation: 0x7f98f2e01d20, &#123; latitude = "51.506"; longitude = 0; title = London;&#125; 我们可以看到，通过重写description方法可以让我们更加了解对象的情况，便于后期的调试，节省开发时间。 NSArray&amp; NSMutableArray 1. addObject之前要非空判断。2. 取下标的时候要判断是否越界。3. 取第一个元素或最后一个元素的时候使用firtstObject和lastObjectNSCache 1. 构建缓存时选用NSCache 而非NSDictionary如果我们缓存使用得当，那么应用程序的响应速度就会提高。只有那种“重新计算起来很费事的数据，才值得放入缓存”，比如那些需要从网络获取或从磁盘读取的数据。 在构建缓存的时候很多人习惯用NSDictionary或者NSMutableDictionary，但是作者建议大家使用NSCache，它作为管理缓存的类，有很多特点要优于字典，因为它本来就是为了管理缓存而设计的。 2. NSCache优于NSDictionary的几点： 当系统资源将要耗尽时，NSCache具备自动删减缓冲的功能。并且还会先删减“最久未使用”的对象。 NSCache不拷贝键，而是保留键。因为并不是所有的键都遵从拷贝协议（字典的键是必须要支持拷贝协议的，有局限性）。 NSCache是线程安全的：不编写加锁代码的前提下，多个线程可以同时访问NSCache。 NSNotification 1. 通知的名称建议将通知的名字作为常量，保存在一个专门的类中： 12345// Const.hextern NSString * const ZOCFooDidBecomeBarNotification// Const.mNSString * const ZOCFooDidBecomeBarNotification = @"ZOCFooDidBecomeBarNotification"; 2. 通知的移除通知必须要在对象销毁之前移除掉。 其他 1. Xcode工程文件的物理路径要和逻辑路径保持一致。2. 忽略没有使用变量的编译警告对于某些暂时不用，以后可能用到的临时变量，为了避免警告，我们可以使用如下方法将这个警告消除： 12345- (NSInteger)giveMeFive &#123; NSString *foo; #pragma unused (foo) return 5; &#125; 3. 手动标明警告和错误手动明确一个错误：1234- (NSInteger)divide:(NSInteger)dividend by:(NSInteger)divisor &#123; #error Whoa, buddy, you need to check for zero here! return (dividend / divisor); &#125; 手动明确一个警告：12345678- (float)divide:(float)dividend by:(float)divisor &#123; #warning Dude, don't compare floating point numbers like this! if (divisor != 0.0) &#123; return (dividend / divisor); &#125; else &#123; return NAN; &#125; &#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS ImageView contentMode 图片填充模式]]></title>
    <url>%2F2019%2F07%2F12%2FiOS-ImageView-contentMode-%E5%9B%BE%E7%89%87%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[摘要： UIImageView的contentMode这个属性是用来设置图片的显示方式,如居中、居右,是否缩放等,系统给出的有枚举类型,以下示例图片比例大于imageViewUIViewContentModeScaleToFill,&lt;默认属性,图片根据imageView大小显示,会使图片变形&gt;根据视图的比例去拉伸图片内容UIViewContentModeScaleAspectFit,//contentsscaledtofitwithfixedaspect.remainde UIImageView的contentMode这个属性是用来设置图片的显示方式,如居中、居右,是否缩放等,系统给出的有枚举类型,以下示例图片比例大于imageView UIViewContentModeScaleToFill,&lt;默认属性,图片根据imageView大小显示,会使图片变形&gt; 根据视图的比例去拉伸图片内容 UIViewContentModeScaleAspectFit,/ /contents scaled to fit with fixed aspect. remainder is transparent (内容符合固定的方面。剩余部分是透明的) &lt;图片根据自身比例进行显示,图片小于imageView的部分会透明显示&gt; 保持图片内容的纵横比例,来适应视图的大小 UIViewContentModeScaleAspectFill,// contents scaled to fill with fixed aspect. some portion of content may be clipped.&lt;内容扩展填充固定方面。部分内容可能剪。&gt; &lt;图片按imageView大小比例居中显示,图片可能会失真并且不会显示完整,只显示中间部分&gt; 用图片内容来填充视图的大小,多余得部分可以被修剪掉来填充整个视图边界 UIViewContentModeRedraw,// redraw on bounds change (calls - setNeedsDisplay) &lt;重划边界变化(重设 - setNeedsDisplay)&gt; 这个选项是单视图的尺寸位置发生变化的时候通过调用setNeedsDisplay方法来重新显示 UIViewContentModeCenter,// contents remain same size. positioned adjusted.&lt;内容保持相同大小。定位调整&gt; 保持图片原比例在视图中间显示图片内容,如果视图大小小于图片的尺寸,则图片会超出视图边界,下面类同 UIViewContentModeTop, 保持图片原比例在视图中间顶部显示图片内容 UIViewContentModeBottom, 保持图片原比例在视图中间底部显示图片内容 UIViewContentModeLeft, 保持图片原比例在视图中间左边显示图片内容 UIViewContentModeRight, 保持图片原比例在视图中间右边显示图片内容 UIViewContentModeTopLeft, 保持图片原比例在视图左上角显示图片内容 UIViewContentModeTopRight, 保持图片原比例在视图右上角显示图片内容 UIViewContentModeBottomLeft, 保持图片原比例在视图左下角显示图片内容 UIViewContentModeBottomRight, 保持图片原比例在视图右下角显示图片内容]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS八种更新方式]]></title>
    <url>%2F2019%2F07%2F12%2FiOS%E5%85%AB%E7%A7%8D%E6%9B%B4%E6%96%B0%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、JSPatch热更新时，从服务器拉去js脚本。理论上可以修改和新建所有的模块，但是不建议这样做。建议 用来做紧急的小需求和 修复严重的线上bug。二、lua脚本比如： wax。热更新时，从服务器拉去lua脚本。游戏开发经常用到。三、Weex跨平台，一套代码，iOS、Android都可以运行。用前端语法实现原生效果。比React Native更好用。 weex基于vue.js，ReactNative使用React。 ReactNative安装配置麻烦。 weex安装cli之后就可以使用。 react模板JSX有一定的学习成本，vue和常用的web开发类似，模板是普通的html，数据绑定用mustache风格，样式直接使用css。 淘宝干的漂亮，中国在编码的实力越来越牛叉了。威武！！！ 四、React Native不像Weex能一套代码多端运行，需要自己分别做修改。 React Native 可以动态添加业务模块，但无法做到修改原生OC代码。 JSPatch、lua 配合React Native可以让一个原生APP时刻处于可扩展可修改的状态。 五、Hybrid像PhoneGap之类的框架, 基本概念和web差不多, 通过更新js/html来实现动态化，没有原生的效果流畅。 六、动态库可以做demo用，真实使用的时候会被苹果禁止。 因为 打包发到AppStore的ipa安装包 里的每个动态库 都有唯一的编码，iOS系统会进行验证，所以动态通过网络获取 新的动态库 也用不了。 七、rollout.ioRollout紧急修复线上bug。后端有相关的管理页面。因为是国外的网站，然后呢，要FQ才能使用。 八、DynamicCocoa滴滴iOS的一个框架，准备在2017年初开源，与JSPatch比更加智能化，用OC在XCode中写完代码，用工具可以自动生成可以更新的js文件。 转自 iOS热更新-8种实现方式]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>热更新</tag>
      </tags>
  </entry>
</search>
