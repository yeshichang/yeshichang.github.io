<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Loves essay]]></title>
    <url>%2F2019%2F09%2F20%2FLoves-essay%2F</url>
    <content type="text"><![CDATA[开篇： 为了自己欣赏自己喜欢的文章 不做多少评论 提升自身文学修养 北平的秋—老舍 ＜四世同堂＞节选中秋前后是北平最美丽的时候。天气正好不冷不热，昼夜的长短也划分得平匀。没有冬季从蒙古吹来的黄风，也没有伏天里挟着冰雹的暴雨。天是那么高，那么蓝，那么亮，好象是含着笑告诉北平的人们：在这些天里，大自然是不会给你们什么威胁与损害的。西山北山的蓝色都加深了一些，每天傍晚还披上各色的霞帔。 在太平年月，街上的高摊与地摊，和果店里，都陈列出只有北平人才能一一叫出名字来的水果。各种各样的葡萄，各种各样的梨，各种各样的苹果，已经叫人够看够闻够吃的了，偏偏又加上那些又好看好闻好吃的北平特有的葫芦形的大枣，清香甜脆的小白梨，象花红那样大的白海棠，还有只供闻香儿的海棠木瓜，与通体有金星的香槟子，再配上为拜月用的，贴着金纸条的枕形西瓜，与黄的红的鸡冠花，可就使人顾不得只去享口福，而是已经辨不清哪一种香味更好闻，哪一种颜色更好看，微微的有些醉意了！ 那些水果，无论是在店里或摊子上，又都摆列的那么好看，果皮上的白霜一点也没蹭掉，而都被摆成放着香气的立体的图案画，使人感到那些果贩都是些艺术家，他们会使美的东西更美一些。况且，他们还会唱呢！他们精心的把摊子摆好，而后用清脆的嗓音唱出有腔调的”果赞”：”唉——一毛钱儿来耶，你就挑一堆我的小白梨儿，皮儿又嫩，水儿又甜，没有一个虫眼儿，我的小嫩白梨儿耶！”歌声在香气中颤动，给苹果葡萄的静丽配上音乐，使人们的脚步放慢，听着看着嗅着北平之秋的美丽。 同时，良乡的肥大的栗子，裹着细沙与糖蜜在路旁唰啦唰啦的炒着，连锅下的柴烟也是香的。”大酒缸”门外，雪白的葱白正拌炒着肥嫩的羊肉；一碗酒，四两肉，有两三毛钱就可以混个醉饱。高粱红的河蟹，用席篓装着，沿街叫卖，而会享受的人们会到正阳楼去用小小的木锤，轻轻敲裂那毛茸茸的蟹脚。 同时，在街上的”香艳的”果摊中间，还有多少个兔儿爷摊子，一层层的摆起粉面彩身，身后插着旗伞的兔儿爷——有大有小，都一样的漂亮工细，有的骑着老虎，有的坐着莲花，有的肩着剃头挑儿，有的背着鲜红的小木柜；这雕塑的小品给千千万万的儿童心中种下美的种子。 同时，以花为粮的丰台开始一挑一挑的往城里运送叶齐苞大的秋菊，而公园中的花匠，与爱美的艺菊家也准备给他们费了半年多的苦心与劳力所养成的奇葩异种开”菊展”。北平的菊种之多，式样之奇，足以甲天下。 同时，象春花一般骄傲与俊美的青年学生，从清华园，从出产莲花白酒的海甸，从东南西北城，到北海去划船；荷花久已残败，可是荷叶还给小船上的男女身上染上一些清香。 同时，那文化过熟的北平人，从一入八月就准备给亲友们送节礼了。街上的铺店用各式的酒瓶，各种馅子的月饼，把自己打扮得象鲜艳的新娘子；就是那不卖礼品的铺户也要凑个热闹，挂起秋节大减价的绸条，迎接北平之秋。 北平之秋就是人间的天堂，也许比天堂更繁荣一点呢！ 本文节选自《四世同堂》人民文学出版社2012年版]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>短篇</tag>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔日志]]></title>
    <url>%2F2019%2F09%2F19%2F%E9%9A%8F%E7%AC%94%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[陛下，请输入密码查看. Incorrect Password! No content to display! U2FsdGVkX1+jpvGfMjxchTfs8sU8/sW2twwJS8vUiqyGLxYinxPBdG6I/2RyK4hsTwzPF1dQ8d1gN6PwKqJg655mQmHxjVn+Edka4jpm6RaiEf+73ly2udbxW2YX+Kou+6O4PnBFKaEaQdG+CEehK9L8DPzlZ9AzowoMbEuFL+8OqUR8yVprmlMpJ815ky9CmzeBxGlnP88AZerbdNIiZBJHaS94BNZrJqAWsmA0XpVuUqTfuTyhLik3hmQejy+dJzju4qQxZ9qyWbg5uIYLrb0NWHA5yVmTlxzN2RpgOqlg8FR3izPMwWOS7btwiSDgnyxWYKrKnTKgCzM8yr6CcGUV1Aeu/VcJQPFSumW07Q1YneUqsJUt4NGW4WIRWoItZbOZCYUZf/FiL7iHng5kyCMsDJ/3zSVNlEgA6W+zArL89Z3SY9fzBxZvNRvjITeLxCiT9DYF6666MDy2ZnRqSjYfTmrDXa8tWULs83CS7VePb/GOrjlxwlGgJykWx0k6m3sjTuT1gUNoAf1tYE9rSkA2zUvwZy6+nWrcXJZUgy27P3Tyw5S9GVpVY+bg/d7WBzy4p9JICkECOLD/0S2+qGLvwBWW/ojUEyIrrkYMgJvyohj4Il2Yxs3y3sSqBQwWn3HyJ8V5eDw2foZamDJEhZ2Ao3VTPdpJq6yP2UVpiLJqCgz0i0LdoLMESZ43oMoap2BWIgKVZHqmP491dDLBAP+Ib+yZ7NUVo7HpDinlzLNocyzwVYW33agAE8LaIzULV5McIcx6DGEF5JyzMsNL/TH7bSNGBm+2HeS1Nx+GjAnVdNJKdl9IoTGhUbEPd9FzS5Sp+g182jwVZFOuKBJ2/HwO4IcCbIBMyRz20eJRvp5fXIeLn7ei+IkApBgOh5ziEcA6BsLAhKwBMJcXcL2xJ6YhW7dLyrX/NCZx67oqlD2g9y9UcQpNUCeKZDl+Y3RfUlDwMMByCvZ5z2G6FWNVBDT0QrGsyhcvbZ9pIrjr3FJZGx7+tSS4qKwDaifHxnCGiLWzDEx+gQ9cwGanuwOOFAIfoYHLv4yWTiZBvTuaA67nrE4FgYcbZs22S2jnji+5ssvbggkBUF8QpjKqsXYsOtI3SZxvhiomPgWMWWEdFHfjWHovP59pSU8Uez46WtZdraGvzb5A0MBsb3gf0DFaZq6uQ3aHJM+hdWjhMtPAuktl9bJiZYnMvsXzkg5kbllvG0iymK0lFCF1I2uirxlWQl2+mMCzy/0Fe098l1XZELnob6cVFbwpLrlYLGZI7nzI9t2MDiKloR+jRyrf2qhDa0MOlzMzHDwCSXJsdvxRfZXPlGD9clyx8u9GqdOtxeHeGJ/t6OuOomr9sOc1F6fTzfJUl97NoLRfyN5cb41x70jHItURfz96n/j7dmaOnSk0VYgNcmlx6arvofzscBsHtVXhXKfNWVXJbd3KdV52s4oSEM55N6ZCudiYRaHxbUrp1rdFuF5irEwrEmcYBSsHuOmeyqG2UyJaE5isbnbL+XgCSaYEPZlDJqtLTiTpThdYXL5l5MhVwN6i7raO3OWN2cbAOZy5cB1BoD6/dGNEP+86SqgztZRMIBUE3VlPyPXJAyKVT4tdDQpXlWsVP80gTs6cbu0V+F/N7vAg2yWr/0L0y4mThP2lDrCfxmRo67vVFjiyMpn3fd+DU38fs51UEngmGkF8oPcXkqyYu1lTDW1EgfuVUqe2hNhXz3pk9TO17o9ztVkmf63/eo4hrHFdz+Kx7dNN4JNreceIL9AhbcqETMqrlIeOp6qRir3MN1I6BJfGYmXdgckzsC//bMmqAaMujgXK1E/Elyh8fO31NpEkYqOnF3ArtApZ9H0H7M0FIVkoPdPIi3+9E2yHNRN/THrtBiXOVdg+EP7QdvT8LrkfOluJoDAA7EjRjCWOfAr8WYRy+sT1tNn2QkQ4Hh6ChEUoEhEgtuBtnk37LUHNoEaeEKROMA3t2V8kcCyD5FFgrJwZaiGtzPmWeEa+cIe4D/8LSPI7Vu0oGQFCtcEBiLRquUKmPmFfiQ/VNMbzcYdamdbf2az8V7LXFimAa9SiUqf/dzsCc+SvByrgKcJg+6SI5chkE5te+0W1zUp1GQNWSBroSpYmcUObTcxwQdiegYLbAxkM9peKxUYtnJJI+Le9x1IvlvWQ7keNWNsCu9zMbLXCx4xbGJ8waKVepnTshiL1INfZQDN2lCnGCZzKgNaN/9tURpXYwlCPWfrX+5baroADmHjetf7EWNLCAxp21DYq7nhnjNg67SeULdkYzgBa3Pz/8wX4q9J3QzC9dI7Lnt1x4cgm6wrQE3zbs/nRxMOv6ehV8ODg3i2K4+3GGxvaltKaEp0z5Wx6iIbh96v/J5ckwTGrPr39SgrHMlE2GZ73W5HPLIB6TBjwemt1fmaGooKMF/cu5WLb8SMCzAfTK4XzYg31IvCgGLfvL2fL2ejy2VoS2GWnlIDASOSADgbnXHCDGWaOcSbCGcc/hroP49S3TvDJhvZSEaDaHq2YaaItHAo5nNxStECghkfkMFudpHUfny2s+stvCWBfeTUSbesQaZM66IFR3KBDAj1G2EQfrRMWvxYK7YNZSfRY9BmefJHo1p1Ha+SfnUcBnp5DfXVtW2tRgapD/fa4luEYQ/iir+sZLbaFAoTummDH3PrTWgtVyh6UmyzubPXb1r1jBb7qe9Gv1J7goTFpM1J729i8AaeYMrBdwr1bPV5sp53G2OuwTZHnVec8d69uU2g/konwRqvtW9lhTTP1ToC/IaOob3abpI/u8a/5nZzG8ZIL5qlnbqntlKXmJFGSjLf6vsj/8EuAykA9VQ+Ri4phCv9xfudKo82DRGiCMIZT2vS4Z0WCFeFQ6dvipR6fRvoMm3mdO6AMLdHzDKilVO9X3CIGnVAadJt3kDdZcjfa632nm0xHYzE/xDapOjue7ZZuL+jmOQ7oOFW3W32r/Vq59+zUhL/OzV9O3PkraR8pMCbAtLmBOewT9pEdW28O4ptOkRVSlBvBvze5yZHoPQiraQ/tsidQ31QdG4tOcD6jqv3YMSOc3pXx7wwvTLo+jZin1CKq0DGPQGrZQ0dCpMtb7TR0/6UfJiSlsWuCm9tDsC7eW/u/U/CGUFo8GcpnHb+RimdRCvLc52n/OTEc3AAeZKkos6ijfB/cMUNsJO+gLQibbVeafIINPLa9Kc6PIysteL/FhWLMiWBIyRIVWHWYBBIpF3ubcbhTbkDHwZg3gK507gSsX87N8cwzbsHMOpeH0m3mlU96nV9NmcTTwbzL2+nSOWbK+gLyp1dIWFRnt1645s8O1zOpynlbrvHC/50xkFALqxwP1pv+w79cpoRqj+9NeXD/QA9ewLf2jb4e/yW9YiY6CCJcHOsAboyPgXXvnhoXnnai6X9R7WcWvh81ydvoUpkT8pPbA5BgSXScrNiLZ8wFtRwBAq3yF6eMqz7Anjm3sEPWHpUNG5qx2hM2A1urHAMcL1ZptQVxaiXgxiHU30pPwKstBt+Q67sTP1iz3FehFMvF5QvUfMBOlxekYqhtP5Bzxb0KtXFCATJLXNe2Ss6aw/vz65plJMLrvGNtKCX+7jcRKlL8+DUVFkwhWSXS230v1jPDwnyZRm2yNhPr0b4Z9SAYinaiAP0lCy9TmKI+n+10M6flS7NVe/OqXlUggZYMwEK77itmn1LXrkHT6F3kggwX/ykio2MjRTAFxf0i4A2CPQACN3X9j7/XEGseAs12Vd9zzIMZa8NDriygW37ASvix29zZ7SIbBFht6M2xd1pIaWnD9gKUUbxoHw4EGyFmAdab+FySgkFFo3JhmjYYb6exj1+7cViUmILpGsNxyhlVin0owl1AQtAyrDahDQCg8JVvT3VstC1TnhNYf9ZhBCegHgn/TqQ4E8RQiVDPCre+c473yPkEkOdBLw==]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Study English]]></title>
    <url>%2F2019%2F09%2F07%2F%E5%AD%A6%E4%B9%A0%E8%8B%B1%E6%96%87%2F</url>
    <content type="text"><![CDATA[编程和英文息息相关，不会英文对开发过程中造成的影响还是不小的。尤其在读一些文档方面，熟悉每个单词的中文意思对读懂整个文档帮助很大。我的英文水平在高中后退化就很大了，大学英语基本上也没学过，词汇量不大，对我的工作生活影响也很大，虽然听力不行，但是增大词汇量对读一些国外文章就不成问题。平时的开发经常查一些单词，捡起来一些东西了，以后还是把自己所查的东西给记录下来吧。便于自己以后看看。 每天记录一些自己不认识或者不熟悉的单词 单词 释意 读音 Diamond 金刚石;钻石;菱形;(纸牌的)方块 美 [ˈdaɪəmənd] Permission 准许;许可;批准;许可证;书面许可 美 [pərˈmɪʃn] External 外部的;外面的;外界的;外来的;在外的;来自(学校或机构)以外的 美 [ɪkˈstɜːrnl] Incompatible 不可兼容的;不相容;不相容的;不兼容的;不相容性 美 [ˌɪnkəmˈpætəbl] percent 百分之… 美 [pərˈsɛnt] Reorder 调整顺序;重新排序;重排序;重排;顺序调整 美 [ˌriːˈɔːrdər] Essay 文章，短文;(用来刊登的)论说文;小品文 美 [ˈeseɪ , eˈseɪ] 记录一些自己喜欢的英文语句]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ipa 打包shell脚本]]></title>
    <url>%2F2019%2F09%2F05%2Fipa-%E6%89%93%E5%8C%85shell%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[问题描述当我们想打包一个IPA，为自己内部测试使用，或者IPA部署自己服务器，这时候我们使用shell脚本就方便点了。 Xcode scheme run set release， device set generic iOS device，  run done product 文件夹下就有我们想要的东西了 编写好shell脚本，自动化快速为我们打包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#!/bin/shecho '\033[32m xcodebuild----------------------------start-------------------------- \033[0m'#打包基础配置userName='ysc'appName='Vostic'svnVersion='1.1.1'serverConfig='BeiJing'#serverConfig='ShuBei'#debugMode='Debug'debugMode='Release'sandbox='eynjaojbmfxqukcbinxdlfasvkpi'savePath=/Users/$&#123;userName&#125;/Desktop/xcodebuildsvnCheckPath=/Users/$&#123;userName&#125;/Desktop/iOS/VosticsvnLocalPath=$&#123;svnCheckPath&#125;/$&#123;svnVersion&#125;svnRemotePath=svn://yeshichang@10.1.6.1/dev/issue/iOS/Vostic/2019/$&#123;svnVersion&#125;#检出svnecho "checkout svn $svnVersion"if [ ! -d "$svnLocalPath" ]; thencd $&#123;svnCheckPath&#125;svn checkout $&#123;svnRemotePath&#125;fiecho '\033[32m xcodebuild---------------------------build--------------------------- \033[0m'#输入版本号read -p "Build version:" buildVersion#检查测试包是否已存在if [ -d "$svnLocalPath/$buildVersion" ]; thenecho "check $buildVersion is exists!"exit 0fi#输入Git版本号read -p "Git version:" gitVersion#开始时间戳startTime=$(date +%s)#创建存放目录if [ ! -d "$savePath" ]; thenmkdir "$savePath"fi#判断目录存在if [ ! -d "$savePath" ]; thenecho "check $savePath is no exists!"exit 0fi#打开存放目录cd $&#123;savePath&#125;#移除目录文件rm -rf *#创建版本目录mkdir "$savePath/$buildVersion"#拷贝xxx.app到存放目录cp -rf /Users/$&#123;userName&#125;/Library/Developer/Xcode/DerivedData/$&#123;appName&#125;-$&#123;sandbox&#125;/Build/Products/$&#123;debugMode&#125;-iphoneos/$&#123;appName&#125;.app $&#123;savePath&#125;#拷贝xxx.app到存放目录cp -rf /Users/$&#123;userName&#125;/Library/Developer/Xcode/DerivedData/$&#123;appName&#125;-$&#123;sandbox&#125;/Build/Products/$&#123;debugMode&#125;-iphoneos/$&#123;appName&#125;.app.dSYM $&#123;savePath&#125;/$&#123;buildVersion&#125;echo '\033[32m xcodebuild----------------------------ipa-------------------------- \033[0m'#利用itues将xxx.app生成ipamkdir Payloadcp -rf $&#123;appName&#125;.app Payload/$&#123;appName&#125;.appcp Icon.png $&#123;appName&#125;/iTunesArtworkzip -r $&#123;appName&#125;.ipa Payload iTunesArtwork#移除临时文件rm -rf Payloadrm -rf $&#123;appName&#125;.app#移动xxx.ipa到版本目录packageName=iOS_$&#123;buildVersion&#125;_$(date "+%Y%m%d")_$&#123;serverConfig&#125;_$&#123;gitVersion:0:10&#125;mv $&#123;appName&#125;.ipa $&#123;packageName&#125;.ipamv $&#123;packageName&#125;.ipa ./$&#123;buildVersion&#125;echo '\033[32m xcodebuild----------------------------zip-------------------------- \033[0m'#打开版本目录cd $&#123;savePath&#125;/$&#123;buildVersion&#125;#压缩xxx.ipa、xxx.app.dSYMzip -r -m $&#123;buildVersion&#125;.zip ./#回到存放目录cd ..#拷贝测试包到svn目录if [ ! -d "$svnLocalPath/$buildVersion" ]; thenmv $&#123;buildVersion&#125; $&#123;svnLocalPath&#125;fiecho '\033[32m xcodebuild----------------------------svn-------------------------- \033[0m'#打开svn目录cd $&#123;svnLocalPath&#125;#提交测试包svn cleanupsvn add $&#123;buildVersion&#125;svn commit -m "提交iOS测试包$buildVersion" $&#123;buildVersion&#125;#结束时间戳endTime=$(date +%s)time=$(($endTime - $startTime))minute=$(($time/60))second=$(($time%60))echo "\033[44;37m 总用时：$&#123;minute&#125;分$&#123;second&#125;秒 \033[0m"echo '\033[32m xcodebuild----------------------------end-------------------------- \033[0m'exit 0]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS13 自定义返回键位置问题]]></title>
    <url>%2F2019%2F09%2F02%2FiOS13-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%94%E5%9B%9E%E9%94%AE%E4%BD%8D%E7%BD%AE%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[iOS13 beta7已经出来了，为了提前适配应用，测试机升级看看应用是否有问题，幸好坑不算多，主要问题就是用系统导航栏的位置返回按钮向右偏移过多。主要与原有项目中的一些自定义导航返回键不统一。之前项目已经对iOS11后导航栏的变化做过处理 iOS11以下通过UIBarButtonSystemItemFixedSpace进行处理，可以参考论坛的一篇文章，但是iOS13系统处理不了。 所以寻找新方法解决这个问题，让我们先删除原来项目代码，大刀阔斧的干，要有豁出去的精神。 因为是使用系统导航栏，况且项目很大，不容易去修改整个结构，遂就对系统导航进行修改网上参考，在寻找一些解决方案。觉得这篇最合适 iOS11 导航栏按钮位置问题的解决——新，简洁流畅无冗余，结合自己项目做一些修改。最主要同时解决iOS13导航栏返回键偏移的问题。使用layoutMargins这个属性遍历图层大致可以看到时这样的结构 1&lt;_UINavigationBarContentView: 0x7fc141607250; frame = (0 0; 414 44); layer = &lt;CALayer: 0x608000038cc0&gt;&gt; 这个UINavigationBarContentView平铺在导航栏中作为iOS11的各个按钮的父视图,该视图的所有的子视图都会有一个layoutMargins被占用,也就是系统调整的占位,我们只要把这个置空就行了.那样的话该视图下的所有的子视图的空间就会变成我们想要的那样,当然为了保险起见,该视图的父视图也就是bar的layoutMargins也置空,这样 整个bar就会跟一个普通视图一样了 左右的占位约束就不存在了 可以过代码处理 12345678910111213141516171819202122@implementation UINavigationBar (FixSpace)+(void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; [self swizzleInstanceMethodWithOriginSel:@selector(layoutSubviews) swizzledSel:@selector(vst_layoutSubviews)]; &#125;);&#125;-(void)vst_layoutSubviews&#123; [self vst_layoutSubviews]; if (deviceVersion &gt;= 11) &#123; self.layoutMargins = UIEdgeInsetsZero; for (UIView *subview in self.subviews) &#123; if ([NSStringFromClass(subview.class) containsString:@"ContentView"]) &#123; subview.layoutMargins = UIEdgeInsetsZero;//可修正iOS11之后的偏移 &#125; &#125; &#125;&#125;@end 最终代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215#import &lt;UIKit/UIKit.h&gt;@interface UINavigationConfig : NSObject@property (nonatomic, assign) CGFloat vst_defaultFixSpace; // item距离两端的间距,默认为0@property (nonatomic, assign) BOOL vst_disableFixSpace; // 是否禁止使用修正,默认为NO+ (instancetype)shared;- (instancetype)init NS_UNAVAILABLE;+ (instancetype)new NS_UNAVAILABLE;- (CGFloat)vst_systemSpace;@end@interface UINavigationItem (VSTFixSpace)@end@interface NSObject (VSTFixSpace)@end#import "UINavigationVSTFixSpace.h"#import &lt;objc/runtime.h&gt;void vst_swizzle(Class oldClass, NSString *oldSelector, Class newClass) &#123; NSString *newSelector = [NSString stringWithFormat:@"vst_%@", oldSelector]; Method old = class_getInstanceMethod(oldClass, NSSelectorFromString(oldSelector)); Method new = class_getInstanceMethod(newClass, NSSelectorFromString(newSelector)); method_exchangeImplementations(old, new);&#125;@implementation UINavigationConfig+ (instancetype)shared &#123; static UINavigationConfig *config; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; config = [[self alloc] init]; &#125;); return config;&#125;-(instancetype)init &#123; if (self = [super init]) &#123; self.vst_defaultFixSpace = 0; self.vst_disableFixSpace = NO; &#125; return self;&#125;- (CGFloat)vst_systemSpace &#123; return MIN([UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height) &gt; 375 ? 20 : 16;&#125;@end@implementation UINavigationItem (VSTFixSpace)+(void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; if (@available(iOS 11.0, *)) &#123;&#125; else &#123; NSArray &lt;NSString *&gt;*oriSels = @[@"setLeftBarButtonItem:", @"setLeftBarButtonItem:animated:", @"setLeftBarButtonItems:", @"setLeftBarButtonItems:animated:", @"setRightBarButtonItem:", @"setRightBarButtonItem:animated:", @"setRightBarButtonItems:", @"setRightBarButtonItems:animated:"]; [oriSels enumerateObjectsUsingBlock:^(NSString * _Nonnull oriSel, NSUInteger idx, BOOL * _Nonnull stop) &#123; vst_swizzle(self, oriSel, self); &#125;]; &#125; &#125;);&#125;-(void)vst_setLeftBarButtonItem:(UIBarButtonItem *)leftBarButtonItem &#123; [self setLeftBarButtonItem:leftBarButtonItem animated:NO];&#125;-(void)vst_setLeftBarButtonItem:(UIBarButtonItem *)leftBarButtonItem animated:(BOOL)animated &#123; if (!UINavigationConfig.shared.vst_disableFixSpace &amp;&amp; leftBarButtonItem) &#123;// 存在按钮且需要调节 [self setLeftBarButtonItems:@[leftBarButtonItem] animated:animated]; &#125; else &#123;// 不存在按钮,或者不需要调节 [self vst_setLeftBarButtonItem:leftBarButtonItem animated:animated]; &#125;&#125;-(void)vst_setLeftBarButtonItems:(NSArray&lt;UIBarButtonItem *&gt; *)leftBarButtonItems &#123; [self setLeftBarButtonItems:leftBarButtonItems animated:NO];&#125;-(void)vst_setLeftBarButtonItems:(NSArray&lt;UIBarButtonItem *&gt; *)leftBarButtonItems animated:(BOOL)animated &#123; if (!UINavigationConfig.shared.vst_disableFixSpace &amp;&amp; leftBarButtonItems.count) &#123;// 存在按钮且需要调节 UIBarButtonItem *firstItem = leftBarButtonItems.firstObject; CGFloat width = UINavigationConfig.shared.vst_defaultFixSpace - UINavigationConfig.shared.vst_systemSpace; if (firstItem.width == width) &#123;// 已经存在space [self vst_setLeftBarButtonItems:leftBarButtonItems animated:animated]; &#125; else &#123; NSMutableArray *items = [NSMutableArray arrayWithArray:leftBarButtonItems]; [items insertObject:[self fixedSpaceWithWidth:width] atIndex:0]; [self vst_setLeftBarButtonItems:items animated:animated]; &#125; &#125; else &#123;// 不存在按钮,或者不需要调节 [self vst_setLeftBarButtonItems:leftBarButtonItems animated:animated]; &#125;&#125;-(void)vst_setRightBarButtonItem:(UIBarButtonItem *)rightBarButtonItem&#123; [self setRightBarButtonItem:rightBarButtonItem animated:NO];&#125;- (void)vst_setRightBarButtonItem:(UIBarButtonItem *)rightBarButtonItem animated:(BOOL)animated &#123; if (![UINavigationConfig shared].vst_disableFixSpace &amp;&amp; rightBarButtonItem) &#123;// 存在按钮且需要调节 [self setRightBarButtonItems:@[rightBarButtonItem] animated:animated]; &#125; else &#123;// 不存在按钮,或者不需要调节 [self vst_setRightBarButtonItem:rightBarButtonItem animated:animated]; &#125;&#125;- (void)vst_setRightBarButtonItems:(NSArray&lt;UIBarButtonItem *&gt; *)rightBarButtonItems&#123; [self setRightBarButtonItems:rightBarButtonItems animated:NO];&#125;- (void)vst_setRightBarButtonItems:(NSArray&lt;UIBarButtonItem *&gt; *)rightBarButtonItems animated:(BOOL)animated &#123; if (!UINavigationConfig.shared.vst_disableFixSpace &amp;&amp; rightBarButtonItems.count) &#123;// 存在按钮且需要调节 UIBarButtonItem *firstItem = rightBarButtonItems.firstObject; CGFloat width = UINavigationConfig.shared.vst_defaultFixSpace - UINavigationConfig.shared.vst_systemSpace; if (firstItem.width == width) &#123;// 已经存在space [self vst_setRightBarButtonItems:rightBarButtonItems animated:animated]; &#125; else &#123; NSMutableArray *items = [NSMutableArray arrayWithArray:rightBarButtonItems]; [items insertObject:[self fixedSpaceWithWidth:width] atIndex:0]; [self vst_setRightBarButtonItems:items animated:animated]; &#125; &#125; else &#123;// 不存在按钮,或者不需要调节 [self vst_setRightBarButtonItems:rightBarButtonItems animated:animated]; &#125;&#125;- (UIBarButtonItem *)fixedSpaceWithWidth:(CGFloat)width &#123; UIBarButtonItem *fixedSpace = [[UIBarButtonItem alloc]initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil]; fixedSpace.width = width; return fixedSpace;&#125;@end@implementation NSObject (VSTFixSpace)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; if (@available(iOS 13.0, *)) &#123; NSDictionary &lt;NSString *, NSString *&gt;*oriSels = @&#123;@"_UINavigationBarContentView": @"layoutSubviews", @"_UINavigationBarContentViewLayout": @"_updateMarginConstraints"&#125;; [oriSels enumerateKeysAndObjectsUsingBlock:^(NSString * _Nonnull cls, NSString * _Nonnull oriSel, BOOL * _Nonnull stop) &#123; vst_swizzle(NSClassFromString(cls), oriSel, NSObject.class); &#125;]; &#125; &#125;);&#125;- (void)vst_layoutSubviews &#123; [self vst_layoutSubviews]; if (UINavigationConfig.shared.vst_disableFixSpace) return; if (![self isMemberOfClass:NSClassFromString(@"_UINavigationBarContentView")]) return; id layout = [self valueForKey:@"_layout"]; if (!layout) return; SEL selector = NSSelectorFromString(@"_updateMarginConstraints"); IMP imp = [layout methodForSelector:selector]; void (*func)(id, SEL) = (void *)imp; func(layout, selector);&#125;- (void)vst__updateMarginConstraints &#123; [self vst__updateMarginConstraints]; if (UINavigationConfig.shared.vst_disableFixSpace) return; if (![self isMemberOfClass:NSClassFromString(@"_UINavigationBarContentViewLayout")]) return; [self vst_adjustLeadingBarConstraints]; [self vst_adjustTrailingBarConstraints];&#125;- (void)vst_adjustLeadingBarConstraints &#123; if (UINavigationConfig.shared.vst_disableFixSpace) return; NSArray&lt;NSLayoutConstraint *&gt; *leadingBarConstraints = [self valueForKey:@"_leadingBarConstraints"]; if (!leadingBarConstraints) return; CGFloat constant = UINavigationConfig.shared.vst_defaultFixSpace - UINavigationConfig.shared.vst_systemSpace; for (NSLayoutConstraint *constraint in leadingBarConstraints) &#123; if (constraint.firstAttribute == NSLayoutAttributeLeading &amp;&amp; constraint.secondAttribute == NSLayoutAttributeLeading) &#123; constraint.constant = constant; &#125; &#125;&#125;- (void)vst_adjustTrailingBarConstraints &#123; if (UINavigationConfig.shared.vst_disableFixSpace) return; NSArray&lt;NSLayoutConstraint *&gt; *trailingBarConstraints = [self valueForKey:@"_trailingBarConstraints"]; if (!trailingBarConstraints) return; CGFloat constant = UINavigationConfig.shared.vst_systemSpace - UINavigationConfig.shared.vst_defaultFixSpace; for (NSLayoutConstraint *constraint in trailingBarConstraints) &#123; if (constraint.firstAttribute == NSLayoutAttributeTrailing &amp;&amp; constraint.secondAttribute == NSLayoutAttributeTrailing) &#123; constraint.constant = constant; &#125; &#125;&#125;@end 原文demo地址]]></content>
      <categories>
        <category>Coding日常problem</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[My life]]></title>
    <url>%2F2019%2F08%2F31%2FMy-life%2F</url>
    <content type="text"><![CDATA[陛下，请输入密码查看. Incorrect Password! No content to display! U2FsdGVkX19JpfvSOnQ2CA54DUiJG75KzJ0K4jM29YJbBzsyjG9MoTbjD6H/83iMaUI2Ozx5KgDYRCh8IU7YXbS9hS9iGnwEllayS9jDqJ6dp3olI7mQHMH9VuSstu7n]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iPhone A12芯片录制编码解码失败问题]]></title>
    <url>%2F2019%2F08%2F31%2FiPhone-A12%E8%8A%AF%E7%89%87%E5%BD%95%E5%88%B6%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[语玩项目中发布动态，有个录制视频功能，录制视频用的是公司底层库C++编写的代码，现在遇到个问题。 问题描述 用A12以下处理器来录制视频，没问题，可以再任何苹果设备和安卓设备上播放 用A12处理器设备录制视频，在A12以下处理器的设备可以播放，在安卓设备也可以播放，但是在用A12处理器设备播放不了视频 特点是黑屏 验证我用手机iPhone XR录制视频，确实在本设备上不能够播放，在Safari浏览器上也不能播放，在本地相册中也不能播放。在其他设备可播放， iPhone XS iPhone XS Max 不可播放。 解决 底层库开发人员修改代码，使用软编码录制，确实可解决问题，但是视频质量不佳 不使用原生AVPlayer，使用其他第三方播放器如&lt;KSYMediaPlayer&gt;可播放，自己实现解码可播放。 经查明，是苹果系统的问题，从iOS12开始，这个bug一直未修复，听说是在iOS13 beta7版本中修复了此bug，但是苦于没有设备，别人的设备也不能够给人家升级beta版，无法做验证。]]></content>
      <categories>
        <category>Coding日常problem</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构 & 算法 in Swift （二）：算法概述和排序算法]]></title>
    <url>%2F2019%2F08%2F30%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%26%20%E7%AE%97%E6%B3%95%20in%20Swift%20%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0%E5%92%8C%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本篇是《数据结构 &amp; 算法 in Swift》系列连载的第二篇，内容分为如下两个部分： 算法基础：简单介绍算法的概念，时间复杂度与空间复杂度，递归，作为本文第二部分的背景知识。 排序算法：结合Swift的代码实现来讲解冒泡排序，选择排序，插入排序，归并排序，快速排序。 算法基础 该部分是给那些对算法以及相关知识不了解的读者准备的，如果已经对算法的相关知识有所了解，可以略过该部分，直接看本文的第二部分：排序算法。 关于该部分的讨论不属于本文介绍的重点，因此没有过多非常专业的论述，只是让那些对算法不了解的读者可以对算法先有一个基本的认识，为阅读和理解本文的第二部分做好准备。 算法的概念算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。 摘自《大话数据结构》 简单说来，算法就是“一个问题的解法”。对于相同一个问题，可能会有多种不同的解法。这些解法虽然可以得到相同的结果，但是每个算法的执行所需要的时间和空间资源却可以是千差万别的。 以消耗的时间的角度为出发点，我们看一下对于同一个问题，两种不同的解法的效率会相差多大： 现在让我们解决这个问题：计算从1到100数字的总和。 把比较容易想到的下面两种方法作为比较： 1到100循环遍历逐步相加 等差数列求和 用Swift函数来分别实现一下： 12345678910111213141516171819func sumOpration1(_ n:Int) -&gt; Int&#123; var sum = 0 for i in 1 ... n &#123; sum += i &#125; return sum&#125;sumOpration1(100)//5050func sumOpration2(_ n:Int) -&gt; Int&#123; return (1 + n) * n/2&#125;sumOpration2(100)//5050 上面的代码中，sumOpration1使用的是循环遍历的方式；sumOpration2使用的是等差数列求和的公式。 虽然两个函数都能得到正确的结果，但是不难看出两个函数实现的效率是有区别的: 遍历求和所需要的时间是依赖于传入函数的n的大小的，而等差数列求和的方法所需要的时间对传入的n的大小是完全不依赖的。 在遍历求和中，如果传入的n值是100，则需要遍历100次并相加才能得到结果，那么如果传入的n值是一百万呢？ 而在等差数列求和的函数中，无论n值有多大，只需要一个公式就可以解决。 我们对此可以以小见大：世上千千万万种问题（算法题）可能也有类似的情况：相同的问题，相同的结果，但是执行效率缺差之千里。那么有没有什么方法可以度量某种算法的执行效率以方便人们去选择或是衡量算法之间的差异呢？ 答案是肯定的。 下面笔者就向大家介绍算法所消耗资源的两个维度：时间复杂度和空间复杂度。 时间复杂度与空间复杂度时间复杂度算法的时间复杂度是指算法需要消耗的时间资源。一般来说，计算机算法是问题规模!n的函数f(n)，算法的时间复杂度也因此记做： 常见的时间复杂度有：常数阶O(1)，对数阶O(log n），线性阶 O(n)，线性对数阶O(nlog n)，平方阶O(n^{2})，立方阶O(n^{3})，!k次方阶O(n^{k})，指数阶 O(2^{n})}。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。 拿其中几个复杂度做对比： 从上图中我们可以看到，平方阶O(n^{2})随着n值的增大，其复杂度近乎直线飙升；而线性阶 O(n)随着n的增大，复杂度是线性增长的；我们还可以看到常数阶 O(1)随着n增大，其复杂度是不变的。 参考上一节的求和问题，我们可以看出来遍历求和的算法复杂度是线性阶O(n)：随着求和的最大数值的大小而线性增长；而等差数列求和算法的复杂度为常数阶 O(1)其算法复杂度与输入n值的大小无关。 读者可以试着想一个算法的复杂度与输入值n的平方成正比的算法。 在这里笔者举一个例子：求一个数组中某两个元素和为某个值的元素index的算法。数组为[0,2,1,3,6]，和为8： 1234567891011121314151617181920212223242526func findTwoSum(_ array: [Int], target: Int) -&gt; (Int, Int)? &#123; guard array.count &gt; 1 else &#123; return nil &#125; for i in 0..&lt;array.count &#123; let left = array[i] for j in (i + 1)..&lt;array.count &#123; let right = array[j] if left + right == target &#123; return (i, j) &#125; &#125; &#125; return nil&#125;let array = [0,2,1,3,6]if let indexes = findTwoSum(array, target: 8) &#123; print(indexes) //1， 4&#125; else &#123; print("No pairs are found")&#125; 上面的算法准确地计算出了两个元素的index为1和4。因为使用了两层的遍历，所以这里算法的复杂度是平方阶O(n^{2}。关于算法复杂度的详细推倒方法，可以参考网上和算法相关书籍的资料。 而其实，不需要遍历两层，只需要遍历一层即可：在遍历的时候，我么知道当前元素的值a，那么只要其余元素里面有值等于（target - a）的值即可。所以这次算法的复杂度就是线性阶O(n)了。 同样地，上面两种算法虽然可以达到相同的效果，但是当n非常大的时候，二者的计算效率就会相差更大：n = 1000的时候，二者得到结果所需要的时间可能会差好几百倍。可以说平方阶O(n^{2})复杂度的算法在数据量很大的时候是无法让人接受的。 空间复杂度算法的空间复杂度是指算法需要消耗的空间资源。其计算和表示方法与时间复杂度类似，一般都用复杂度的渐近性来表示。同时间复杂度相比，空间复杂度的分析要简单得多。而且控件复杂度不属于本文讨论的重点，因此在这里不展开介绍了。 递归在算法的实现中，遍历与递归是经常出现的两种操作。 对于遍历，无非就是使用一个for循环来遍历集合里的元素，相信大家已经非常熟悉了。但是对于递归操作就可能比较陌生。而且由于本文第二部分讲解算法的是时候有两个算法（也是比较重要）的算法使用了递归操作，所以为了能帮助大家理解这两个算法，笔者觉得有必要将递归单独拿出来讲解。 先看一下递归的概念。 递归的概念递归的概念是：在数学与计算机科学中，是指在函数的定义中使用函数自身的方法摘自维基百科 摘自维基百科 通过使用递归，可以把一个大型复杂的问题逐层转化为一个与原问题相似的规模较小的问题来求解。因此如果使用递归，可以达到使用少量的代码就可描述出解题过程所需的多次重复计算的目的，减少了程序的代码量 。 下面用一个例子来具体感受一下递归操作： 大家应该都比较熟悉阶乘的算法：3！= 3 2 1 ； 4！= 4 3 2 * 1 不难看出，在这里反复执行了一个逐渐-1和相乘的操作，如果可以使用某段代码达到重复调用的效果就很方便了，在这里就可以使用递归： 12345func factorial(_ n:Int) -&gt; Int&#123; return n &lt; 2 ? 1: n * factorial(n-1)&#125;factorial(3) //6 在上面的代码里，factorial函数调用了它自己，并且在n&lt;2的时候返回了1；否则继续调用自己。 从代码本身其实不难理解函数调用的方式，但是这个6究竟是怎么算出来的呢？这就涉及到递归的实现原理了。 递归的实现原理递归的调用实际上是通过调用栈（callback stack）来实现的，笔者用一张图从factorial(3)开始调用到最后得出6这个顺序之间发生的事情画了出来： 由上图可以看出，整个递归的过程和栈的入栈出栈的操作非常类似：橘黄色背景的圆角矩形代表了栈顶元素，也就是正在执行的操作，而灰色背景的圆角矩形则代表了其余的元素，它们的顺序就是当初被调用的顺序，而且在内容上保持了当时被调用时执行的代码。 现在笔者按照时间顺序从左到右来说明一下整个调用的过程： 最开始传入3之后，3满足了n&gt;=2的条件，继续调用自己：3 * factorial(2) ，入栈。 传入2之后，2满足了n&gt;=2的条件，继续调用自己：2 * factorial(1) ，入栈。 传入1之后，1满足了n&lt;2的条件，停止调用自己，返回了1，出栈。 此时的栈顶元素为2 factorial(1) ，而刚刚factorial(1)返回了1，所以现在这里变成了2 1 = 2，出栈。 同样地，此时栈顶元素为3 factorial(2)里的 factorial(2)返回了2，所以现在这里变成了3 2 = 6，出栈。 最后，factorial(3)返回了6，出栈，递归结束。 按照笔者个人的理解：整个递归的过程可以大致理解为：在使递归继续的条件为false之前，持续递归调用，以栈的形式保存调用上下文（临时变量，函数等）。一旦这个条件变为true，则立即按照出栈的顺序（入栈顺序的逆序）来返回值，逐个传递，最终传递到最开始调用的那一层返回最终结果。 再简单点，递归中的“递”就是入栈，传递调用信息；“归”就是出栈，输出返回值。 而这个分界线就是递归的终止条件。很显然，这个终止条件在整个递归过程中起着举足轻重的作用。试想一下，如果这个条件永远不会改变，那么就会一直入栈，就会发生栈溢出的情况。 使用递归时需要注意的问题基于上面递归的例子，我们将递归终止条件去掉： 12345func factorialInfinite(_ n:Int) -&gt; Int&#123; return n * factorialInfinite(n-1)&#125;factorialInfinite(3) 这段代码如果放在playground里，经过一小段时间（几秒钟或更多）后，会报一个运行时错误。也可以在return语句上面写一个print函数打印一些字符串，接着就会看到不停的打印，直到运行时错误，栈溢出。 所以说在今后写关于递归的代码的时候，一定要注意递归的终止条件是否合理，因为即使条件存在也不一定就是合理的条件。我们看一下下面这个例子： 12345678func sumOperation( _ n:Int) -&gt; Int &#123; if n == 0 &#123; return 0 &#125; return n + sumOperation(n - 1)&#125;sumOperation(2) //3 上面的代码跟阶乘类似，也是和小于当前参数的值相加，如果传入2，那么知道 n=0时就开始出栈， 2 + 1 + 0 = 3。看似没什么问题，但是如果一开始传入 - 1 呢？结果就是不停的入栈，直到栈溢出。因为 n == 0 这个条件在传入 - 1 的时候是无法终止入栈的，因为 - 1 之后的 -1 操作都是非0的。 所以说这个条件就不是合理的，一个比较合理的条件是 n &lt; = 0。 12345678func sumOperation( _ n:Int) -&gt; Int &#123; if n &lt;= 0 &#123; return 0 &#125; return n + sumOperation(n - 1)&#125;sumOperation(-1) //0 相信到这里，读者应该对递归的使用，调用过程以及注意事项有个基本的认识了。 那么到这里，关于算法的基本介绍已经讲完了，下面正式开始讲解排序算法。 排序算法讲解算法之前，我们先来看一下几个常见的排序算法的对比： 排序算法 平均情况下 最好情况 最坏情况 稳定性 空间复杂度 冒泡 O(n^2) O(n） O(n^2) 稳定 1 选择排序 O(n^2) O(n^2) O(n^2) 不稳定 1 插入排序 O(n^2) O(n） O(n^2) 稳定 1 希尔排序 O(nlogn) 依赖步长 依赖步长 稳定 1 堆排序 O(nlogn) O(nlogn) O(nlogn) 稳定 1 归并排序 O(nlogn) O(nlogn) O(nlogn) 稳定 O(n） 快速排序 O(nlogn) O(nlogn) O(n^2) 不稳定 O(logn) 最好情况和最坏情况以及稳定性的概念不在本文的讨论范围之内，有兴趣的读者可以查阅相关资料。 现在只看平均情况下的性能： 冒泡排序，选择排序，插入排序的时间复杂度为平方阶O(n^{2}) 希尔排序，堆排序，归并排序，快速排序的时间复杂度为线性对数阶O(nlog n) 本篇要给大家介绍的是冒泡排序，选择排序，插入排序，归并排序和快速排序。 希尔排序是基于插入排序，理解了插入排序以后，理解希尔排序会很容易，故在本文不做介绍。堆排序涉及到一个全新的数据结构：堆，所以笔者将堆这个数据结构和堆排序放在下一篇来做介绍。 排序初探在讲排序算法之前，我们先看一种最简单的排序算法（也是性能最低的，也是最好理解的），在这里先称之为“交换排序”。 注意，这个名称是笔者自己起的，在互联网和相关技术书籍上面没有对该算法起名。 算法讲解用两个循环来嵌套遍历： 外层遍历数组从0到末尾的元素，索引为i. 里层遍历数组从i+1至数组末尾的元素，索引为j。 当i上的元素比j上的元素大的时候，交换i和j的元素，目的是保持index为i的元素是最小的。 我们用一个例子看一下是怎么做交换的： 给定一个初始数组：array = [4, 1, 2, 5, 0] i = 0 时： array[0] &gt; array[1] : 交换4和1：[1, 4, 2, 5, 0]，内层的j继续遍历，j++。 array[0] &gt; array[4] : 交换0和1：[0, 4, 2, 5, 1]，i = 0的外层循环结束，i++。 i = 1时： array[1] &gt; array[2] : 交换2和4：[0, 2, 4, 5, 1]，内层的j继续遍历，j++。 array[1] &gt; array[4] : 交换1和2：[0, 1, 4, 5, 2]，i = 1的外层循环结束，i++。 i = 2 时： array[2] &gt; array[4] : 交换2和4：[0, 1, 2, 5, 4]，i = 2的外层循环结束，i++。 i = 3 时： array[3] &gt; array[4] : 交换5和4：[0, 1, 2, 4, 5]，i = 3的外层循环结束，i++。 i = 4 时：不符合内循环的边界条件，不进行内循环，排序结束。 那么用代码如何实现呢？ 代码实现1234567891011121314151617func switchSort(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; for i in 0 ..&lt; array.count &#123; for j in i + 1 ..&lt; array.count &#123; if array[i] &gt; array[j] &#123; array.swapAt(i, j) print("\(array)") &#125; &#125; &#125; return array &#125; 这里面swapAt函数是使用了Swift内置的数组内部交换两个index的函数，在后面会经常用到。 为了用代码验证上面所讲解的交换过程，可以在swapAt函数下面将交换元素后的数组打印出来： 1234567891011121314151617181920212223var originalArray = [4,1,2,5,0]print("original array:\n\(originalArray)\n")func switchSort(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; for i in 0 ..&lt; array.count &#123; for j in i + 1 ..&lt; array.count &#123; if array[i] &gt; array[j] &#123; array.swapAt(i, j) print("\(array)") &#125; &#125; &#125; return array &#125;switchSort(&amp;originalArray) 打印结果： 1234567891011original array:[4, 1, 2, 5, 0]switch sort...[1, 4, 2, 5, 0][0, 4, 2, 5, 1][0, 2, 4, 5, 1][0, 1, 4, 5, 2][0, 1, 2, 5, 4][0, 1, 2, 4, 5] 验证后我们可以看到，结果和上面分析的结果是一样的。 各位读者也可以自己设置原数组，然后在运行代码之前按照自己的理解，把每一次交换的结果写出来，接着和运行算法之后进行对比。该方法对算法的理解很有帮助，推荐大家使用~ 请务必理解好上面的逻辑，可以通过动笔写结果的方式来帮助理解和巩固，有助于对下面讲解的排序算法的理解。 大家看上面的交换过程（排序过程）有没有什么问题？相信细致的读者已经看出来了：在原数组中，1和2都是比较靠前的位置，但是经过中间的排序以后，被放在了数组后方，然后再次又交换回来。这显然是比较低效的，给人的感觉像是做了无用功。 那么有没有什么方法可以优化一下交换的过程，让交换后的结果与元素最终在数组的位置基本保持一致呢？ 答案是肯定的，这就引出了笔者要第一个正式介绍的排序算法冒泡排序： 冒泡排序算法讲解与上面讲的交换排序类似的是，冒泡排序也是用两层的循环来实现的；但与其不同的是： 循环的边界条件：冒泡排序的外层是[0,array.count-1);内层是[0,array.count-1-i)。可以看到内层的范围是不断缩小的，而且范围的前端不变，后端在向前移。 交换排序比较的是内外层索引的元素（array[i] 和 array[j]）,但是冒泡排序比较的是两个相邻的内层索引的元素：array[j]和array[j+1]。 笔者用和上面交换排序使用的同一个数组来演示下元素是如何交换的： 初始数组：array = [4, 1, 2, 5, 0] i = 0 时： array[0] &gt; array[1] : 交换4和1：[1, 4, 2, 5, 0]，内层的j继续遍历，j++。 array[1] &gt; array[2] : 交换4和2：[1, 2, 4, 5, 0]，内层的j继续遍历，j++。 array[2] &lt; array[3] : 不交换，内层的j继续遍历，j++。 array[3] &gt; array[4] : 交换5和0：[1, 2, 4, 0, 5]，i = 0的外层循环结束，i++。 i = 1时： array[2] &gt; array[3] : 交换2和4：[1, 2, 0, 4, 5]，内层的j继续遍历，j++。 array[3] &lt; array[4] : 不交换，i = 1的外层循环结束，i++。 i = 2 时： array[1] &gt; array[2] : 交换2和0：[1, 0, 2, 4, 5]，内层的j继续遍历，j++，直到退出i=2的外层循环，i++。 i = 3 时： array[0] &gt; array[1] : 交换1和0：[0, 1, 2, 4, 5]，内层的j继续遍历，j++，直到退出i=3的外层循环，i++。 i = 4 时：不符合外层循环的边界条件，不进行外层循环，排序结束。 代码实现我们来看一下冒泡排序的代码： 123456789101112131415func bubbleSort(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; for i in 0 ..&lt; array.count - 1 &#123; for j in 0 ..&lt; array.count - 1 - i &#123; if array[j] &gt; array[j+1] &#123; array.swapAt(j, j+1) &#125; &#125; &#125; return array&#125; 从上面的代码我们可以清楚地看到循环遍历的边界条件和交换时机。同样地，我们添加上log，将冒泡排序每次交换后的数组打印出来（为了进行对比，笔者将交换排序的log也打印了出来）： 123456789101112131415161718original array:[4, 1, 2, 5, 0]switch sort...[1, 4, 2, 5, 0][0, 4, 2, 5, 1][0, 2, 4, 5, 1][0, 1, 4, 5, 2][0, 1, 2, 5, 4][0, 1, 2, 4, 5]bubble sort...[1, 4, 2, 5, 0][1, 2, 4, 5, 0][1, 2, 4, 0, 5][1, 2, 0, 4, 5][1, 0, 2, 4, 5][0, 1, 2, 4, 5] 从上面两组打印可以看出，冒泡排序算法解决了交换排序算法的不足： 原来就处于靠前位置的1，2两个元素，在排序的过程中一直是靠前的。 原来处于末尾的0元素，在冒泡排序的过程中一点一点地向前移动，最终到了应该处于的位置。 现在我们知道冒泡排序是好于交换排序的，而且它的做法是相邻元素的两两比较：如果是逆序（左大右小）的话就做交换。 那么如果在排序过程中，数组已经变成有序的了，那么再进行两两比较就很不划算了。 为了证实上面这个排序算法的局限性，我们用新的测试用例来看一下： 1var originalArray = [2,1,3,4,5] 而且这次我们不仅仅在交换以后打log，也记录一下作比较的次数： 123456789101112131415161718192021func bubbleSort(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; var compareCount = 0 for i in 0 ..&lt; array.count - 1 &#123; for j in 0 ..&lt; array.count - 1 - i &#123; compareCount += 1 print("No.\(compareCount) compare \(array[j]) and \(array[j+1])") if array[j] &gt; array[j+1] &#123; array.swapAt(j, j+1) //keeping index of j is the smaller one print("after swap: \(array)") &#125; &#125; &#125; return array&#125; 打印结果： 12345678910111213141516original array:[2, 1, 3, 4, 5]bubble sort...No.1 compare 2 and 1after swap: [1, 2, 3, 4, 5] //already sorted, but keep comparingNo.2 compare 2 and 3No.3 compare 3 and 4No.4 compare 4 and 5No.5 compare 1 and 2No.6 compare 2 and 3No.7 compare 3 and 4No.8 compare 1 and 2No.9 compare 2 and 3No.10 compare 1 and 2` 从打印的结果可以看出，其实在第一次交换过之后，数组已经是有序的了，但是该算法还是继续在比较，做了很多无用功，能不能有个办法可以让这种两两比较在已知有序的情况下提前结束呢？答案是肯定的。 提前结束这个操作很容易，我们只需要跳出最外层的循环就好了。关键是这个时机：我们需要让算法自己知道什么时候数组已经是有序的了。 是否已经想到了呢？就是在一次内循环过后，如果没有发生元素交换，就说明数组已经是有序的，不需要再次缩小内循环的范围继续比较了。所以我们需要在外部设置一个布尔值的变量来标记“该数组是否有序”： 我们将这个算法称为：advanced bubble sort 12345678910111213141516171819202122232425func bubbleSortAdvanced(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; for i in 0 ..&lt; array.count - 1 &#123; //bool switch var swapped = false for j in 0 ..&lt; array.count - i - 1 &#123; if array[j] &gt; array [j+1] &#123; array.swapAt(j, j+1) swapped = true; &#125; &#125; //if there is no swapping in inner loop, it means the the part looped is already sorted, //so it's time to break if (swapped == false)&#123; break &#125; &#125; return array &#125; 从上面的代码可以看出，在第一个冒泡排序的算法之内，只添加了一个swapped这个布尔值，默认为false： 如果在当前内循环里面没有发生过元素交换，则说明当前内循环范围的元素都是有序的；那么就说明后续的内循环范围的元素也是有序的（因为内循环每次迭代后都会缩小），就可以跳出循环了。 反之，如果在当前内循环里发生过元素交换，则说明当前内循环很可能是无序的（也可能是有序的，但是有序性需要在下一个内循环中验证，所以还是不能提前退出，还需要进行一次内循环）。 为了验证上面这个改进冒泡排序是否能解决最初给出的冒泡排序的问题，我们添加上对比次数的log： 123456789101112131415161718192021222324252627original array:[2, 1, 3, 4, 5]bubble sort...No.1 compare 2 and 1after swap: [1, 2, 3, 4, 5]No.2 compare 2 and 3No.3 compare 3 and 4No.4 compare 4 and 5No.5 compare 1 and 2No.6 compare 2 and 3No.7 compare 3 and 4No.8 compare 1 and 2No.9 compare 2 and 3No.10 compare 1 and 2bubble sort time duration : 1.96msadvanced bubble sort...No.1 compare 2 and 1after swap: [1, 2, 3, 4, 5]No.2 compare 2 and 3No.3 compare 3 and 4No.4 compare 4 and 5No.5 compare 1 and 2No.6 compare 2 and 3No.7 compare 3 and 4 我们可以看到，在使用改进的冒泡排序后，对比的次数少了3次。之所以没有立即返回，是因为即使在交换完变成有序数组以后，也无法在当前内循环判断出是有序的。需要在下次内循环才能验证出来。 因为数组的元素数量比较小，所以可能对这个改进所达到的效果体会得不是很明显。现在我们增加一下数组元素的个数，并用记录比较总和的方式来看一下二者的区别： 123456789original array:[2, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]bubble sort...total compare count： 91advanced bubble sort...total compare count： 25 从比较结果可以看出，这两种算法在该测试样本下的差距是比较大的，而且随着元素个数的增多这个差距会越来越大（因为做了更多没有意义的比较）。 虽然这种测试样本比较极端，但是在某种意义上还是优化了最初的冒泡排序算法。一般在网上的冒泡排序算法应该都能看到这个优化版的。 现在我们知道这个优化版的冒泡排序算法可以在知道当前数组已经有序的时候提前结束，但是毕竟不断的交换还是比较耗费性能的，有没有什么方法可以只移动一次就能做好当前元素的排序呢？答案又是肯定的，这就引出了笔者即将介绍的选择排序算法。 选择排序算法讲解选择排序也是两层循环： 外层循环的边界是[0,array.count-1)，index为i。 内层循环的边界是[i+1,array.count)，index为j。可以看到内层的范围也是不断缩小的，而且范围的前端一直后移，后端保持不变。 具体做法是： 在外层循环的开始，将i作为最小值index（很可能不是该数组的最小值）。 在内层循环里面找到当前内层循环范围内的最小值，并与已经记录的最小值作比较： 如果与当前记录的最小值index不同，则替换 如果与当前记录的最小值index相同，则不替换 我们还是用手写迭代的方式看一下选择排序的机制，使用的数组和上面交换排序和冒泡排序（非优化版）的数组一致：[4, 1, 2, 5, 0] i = 0 时： 记录当前的最小值的index为0，当前最小值为4。 内层循环开始，找到[1,5)之间的最小值为0，0的index为4，与当前最小值的index0不同，所以二者要做交换。交换后的数组：[0, 1, 2, 5, 4]。当前内层循环结束，i++。 i = 1 时： 记录当前的最小值的index为1，当前最小值为1。 内层循环开始，找到[2,5)之间的最小值为1，与当前记录的最小值index相同。也就是说后面没有比1还要小的了，不做交换。当前内层循环结束，i++。 i = 2 时： 记录当前的最小值的index为2，当前最小值为2。 内层循环开始，找到[3,5)之间的最小值为2，与当前记录的最小值index相同。也就是说后面没有比1还要小的了，不做交换。当前内层循环结束，i++。 i = 3 时： 记录当前的最小值的index为3，当前最小值为2。 内层循环开始，找到[4,5)之间的最小值为4，4的index为4，与当前记录的最小值index3不同，所以二者要做交换。交换后的数组：[0, 1, 2, 4, 5]。当前内层循环结束，i++。 i = 4 时：不符合外层循环的边界条件，不进行外层循环，排序结束。 我们可以看到，同样的初始序列，使用选择排序只进行了2次交换，因为它知道需要替换的最小值是什么，做了很少没意义的交换。 代码实现我们用代码来实现一下上面选择排序的算法： 1234567891011121314151617181920212223func selectionSort(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; for i in 0 ..&lt; array.count - 1&#123; var min = i for j in i + 1 ..&lt; array.count &#123; if array[j] &lt; array[min] &#123; min = j &#125; &#125; //if min has changed, it means there is value smaller than array[min] //if min has not changed, it means there is no value smallter than array[min] if i != min &#123; array.swapAt(i, min) &#125; &#125; return array&#125; 从上面的代码可以看到，在这里使用了min这个变量记录了当前外层循环所需要被比较的index值，如果当前外层循环的内层循环内部找到了比这个最小值还小的值，就替换他们。 下面我们使用log来看一下此时选择排序作替换的次数： 1234567891011121314original array:[4, 1, 2, 5, 0]advanced bubble sort...after swap: [1, 4, 2, 5, 0]after swap: [1, 2, 4, 5, 0]after swap: [1, 2, 4, 0, 5]after swap: [1, 2, 0, 4, 5]after swap: [1, 0, 2, 4, 5]after swap: [0, 1, 2, 4, 5]selection sort...after swap: [0, 1, 2, 5, 4]after swap: [0, 1, 2, 4, 5] 从上面的log可以看出二者的对比应该比较明显了。 为了进一步验证选择排序的性能，笔者在网上找到了两个工具： 计算程序运行时间的类：executionTimeInterval.swift 生成各种类型随机数的Array的分类：Array+Extension.swift 首先看executionTimeInterval.swift的实现： 1234567891011121314151617181920//time intervalpublic func executionTimeInterval(block: () -&gt; ()) -&gt; CFTimeInterval &#123; let start = CACurrentMediaTime() block(); let end = CACurrentMediaTime() return end - start&#125;//formatted timepublic extension CFTimeInterval &#123; public var formattedTime: String &#123; return self &gt;= 1000 ? String(Int(self)) + "s" : self &gt;= 1 ? String(format: "%.3gs", self) : self &gt;= 1e-3 ? String(format: "%.3gms", self * 1e3) : self &gt;= 1e-6 ? String(format: "%.3gµs", self * 1e6) : self &lt; 1e-9 ? "0s" : String(format: "%.3gns", self * 1e9) &#125;&#125; 第一个函数以block的形式传入需要测试运行时间的函数，返回了函数运行的时间。 第二个函数是CFTimeInterval的分类，将秒数添加了单位：毫秒级的以毫秒显示，微秒级的以微秒显示，大于1秒的以秒单位显示。 使用方法是：将两个swift文件拖进playground里面的Sources文件夹里，并点击二者后，进入playground内部： 123456var selectionSortedArray = [Int]()var time4 = executionTimeInterval&#123; selectionSortedArray = selectionSort(&amp;originalArray4) //要测试的函数&#125;print("selection sort time duration : \(time4.formattedTime)") //打印出时间 再来看一下Array+Extension.swift类： 先介绍其中的一个方法，生成随机数组： 1234567891011121314import Foundationextension Array &#123; static public func randomArray(size: Int, maxValue: UInt) -&gt; [Int] &#123; var result = [Int](repeating: 0, count:size) for i in 0 ..&lt; size &#123; result[i] = Int(arc4random_uniform(UInt32(maxValue))) &#125; return result &#125;&#125; 这个方法只需要传入数组的大小以及最大值就可以生成一个不超过这个最大值的随机数组。 比如我们要生成一个数组长度为10，最大值为100的数组： 12var originalArray = Array&lt;Int&gt;.randomArray(size: inputSize, maxValue:100)//originalArray:[87, 56, 54, 20, 86, 33, 41, 9, 88, 55] 那么现在有了上面两个工具，我们就可以按照我们自己的意愿来生成测试用例数组，并且打印出所用算法的执行时间。我们现在生成一个数组长度为10，最大值为100的数组，然后分别用优化的冒泡排序和选择排序来看一下二者的性能： 12345678original array:[1, 4, 80, 83, 92, 63, 83, 23, 9, 85]advanced bubble sort...advanced bubble sort result: [1, 4, 9, 23, 63, 80, 83, 83, 85, 92] time duration : 8.53msselection sort...selection sort result: [1, 4, 9, 23, 63, 80, 83, 83, 85, 92] time duration : 3.4ms 我们现在让数组长度更长一点:一个长度为100，最大值为200： 12345advanced bubble sort...advanced bubble sort sorted elemets: 100 time duration : 6.27sselection sort...selection sort sorted elemets: 100 time duration : 414ms 可以看到，二者的差别大概在12倍左右。这个差别已经很大了，如果说用选择排序需要1天的话，冒泡排序需要12天。 现在我们学习了选择排序，知道了它是通过减少交换次数来提高排序算法的性能的。 但是关于排序，除了交换操作以外，对比操作也是需要时间的：选择排序通过内层循环的不断对比才得到了当前内层循环的最小值，然后进行后续的判断和操作。 那么有什么办法可以减少对比的次数呢？猜对了，答案又是肯定的。这就引出了笔者下面要说的算法：插入排序算法。 插入排序算法讲解插入排序的基本思想是：从数组中拿出一个元素（通常就是第一个元素）以后，再从数组中按顺序拿出其他元素。如果拿出来的这个元素比这个元素小，就放在这个元素左侧；反之，则放在右侧。整体上看来有点和玩儿扑克牌的时候将刚拿好的牌来做排序差不多。 选择排序也是两层循环： 外层循环的边界是[1,array.count)，index为i。 内层循环开始的时候初始index j = i，然后使用一个while循环，循环条件是j&gt;0 &amp;&amp; array[j] &lt; array[j - 1],循环内侧是交换j-1和j的元素，并使得j-1。可以简单理解为如果当前的元素比前一个元素小，则调换位置；反之进行下一个外层循环。 下面我们还是用手写迭代的方式看一下插入排序的机制，使用的数组和上面选择排序的数组一致：[4, 1, 2, 5, 0] i = 1 时： j = 1：array[1] &lt; array[0]， 交换4和1：[1, 4, 2, 5, 0]，j-1之后不符合内层循环条件，退出内层循环，i+1。 i = 2 时： j = 2，array[3] &lt; array[2]，交换4和2：[1, 2, 4, 5, 0]，j向左移动，array[2] &gt; array[1]，不符合内层循环条件，退出内层循环，i+1。 i = 3 时： j = 3，array[3] &gt; array[2]，不符合内层循环条件，退出内层循环，i+1。 i = 4 时： j = 4，array[4] &lt; array[3]，交换5和0：[1, 2, 4, 0, 5]，j -1。 j = 3，array[3] &lt; array[2]，交换4和0：[1, 2, 0, 4, 5]，j -1。 j = 2，array[2] &lt; array[1]，交换4和0：[1, 0, 2, 4, 5]，j -1。 j = 1，array[1] &lt; array[0]，交换1和0：[0, 1, 2, 4, 5]，j -1 = 0，不符合内层循环条件，退出内层循环，i+1 = 5，不符合外层循环条件，排序终止。 从上面的描述可以看出，和选择排序相比，插入排序的内层循环是可以提前推出的，其条件就是array[j] &gt;= array[j - 1],也就是说，当前index为j的元素只要比前面的元素大，那么该内层循环就立即退出，不需要再排序了，因为该算法从一开始就是小的放前面，大的放后面。 代码实现下面我们通过代码来看一下如何实现插入排序算法: 1234567891011121314func insertionSort(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; for i in 1..&lt;array.count &#123; var j = i while j &gt; 0 &amp;&amp; array[j] &lt; array[j - 1] &#123; array.swapAt(j - 1, j) j -= 1 &#125; &#125; return array&#125; 从上面的代码可以看出插入排序内层循环的条件：j &gt; 0 &amp;&amp; array[j] &lt; array[j - 1]。只要当前元素比前面的元素小，就会一直交换下去；反之，当大于等于前面的元素，就会立即跳出循环。 之前笔者有提到相对于选择排序，说插入排序可以减少元素之间对比的次数，下面我们通过打印对比次数来对比一下两种算法： 使用元素个数为50，最大值为50的随机数组： 1234567selection sort...compare times:1225selection sort time duration : 178msinsertion sort...compare times:519insertion sort time duration : 676ms 我们可以看到，使用选择排序的比较次数比插入排序的比较次数多了2倍。但是遗憾的是整体的性能选择排序要高于插入排序。 也就是说虽然插入排序的比较次数少了，但是交换的次数却比选择排序要多，所以性能上有时可能不如选择排序。 注意，这不与笔者之前的意思相矛盾，笔者只是说在减少比较次数上插入排序是优于选择排序的，但没有说插入排序整体上优于选择排序。 那么有何种特性的数组可以让排序算法有其用武之地呢？ 从上面使用插入排序来排序[4, 1, 2, 5, 0]这个数组的时候，我们可以看到，因为0这个元素已经在末尾了，所以在j=4的时候我们费了好大劲才把它移到前面去。 那么将这个情况作为一个极端，我们可以这样想：如果这个数组里的元素里的index大致于最终顺序差不多的情况是不是就不用做这么多的搬移了？。这句话听起来像是理所当然的话，但是有一种数组属于“基本有序”的数组，这种数组也是无需的，但是它在整体上是有序的，比如： 1[2,1,3,6,4,5,9,7,8] 用笔者的话就叫做整体有序，部分无序。 我们可以简单用这个数组来分别进行选择排序和插入排序做个比较： 1234567selection sort...compare times:36selection sort time duration : 4.7msinsertion sort...compare times:5insertion sort time duration : 3.2ms 我们可以看到插入排序在基本有序的测试用例下表现更好。为了让差距更明显，笔者在Array+Extension.swift文件里增加了一个生成基本有序随机数组的方法： 12345678910111213141516171819202122static public func nearlySortedArray(size: Int, gap:Int) -&gt; [Int] &#123; var result = [Int](repeating: 0, count:size) for i in 0 ..&lt; size &#123; result[i] = i &#125; let count : Int = size / gap var arr = [Int]() for i in 0 ..&lt; count &#123; arr.append(i*gap) &#125; for j in 0 ..&lt; arr.count &#123; let swapIndex = arr[j] result.swapAt(swapIndex,swapIndex+1) &#125; return result&#125; 该函数需要传入数组的长度以及需要打乱顺序的index的跨度，它的实现是这样子的： 首先生成一个完全有序的序列。 将数组长度除以跨度来得出需要交换的index的个数count。 根据这个count可以得出需要交换的index，把这些index放在一个新的arr里面 便利这个arr来取出index，将之前生成好的w安全有序的数组的index于index+1做交换。 举个例子，如果我们生成一个数组长度为12，跨度为3的基本有序的数组，就可以这么调用： 12var originalArray = Array&lt;Int&gt;.nearlySortedArray(size: 12, gap: 3)//[1, 0, 2, 4, 3, 5, 7, 6, 8, 10, 9, 11] 跨度为3，说明有12/3 = 4 - 1 = 3 个元素需要调换位置，序号分别为0，3，6，9。所以序号为0，1；3，4；6，7；9，10的元素被调换了位置，可以看到调换后的数组还是基本有序的。 现在我们可以用一个比较大的数组来验证了： 1var originalArray = Array&lt;Int&gt;.nearlySortedArray(size: 100, gap: 10) 结果为： 1234567selection sort...compare times:4950selection sort time duration : 422msinsertion sort...compare times:10insertion sort time duration : 56.4ms 我们可以看到差距是非常明显的，插入排序的性能是选择排序的性能的近乎10倍 归并排序算法讲解归并排序使用了算法思想里的分治思想（divide conquer）。顾名思义，就是将一个大问题，分成类似的小问题来逐个攻破。在归并排序的算法实现上，首先逐步将要排序的数组等分成最小的组成部分（通常是1各元素），然后再反过来逐步合并。 用一张图来体会一下归并算法的实现过程： 上图面的虚线箭头代表拆分的过程；实线代表合并的过程。仔细看可以发现，拆分和归并的操作都是重复进行的，在这里面我们可以使用递归来操作。 首先看一下归并的操作： 归并的操作就是把两个数组（在这里这两个数组的元素个数通常是一致的）合并成一个完全有序数组。 归并操作的实现步骤是： 新建一个空数组，该数组用于存放合并后的有序数组。 两个传入的数组从index 0 开始两两比较，较小的元素放在新建的空数组中，index + 1; 较大的元素不作操作，index 不变，然后继续两两比较。知道index移到末尾为止。 个别情况当两个数组长度不一致的情况下需要将数组里剩余的元素放在新建的数组中。 代码实现我们来看一下归并排序算法的代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546func _merge(leftPile: [Int], rightPile: [Int]) -&gt; [Int] &#123; var leftIndex = 0 //left pile index, start from 0 var rightIndex = 0 //right pile index, start from 0 var sortedPile = [Int]() //sorted pile, empty in the first place while leftIndex &lt; leftPile.count &amp;&amp; rightIndex &lt; rightPile.count &#123; //append the smaller value into sortedPile if leftPile[leftIndex] &lt; rightPile[rightIndex] &#123; sortedPile.append(leftPile[leftIndex]) leftIndex += 1 &#125; else if leftPile[leftIndex] &gt; rightPile[rightIndex] &#123; sortedPile.append(rightPile[rightIndex]) rightIndex += 1 &#125; else &#123; //same value, append both of them and move the corresponding index sortedPile.append(leftPile[leftIndex]) leftIndex += 1 sortedPile.append(rightPile[rightIndex]) rightIndex += 1 &#125; &#125; //left pile is not empty while leftIndex &lt; leftPile.count &#123; sortedPile.append(leftPile[leftIndex]) leftIndex += 1 &#125; //right pile is not empty while rightIndex &lt; rightPile.count &#123; sortedPile.append(rightPile[rightIndex]) rightIndex += 1 &#125; return sortedPile&#125; 因为该函数是归并排序函数内部调用的函数，所以在函数名称的前面添加了下划线。仅仅是为了区分，并不是必须的。 从上面代码可以看出合并的实现逻辑： 新建空数组，初始化两个传入数组的index为0 两两比较两个数组index上的值，较小的放在新建数组里面并且index+1。 最后检查是否有剩余元素，如果有则添加到新建数组里面。 理解了合并的算法，下面我们看一下拆分的算法。拆分算法使用了递归： 12345678910func mergeSort(_ array: [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; let middleIndex = array.count / 2 let leftArray = mergeSort(Array(array[0..&lt;middleIndex])) // recursively split left part of original array let rightArray = mergeSort(Array(array[middleIndex..&lt;array.count])) // recursively split right part of original array return _merge(leftPile: leftArray, rightPile: rightArray) // merge left part and right part&#125; 我们可以看到mergeSort调用了自身，它的递归终止条件是!(array.count &gt;1)，也就是说当数组元素个数 = 1的时候就会返回，会触发调用栈的出栈。 从这个递归函数的实现可以看到它的作用是不断以中心店拆分传入的数组。根据他的递归终止条件，当数组元素 &gt; 1的时候，拆分会继续进行。而下面的合并函数只有在递归终止，开始出栈的时候才开始真正执行。也就是说在拆分结束后才开始进行合并，这样符合了上面笔者介绍的归并算法的实现过程。 上段文字需要反复体会。 为了更形象体现出归并排序的实现过程，可以在合并函数(_merge)内部添加log来验证上面的说法： 123456789func _merge(leftPile: [Int], rightPile: [Int]) -&gt; [Int] &#123; print("\nmerge left pile:\(leftPile) | right pile:\(rightPile)") ... print("sorted pile：\(sortedPile)") return sortedPile&#125; 而且为了方便和上图作比较，初始数组可以取图中的[3, 5, 9, 2, 7, 4, 8, 0]。运行一下看看效果： 12345678910111213141516171819202122232425original array:[3, 5, 9, 2, 7, 4, 8, 0]merge sort...merge left pile:[3] | right pile:[5]sorted pile：[3, 5]merge left pile:[9] | right pile:[2]sorted pile：[2, 9]merge left pile:[3, 5] | right pile:[2, 9]sorted pile：[2, 3, 5, 9]merge left pile:[7] | right pile:[4]sorted pile：[4, 7]merge left pile:[8] | right pile:[0]sorted pile：[0, 8]merge left pile:[4, 7] | right pile:[0, 8]sorted pile：[0, 4, 7, 8]merge left pile:[2, 3, 5, 9] | right pile:[0, 4, 7, 8]sorted pile：[0, 2, 3, 4, 5, 7, 8, 9] 我们可以看到，拆分归并的操作是先处理原数组的左侧部分，然后处理原数组的右侧部分。这是为什么呢？ 我们来看下最初函数是怎么调用的： 最开始我们调用函数： 12345678910func mergeSort(_ array: [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; let middleIndex = array.count / 2 let leftArray = mergeSort(Array(array[0..&lt;middleIndex])) //1 let rightArray = mergeSort(Array(array[middleIndex..&lt;array.count])) //2 return _merge(leftPile: leftArray, rightPile: rightArray) //3&#125; 在//1这一行开始了递归，这个时候数组是原数组，元素个数是8，而调用mergeSort时原数组被拆分了一半，是4。而4&gt;1，不满足递归终止的条件，继续递归，直到符合了终止条件（[3]）,递归开始返回。以为此时最初被拆分的是数组的左半部分，所以左半部分的拆分会逐步合并，最终得到了[2,3,5,9]。 同理，再回到了最初被拆分的数组的右半部分（上面代码段中的//2），也是和左测一样的拆分和归并，得到了右侧部分的归并结果：[0,4,7,8。 而此时的递归调用栈只有一个mergeSort函数了，mergeSort会进行最终的合并（上面代码段中的//3），调用_merge函数，得到了最终的结果：[0, 2, 3, 4, 5, 7, 8, 9]。 关于归并排序的性能：由于使用了分治和递归并且利用了一些其他的内存空间，所以其性能是高于上述介绍的所有排序的，不过前提是初始元素量不小的情况下。 我们可以将选择排序和归并排序做个比较：初始数组为长度500，最大值为500的随机数组： 12345selection sort...selection sort time duration : 12.7smerge sort...merge sort time duration : 5.21s 可以看到归并排序的算法是优与选择排序的。 现在我们知道归并排序使用了分治思想而且使用了递归，能够高效地将数组排序。其实还有一个也是用分治思想和递归，但是却比归并排序还要优秀的算法 - 快速排序算法。 快速排序快速排序算法被称之为20世纪十大算法之一，也是各大公司面试比较喜欢考察的算法。 算法讲解快速排序的基本思想是：通过一趟排序将带排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。 上述文字摘自《大话数据结构》 它的实现步骤为： 从数列中挑出一个元素（挑选的算法可以是随机，也可以作其他的优化），称为”基准”（pivot）。 重新对数组进行排序：所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面，相同的放两边。 递归地进行分区操作，继续把小于基准值元素的子数列和大于基准值元素的子数列排序。 从上面的描述可以看出，分区操作是快速排序中的核心算法。下面笔者结合实例来描述一下分区操作的过程。 首先拿到初始的数组：[5,4,9,1,3,6,7,8,2] 选择5作为pivot。 从剩下部分的两端开始：左侧1的标记为low，最右侧2的标记为high。 先看j：2 &lt; 5 , 交换5和2，j不变 ：[2,4,9,1,3,6,7,8,5] ； 再看i：2 &lt; 5 , i ++ ；4 &lt; 5, i++；9 &gt; 5，交换 9 和 5，i不变[2,4,5,1,3,6,7,8,9]。 代码实现使用Swift的filter函数因为在Swift中有一个数组的filter函数可以找出数组中符合某范围的一些数值，所以笔者先介绍一个会用该函数的简单的快速排序的实现： 12345678910func quickSort0&lt;T: Comparable&gt;(_ array: [T]) -&gt; [T] &#123; guard array.count &gt; 1 else &#123; return array &#125; let pivot = array[array.count/2] let less = array.filter &#123; $0 &lt; pivot &#125; let greater = array.filter &#123; $0 &gt; pivot &#125; return quickSort0(less) + quickSort0(greater)&#125; 不难看出这里面使用了递归：选中pivot以后，将数组分成了两个部分，最后将它们合并在一起。虽然这里面使用了Swift里面内置的函数来找出符合这两个个部分的元素，但是读者可以通过这个例子更好地理解快速排序的实现方式。 使用取index = 0 的partition函数除了使用swift内置的filter函数，当然我们也可以自己实现分区的功能，通常使用的是自定义的partition函数。 123456789101112131415161718192021222324func _partition(_ array: inout [Int], low: Int, high: Int) -&gt; Int&#123; var low = low var high = high let pivotValue = array[low] while low &lt; high &#123; while low &lt; high &amp;&amp; array[high] &gt;= pivotValue &#123; high -= 1 &#125; array[low] = array[high] while low &lt; high &amp;&amp; array[low] &lt;= pivotValue &#123; low += 1 &#125; array[high] = array[low] &#125; array[low] = pivotValue return low&#125; 从代码实现可以看出，最初在这里选择的pivotValue是当前数组的第一个元素。 然后从数组的最右侧的index逐渐向左侧移动，如果值大于pivotValue，那么index-1；否则直接将high与low位置上的元素调换；同样左侧的index也是类似的操作。 该函数执行的最终效果就是将最初的array按照选定的pivotValue前后划分。 那么_partition如何使用呢？ 1234567891011func quickSort1(_ array: inout [Int], low: Int, high: Int)&#123; guard array.count &gt; 1 else &#123; return &#125; if low &lt; high &#123; let pivotIndex = _partition(&amp;array, low: low, high: high) quickSort1(&amp;array, low: low, high: pivotIndex - 1) quickSort1(&amp;array, low: pivotIndex + 1, high: high) &#125; &#125; 外层调用的quickSort1是一个递归函数，不断地进行分区操作，最终得到排好序的结果。 我们将上面实现的归并排序，使用swift内置函数的快速排序，以及自定义partition函数的快速排序的性能作对比： 123456merge sort...merge sort time duration : 4.85squick sort...quick sort0 time duration : 984ms //swift filter functionquick sort1 time duration : 2.64s //custom partition 上面的测试用例是选择随机数组的，我们看一下测试用例为元素个数一致的基本有序的数组试一下： 123456merge sort...merge sort time duration : 4.88squick sort...quick sort0 time duration : 921msquick sort1 time duration : 11.3s 虽然元素个数一致，但是性能却差了很多，是为什么呢？因为我们在分区的时候，pivot的index强制为第一个。那么如果这个第一个元素的值本来就非常小，那么就会造成分区不均的情况（前重后轻），而且由于是迭代操作，每次分区都会造成分区不均，导致性能直线下降。所以有一个相对合理的方案就是在选取pivot的index的时候随机选取。 使用随机选择pivotValue的partition函数实现方法肯简单，只需在分区函数里将pivotValue的index随机生成即可： 12345678910func _partitionRandom(_ array: inout [Int], low: Int, high: Int) -&gt; Int&#123; let x = UInt32(low) let y = UInt32(high) let pivotIndex = Int(arc4random() % (y - x)) + Int(x) let pivotValue = array[pivotIndex] ...&#125; 现在用一个数组长度和上面的测试用例一致的基本有序的数组来测试一下随机选取pivotValue的算法： 1234567merge sort...merge sort time duration : 4.73squick sort...quick sort0 time duration : 866msquick sort1 time duration : 15.1s //fixed pivote indexquick sort2 time duration : 4.28s //random pivote index 我们可以看到当随机抽取pivot的index的时候，其运行速度速度是上面方案的3倍。 现在我们知道了3种快速排序的实现，都是根据pivotValue将原数组一分为二。但是如果数组中有大量的重复的元素，而且pivotValue很有可能落在这些元素里，那么显然上面这些算法对于这些可能出现多次于pivotValue重复的情况没有单独做处理。而为了很好解决存在与pivot值相等的元素很多的数组的排序，使用三路排序算法会比较有效果。 三路快速排序三路快速排序将大于，等于，小于pivotValue的元素都区分开，我们看一下具体的实现。先看一下partition函数的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455func swap(_ arr: inout [Int], _ j: Int, _ k: Int) &#123; guard j != k else &#123; return; &#125; let temp = arr[j] arr[j] = arr[k] arr[k] = temp&#125;func quickSort3W(_ array: inout [Int], low: Int, high: Int) &#123; if high &lt;= low &#123; return &#125; var lt = low // arr[low+1...lt] &lt; v var gt = high + 1 // arr[gt...high] &gt; v var i = low + 1 // arr[lt+1...i) == v let pivoteIndex = low let pivoteValue = array[pivoteIndex] while i &lt; gt &#123; if array[i] &lt; pivoteValue &#123; swap(&amp;array, i, lt + 1) i += 1 lt += 1 &#125;else if pivoteValue &lt; array[i]&#123; swap(&amp;array, i, gt - 1) gt -= 1 &#125;else &#123; i += 1 &#125; &#125; swap(&amp;array, low, lt) quickSort3W(&amp;array, low: low, high: lt - 1) quickSort3W(&amp;array, low: gt, high: high) &#125;func quickSort3(_ array: inout [Int] )&#123; quickSort3W(&amp;array, low: 0, high: array.count - 1) &#125; 主要看quickSort3W方法，这里将数组分成了三个区间，分别是大于，等于，小于pivote的值，对有大量重复元素的数组做了比较好的处理。 我们生成一个元素数量为500，最大值为5的随机数组看一下这些快速排序算法的性能： 123quick sort1 time duration : 6.19s //fixed pivote indexquick sort2 time duration : 8.1s //random pivote indexquick sort3 time duration : 4.81s //quick sort 3 way 可以看到三路快速排序（quick sort 3 way）在处理大量重复元素的数组的表现最好。 对于三路快速排序，我们也可以使用Swift内置的filter函数来实现: 1234567891011func quicksort4(_ array: [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; let pivot = array[array.count/2] let less = array.filter &#123; $0 &lt; pivot &#125; let equal = array.filter &#123; $0 == pivot &#125; let greater = array.filter &#123; $0 &gt; pivot &#125; return quicksort4(less) + equal + quicksort4(greater)&#125; 以上，介绍完了快速排序在Swift中的5中实现方式。 最后的话总结本文讲解了算法的一些基本概念以及结合了Swift代码的实现讲解了冒泡排序，选择排序，插入排序，归并排序，快速排序。相信认真阅读本文的读者能对这些算法有进一步的了解。 关于算法学习的思考关于算法的学习，笔者有一些思考想分享出来，也有可能有不对的地方，但笔者觉得有必要在这里说出来，希望可以引发读者的思考： 上图的Question是指问题；Mind是指想法，或者解决问题的思路；Code是指代码实现。 在阅读资料或书籍的算法学习过程，往往是按照图中1，2，3这些实线的路径进行的： 路径1：给出一个既定的问题后，马上给出解题策略 路径2：给出一个既定的问题后，马上给出算法实现 路径3：给出一个算法实现后，马上告诉你这些实现代码的意思 这些路径在算法的学习中虽然也是必不可少的，但是很容易给人一个错觉，这个错觉就是“我已经学会了这个算法了”。但是，仅仅是通过这些路径，对于真正理解算法，和今后对算法的应用还是远远不够的，原因是： 今后遇到的问题，几乎不可能与现在学习的问题一模一样，所以应该知其所以然，将问题本身抽象出来，达到触类旁通，举一反三。 有了一个新想法，如果没有足够的代码实现经验，很难以非常合理的方式用代码将其实现出来。所以应该增强将想法转化为代码的能力。 上面所说的两点的第一点，对应的是上图的路径4：给定一个策略或是设计，要思考这个策略或是设计是解决什么样的问题的，这样也就理解了这个策略或是设计的意义在哪里；而第二点对应的是上图中的路径5：怎样根据一个给定的策略来正确地，合理地用代码地实现出来；而上图中的路径6，笔者觉得也很重要：给定一份解决问题的代码，是否可以想到它所对应的问题是什么。 综上所述，笔者认为对于算法的学习，需要经常反复在问题，策略以及代码之间反复思考，这样才能真正地达到学以致用。]]></content>
      <categories>
        <category>Data Structure &amp; Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构 & 算法 in Swift （一）：Swift基础和数据结构]]></title>
    <url>%2F2019%2F08%2F29%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%26%20%E7%AE%97%E6%B3%95%20in%20Swift%20%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ASwift%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[写在前面从本文标题中的序号可以看出，本文是一个连载的开篇。而且这个连载的标题是：数据结构 &amp; 算法 in Swift。从这个连载的标题中可以看出，笔者分享的是使用Swift语言来实现所学的的数据结构和算法的知识。这里面需要解释两点：第一：为什么学习数据结构和算法？学习通用性知识，突破技能瓶颈：笔者做iOS开发也有两年了，这期间通过从项目，第三方源码，相关应用类的编程书籍提高了些技术水平。而作为没学过数据结构和算法的非科班大军中的一员，这些知识始终是绕不过去的。因为对此类知识的掌握程度会对今后编程技能的提高有着无可估量的影响，所以就决定学习了。 第二：为什么用Swift语言来实现？ 选择哪个语言并不重要，重要的是数据结构和算法本身的理解：通过两个星期的学习，如今笔者已经可以使用Swift语言来实现几种数据结构和算法了，但我相信如果我使用C语言或者Objective-C语言的话会学得更快些，因为在实现的时候由于对该语言的不熟悉导致在实现过程中踩了不少坑。不过可以反过来思考：如果我可以使用Swift来实现这些，那么我今后用C，Objective-C，甚至是Java就容易多了，再加上我还顺便学习了Swift不是么？ 如今Swift的势头还在上涨：笔者已经观察到很多新的库，教学都使用了Swift语言。而且听说一些面试的朋友在面试过程中多少有问过Swift相关的知识，一些公司的新项目也有用Swift写了。 该系列的最佳受众是那些已经会Swift，但是对数据结构和算法还没有过多接触过的iOS开发者。其次是那些不会Swift也不会数据结构和算法的iOS开发者，毕竟Swift是大势所趋。 不过对于那些非iOS开发者来说也同样适合，因为还是那句话：重点不在于使用哪种语言，而是数据结构和算法本身。除了第一篇会讲解一些在这个系列文章会使用到的Swift基础语法以外，后续的文章我会逐渐弱化对Swift语言的讲解，将重点放在数据结构和算法这里。而且后续我还会不断增加其他语言的实现（Java语言是肯定要加的，其他的语言还待定）。 好了，背景介绍完了，现在正式开始： 作为该系列的开篇，本文分为两个部分： Swift语法基础：讲解一下后续连载中讲到的数据结构和算法所涉及到的Swift语法知识（并不是很全面，也不是很深入，但是在实现数据结构和算法这块应该是够了）。 数据结构：简单介绍数据结构和算法的相关概念，以及用Swift来实现几个简单的数据结构（链表，栈，队列） 注：该系列涉及到的Swift语法最低基于Swift4.0。 Swift 语法基础Swift语法基础从以下几点来展开： 循环语句 泛型 guard 函数 集合 循环语句循环条件的开闭区间Swift将循环的开闭区间做了语法上的简化： 闭区间：12345678for index in 1...5 &#123; print("index: \(index)")&#125;// index : 1// index : 2// index : 3// index : 4// index : 5 半开闭区间：1234567for index in 1..&lt;5 &#123; print("index: \(index)")&#125;// index : 1// index : 2// index : 3// index : 4 循环的升序与降序上面两个例子都是升序的（index从小到大），我们来看一下降序的写法： 1234567for index in (1..&lt;5).reversed() &#123; print("index: \(index)")&#125;// index : 4// index : 3// index : 2// index : 1 降序的应用可以在下篇的冒泡排序算法中可以看到。 泛型使用泛型可以定义一些可复用的函数或类型，Swift中的Array和Dictionary都是泛型的集合。 为了体现出泛型的意义，下面举一个例子来说明一下： 实现这样一个功能:将传入该函数的两个参数互换。 整型的交换： 12345func swapTwoInts(_ a: inout Int, _ b: inout Int) &#123; let tmp = a a = b b = tmp&#125; 字符串的交换： 12345func swapTwoStrings(_ a: inout String, _ b: inout String) &#123; let tmp = a a = b b = tmp&#125; 浮点型的交换： 12345func swapTwoDoubles(_ a: inout Double, _ b: inout Double) &#123; let tmp = a a = b b = tmp&#125; 上面这三种情况的实现部分其实都是一样的，但仅仅是因为传入类型的不一致，导致对于不同的类型还要定义一个新的函数。所以如果类型有很多的话，定义的新函数也会很多，这样显然是不够优雅的。 此类问题可以使用泛型来解决： 12345func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) &#123; let tmp = a a = b b = tmp&#125; 上面函数中的T是泛型的固定写法，可以理解为“所有类型”。这样一来，我们可以传入任何相同的类型来作交换了。 泛型还有其他比较强大的功能，由于在后续的数据结构和算法的讲解里面可能不会涉及到，所以在这里先不赘述了。有兴趣的朋友可以参考官方文档：Swift：Generics guard guard是 swift 2.0推出的新的判断语句的用法。 与if语句相同的是，guard也是基于一个表达式的布尔值去判断一段代码是否该被执行。与if语句不同的是，guard只有在条件不满足的时候才会执行这段代码。你可以把guard近似的看做是Assert，但是你可以优雅的退出而非崩溃 使用guard语法，可以先对每个条件逐一做检查，如果不符合条件判断就退出（或者进行其他某些操作）。这就会让人容易看出来什么条件会让这个函数退出（或者进行其他某些操作）。 可以用一个例子来分别使用if和guard来实现，体会二者的区别： 使用if-else1234567891011121314151617181920212223242526//money: holding moneny (用户持有的钱数)//price: product price (商品的价格)//capacity: bag capacity (用户用来装商品的袋子容量)//volume: product size (商品的大小)func buying1( money: Int , price: Int , capacity: Int , volume: Int)&#123; if money &gt;= price&#123; if capacity &gt;= volume&#123; print("Start buying...") print("\(money-price) money left after buying.") print("\(capacity-volume) capacity left after buying.") &#125;else&#123; print("No enough capacity") &#125; &#125;else&#123; print("No enough money") &#125;&#125; 从上面的逻辑可以看出，当同时满足： 用户的钱数&gt;商品价格 用户用来装商品的袋子容量&gt;商品的大小 这两个情况的时候，购买才会进行，其他所有情况都无法引发购买。 对于大多数习惯使用if-else的朋友来说，上面的代码立即起来并没有难度，但是相同的逻辑，我们看一下使用guard之后的效果： 使用guard12345678910111213141516func buying2( money: Int , price: Int , capacity: Int , volume: Int)&#123; guard money &gt;= price else&#123; print("No enough money") return &#125; guard capacity &gt;= volume else&#123; print("No enough capacity") return &#125; print("Start buying...") print("\(money-price) money after buying.") print("\(capacity-volume) capacity left after buying.")&#125; 从上面的实现可以看出： 使用guard以后，将money &lt; price和capacity &lt; volume 这两个情况首先排除掉并填上了相应的处理代码。 在两个guard下面才是真正正确逻辑后的处理代码。 因此通过两个guard判断的语句，我们知道该函数所处理的正确逻辑是什么，非常清晰。 函数因为后续的数据结构和算法的讲解是离不开函数的使用的，所以在这里简单介绍一下Swift中函数的使用。 无返回值的函数 有返回值的函数 省略函数的外部参数名 值传递和引用传递 无返回值的函数123456func log(message: String) &#123; print("log: \(message)!")&#125;log(message: "memory warning")// output: log: memory warning! 有返回值的函数1234567func logString(string: String) -&gt; String &#123; return "log: " + string&#125;let logStr = logString(string: "memory warning!")print("\(logStr)")// output: log: memory warning! 省略函数外部参数名通过在函数形参前面加上_,可以起到在调用时省略外部参数的作用： 123456func logMessage(_ message: String) &#123; print("log: \(message)!")&#125;logMessage("memory warning")// output: log: memory warning! 再来看一下两个参数的情况： 123456func addInt(_ a : Int ,_ b : Int)&#123; print("sum is \(a + b)")&#125;addInt(3, 4)//output : sum is 7 值传递和引用传递Swift中，struct是按值传递，class是按引用传递。数组和字典在Swift里是属于struct，所以需要如果在一个函数里要修改传入的数组，需要做特殊处理： 123456789101112var originalArr = [2,1,3]func removeLastInArray(_ array: inout [Int])&#123; array.removeLast()&#125;print("\n============ before removing: \(originalArr)")//[2, 1, 3]removeLastInArray(&amp;originalArr)print("============ after removing: \(originalArr)")//[2, 1] 在这里使用的inout关键字就是将传入的数组改为引用传递了。 集合Swift里的集合类型有：数组，集合，字典，下面来分别讲一下。 这三种类型都支持泛型，也就是说里面的元素可以是整数，字符串，浮点等等。 数组 Swift’s Array type is bridged to Foundation’s NSArray class. 可变数组与不可变数组12345// immutable arraylet immutableNumbers: [Int] = [1, 3, 5, 4, 4, 1]// mutable arrayvar mutableNumbers : [Int] = [2, 1, 5, 4, 1, 3] Swift中可以用let和var来分别声明可变和不可变数组：数组的添加删除等操作只能作用于可变数组。 数组的遍历123456789101112131415161718// iteration 1for value in mutableNumbers &#123; if let index = mutableNumbers.index(of: value) &#123; print("Index of \(value) is \(index)") &#125;&#125;// iteration 2mutableNumbers.forEach &#123; value in if let index = mutableNumbers.index(of: value) &#123; print("Index of \(value) is \(index)") &#125;&#125;// iteration 3for (index, value) in mutableNumbers.enumerated() &#123; print("Item \(index + 1): \(value)")&#125; 数组的操作1234567891011121314151617181920mutableNumbers.append(11)// Output: [2, 1, 5, 4, 1, 3, 11]mutableNumbers.insert(42, at: 4)// Output: [2, 1, 5, 4, 42, 1, 3, 11]mutableNumbers.swapAt(0, 1)// Output: [1, 2, 5, 4, 42, 1, 3, 11]mutableNumbers.remove(at: 1)// Output: [2, 5, 4, 42, 1, 3, 11]mutableNumbers.removeFirst()// Output: [5, 4, 42, 1, 3, 11]mutableNumbers.removeLast()// Output: [5, 4, 42, 1, 3]mutableNumbers.removeAll()//[] append函数的作用是在数组的末尾添加元素 swapAt函数的作用是交换在传入的两个index上的元素，该方法在下篇的排序算法中使用得非常频繁。 集合 Swift’s Set type is bridged to Foundation’s NSSet class. 集合的无序性，值的唯一性关于集合与数组的区别，除了数组有序，集合无序以外，数组内部的元素的数值可以不是唯一的；但是集合里元素的数值必须是唯一的，如果有重复的数值会算作是一个： 12345678//value in set is uniquelet onesSet: Set = [1, 1, 1, 1]print(onesSet)// Output: [1]let onesArray: Array = [1, 1, 1, 1]print(onesArray)// Output: [1, 1, 1, 1] 集合的遍历1234567891011121314151617let numbersSet: Set = [1, 2, 3, 4, 5]print(numbersSet)// Output: undefined order, e.g. [5, 2, 3, 1, 4]// iteration 1for value in numbersSet &#123; print(value)&#125;// output is in undefined order// iteration 2numbersSet.forEach &#123; value in print(value)&#125;// output is in undefined order 集合的操作123456789101112131415161718192021222324252627282930313233343536373839var mutableStringSet: Set = ["One", "Two", "Three"]let item = "Two"//containsif mutableStringSet.contains(item) &#123; print("\(item) found in the set")&#125; else &#123; print("\(item) not found in the set")&#125;//isEmptylet strings = Set&lt;String&gt;()if strings.isEmpty &#123; print("Set is empty")&#125;//countlet emptyStrings = Set&lt;String&gt;()if emptyStrings.count == 0 &#123; print("Set has no elements")&#125;//insertmutableStringSet.insert("Four")//remove 1mutableStringSet.remove("Three")//remove 2if let removedElement = mutableStringSet.remove("Six") &#123; print("\(removedElement) was removed from the Set")&#125; else &#123; print("Six is not found in the Set")&#125;//removeAll()mutableStringSet.removeAll()// [] 字典 A dictionary Key type must conform to the Hashable protocol, like a set’s value type. 字典的声明12345678//empty dictionaryvar dayOfWeek = Dictionary&lt;Int, String&gt;()var dayOfWeek2 = [Int: String]()//not empty dictionaryvar dayOfWeek3: [Int: String] = [0: "Sun", 1: "Mon", 2: "Tue"]print(dayOfWeek3)//output:[2: "Tue", 0: "Sun", 1: "Mon"] 可以看到字典的键值对也是无序的，它与声明时的顺序不一定一致。 字典的遍历1234567891011121314// iteration 1for (key, value) in dayOfWeek &#123; print("\(key): \(value)")&#125;// iteration 2for key in dayOfWeek.keys &#123; print(key)&#125;// iteration 3for value in dayOfWeek.values &#123; print(value)&#125; 字典的操作123456789101112131415161718192021222324252627282930313233343536// find valuedayOfWeek = [0: "Sun", 1: "Mon", 2: "Tue"]if let day = dayOfWeek[2] &#123; print(day)&#125;// addValue 1dayOfWeek[3] = "Wed"print(dayOfWeek)// Prints: [2: "Tue", 0: "Sun", 1: "Mon", 3: "Wed"]// updateValue 1dayOfWeek[2] = "Mardi"print(dayOfWeek)// Prints: [2: "Mardi", 0: "Sun", 1: "Mon", 3: "Wed"]// updateValue 2dayOfWeek.updateValue("Tue", forKey: 2)print(dayOfWeek)// Prints: [2: "Tue", 0: "Sun", 1: "Mon", 3: "Wed"]// removeValue 1dayOfWeek[1] = nilprint(dayOfWeek)// Prints: [2: "Tue", 0: "Sun", 3: "Wed"]// removeValue 2dayOfWeek.removeValue(forKey: 2)print(dayOfWeek)// Prints: [0: "Sun", 3: "Wed"]// removeAlldayOfWeek.removeAll()print(dayOfWeek)// Output: [:] 可以看到从字典里面删除某个键值对有两个方法： 使用removeValue方法并传入要删除的键值对里的键。 将字典取下标之后将nil赋给它。 数据结构这一部分内容主要是对连载的后续文章作铺垫，让大家对数据结构先有一个基本的认识，因此在概念上不会深入讲解。该部分由以下三点展开： 数据结构的基本概念 抽象数据类型 链表，栈和队列的实现 概念首先我们来看一下数据结构的概念： 数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。 由数据结构这个词汇的本身（数据的结构）以及它的概念可以看出，它的重点在于“结构”和“关系”。所以说，数据是何种数据并不重要，重要的是这些数据是如何联系起来的。 而这些联系，可以从两个维度来展开： 逻辑结构：指数据对象中元素之间的相互关系。 物理结构：指数据的逻辑结构在计算机中的存储形式。 可以看出，逻辑结构是抽象的联系，而物理结构是实际在计算机内存里的具体联系。那么它们自己又细分为哪些结构呢？ 逻辑结构： 集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。 线性结构：线性结构中的数据元素之间是一对一的关系。 树形结构：数据结构中的元素存在一对多的相互关系。 图形结构：数据结构中的元素存在多对多的相互关系。 物理结构： 顺序存储结构：把数据元素粗放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的（数组）。 链式存储结构：把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。 为了便于记忆，用思维导图总结一下上面所说的： 而通过结合这两个维度中的某个结构，可以定义出来一个实际的数据结构的实现： 比如线性表就是线性结构的一种实现： 顺序存储结构的线性表就是数组：它的内存分布是连续的，元素之间可以通过内存地址来做关联； 链式存储结构的线性表就是 链表 ：它的内存分布可以是不连续的，元素之间通过指针来做关联： 如果每个元素（在链表中称作节点）只持有指向后面节点的指针，那此链表就是单链表。 如果每个元素（在链表中称作节点）持有指向前后节点的两个指针，那此链表就是双链表。 为什么会有链表这么麻烦的东西？像数组这样，所有内存地址都是连续的不是很方便么？既生瑜何生亮呢？ 对于获取元素（节点）这一操作，使用数组这个数据结构确实非常方便：因为所有元素在内存中是连续的，所以只需要知道数组中第一个元素的地址以及要获取元素的index就能算出该index内存的地址，一步到位非常方便。 但是对于向数组中某个index中插入新的元素的操作恐怕就没有这么方便了：恰恰是因为数组中所有元素的内存是连续的，所以如果想在中间插入一个新的元素，那么这个位置后面的所有元素都要后移，显然是非常低效的。如果插在数组尾部还好，如果插在第一位的话成本就太高了。 而如果使用链表，只要把要插入到的index前后节点的指针赋给这个新的节点就可以了，不需要移动原有节点在内存中的位置。 关于链表的这种插入操作会在后面用代码的形式体现出来。 既然有这么多的数据结构，那么有没有一个标准的格式来将这些特定的数据结构（也可以说是数学模型）抽象出来呢？答案是肯定的，它就是我们下一节要讲的抽象数据类型。 抽象数据类型首先来看一下抽象数据类型的概念，摘自《大话数据结构》: 抽象数据类型（Abstract Data Type，ADT）：是指一个数学模型及定义在该模型上的一组操作。 需要注意的是：抽象数据类型的定义仅仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现没有关系。而且，抽象数据类型不仅仅指那些已经定义并实现的数据类型，还尅是计算机编程者自己定义的数据类型。 我们看一下数据类型的标准格式： 1234567891011121314151617ADT 抽象数据类型名Data 数据元素之间逻辑关系的定义 Operation 操作1 初始条件 操作结果描述 操作2 初始条件 操作结果描述 操作nendADT 其实看上去和面向对象编程里的类的定义相似： 可以把抽象数据类型的Data 和 类的成员变量联系起来。 可以把抽象数据类型的操作和类的函数联系起来。 简单来说，抽象数据类型描述了一个数据模型所使用的数据和数据之间的逻辑关系，以及它可以执行的一些操作。因此，如果知道了一个数学模型的抽象数据类型，那么在真正接触数学模型的实现（代码）之前，就可以对该数学模型能做的事情有一个大致的了解。 下一章笔者会介绍链表，栈和队列这三个数学模型，在讲解每个数学模型的实现之前都会给出它们各自的抽象数据类型，让读者可以先对当前数学模型有个大致的了解。 注意：书本文归纳的所有抽象数据类型是笔者自己根据网上资料和相关书籍而定下来的，所以严格来说它们并不是“最官方”的抽象数据类型。读者也可以参考网上的资料或是相关书籍，结合自己的思考来定义自己对着三个数据模型的抽象数据类型。 链表，栈和队列的实现通过上一节的介绍，我们知道了数据结构的概念以及分类，还知道了不同的数据结构在不同的场景下会发挥不同的优势，我们要根据实际的场景来选择合适的数据结构。 下面就来介绍几种在实际应用中使用的比较多的数学模型： 链表 栈 队列 链表（Linked list）说到链表就不得不提线性表这一数据结构，在介绍链表之前，首先看一下线性表的定义： 线性表：零个或多个数据元素的有限序列。 而根据物理结构的不同，线性表有两种具体的实现方式： 线性表的顺序存储结构：线性表的数据元素是被一段地址连续的存储单存储起来的。 线性表的链式存储结构: 线性表的数据元素是被用一组连续或不连续的存储单元存储起来的，这些元素通过指针来作为逻辑上的连接。 注：上面两个概念是笔者用自己的话总结出来的。 在这里，线性表的顺序存储结构的实现就是我们熟悉的数组；而线性表的链式存储结构的实现就是笔者即将要介绍的链表。 链表的定义相信对于读完上一节的朋友来说，应该对链表有一个比较清晰的认识了。关于链表的定义有很多不同的版本，笔者个人比较喜欢百度百科里的定义： 链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。 而且由于数据元素所持有的指针个数和链接特性可以将链表分为： 单向链表：单向链表的链接方向是单向的，其中每个结点都有指针成员变量指向列表中的下一个结点； 双向链表：双向链表的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点，它的链接方向是双向的。 循环链表：循环链表是另一种形式的链式存贮结构。它的特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。 笔者从中挑选出双向链表来进行讲解，它的难度适中，而且能够很好地让读者体会出链表的优势。 双向链表的抽象数据类型因为节点是链表的基本组成单元，所以想要实现链表，必须先要介绍链表的组成部分-节点。 节点： 1234567891011ADT 节点(node)Data value:持有的数据Operation init:初始化 previous:指向上一节点的指针 next:指向下一节点的指针 endADT 再来看一下链表的抽象数据类型： 1234567891011121314151617181920ADT 链表（linked list）Data linked list:持有的线性表Operation init:初始化 count:持有节点总个数 isEmpty:是否为空 first:头节点 last:尾节点 node:传入index返回节点 insert:插入node到指定index insertToHead:插入节点到表头 appendToTail:插入节点到表尾 removeAll:移除所有节点 remove:移除传入的节点 removeAt:移除传入index的节点 endADT 双向链表的实现节点1234567891011121314151617public class LinkedListNode&lt;T&gt; &#123; //value of a node var value: T //pointer to previous node weak var previous: LinkedListNode? //pointer to next node var next: LinkedListNode? //init public init(value: T) &#123; self.value = value &#125;&#125; 再来看一下链表的实现： 因为整个链表的插入，删除等操作比较多，整个链表的定义超过了200行代码，所以为了看着方便一点，在这里来分段说明一下。 首先看一下链表的成员变量: 成员变量12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class LinkedList&lt;T&gt; &#123; public typealias Node = LinkedListNode&lt;T&gt; //if empty public var isEmpty: Bool &#123; return head == nil &#125; //total count of nodes public var count: Int &#123; guard var node = head else &#123; return 0 &#125; var count = 1 while let next = node.next &#123; node = next count += 1 &#125; return count &#125; //pointer to the first node, private private var head: Node? //pointer to the first node, public public var first: Node? &#123; return head &#125; //pointer to the last node public var last: Node? &#123; guard var node = head else &#123; return nil &#125; //until node.next is nil while let next = node.next &#123; node = next &#125; return node &#125; ... &#125; 相信看上面的命名以及注释大家可以对链表的成员变量有个初步的理解，这里面需要说三点： typealias是用来重新为已经存在的类型命名的：这里用Node代替了LinkedListNode&lt;T&gt;（节点类型），降低了不少阅读代码的成本。 在获取count和last的实现，都先判断了head这个指针是否为nil，如果是则判定为空链表，自然也就不存在节点个数和最后的节点对象了。 同样地，也是在获取count和last的实现里，使用了while控制语句来判断node.next节点是否存在：如果存在，则继续+1或者继续往下寻找，直到node.next为nil时才停止。在这里我们可以看到链表的寻址方式：是通过头结点开始，以节点的.next指针来寻找下一个节点的。而且作为链表的尾节点，它的.next指针不指向任何对象，因为它本来就是链表的最后一项。 最下方的…代表即将在下面介绍的一些函数，这些函数都定义在的LinkedList这个class里面。 获取index上node1234567891011121314151617181920212223242526//get node of indexpublic func node(atIndex index: Int) -&gt; Node? &#123; if index == 0 &#123; //head node return head! &#125; else &#123; var node = head!.next guard index &lt; count else &#123; return nil; &#125; for _ in 1..&lt;index &#123; // go on finding by .next node = node?.next if node == nil &#123; break &#125; &#125; return node! &#125;&#125; 注意在这里返回的node是可以为nil的，而且在这里可以看出来，链表在寻找特定node的时候，是根据节点的.next指针来一个一个寻找的。这个与顺序存储结构的数组是不同的，在后面我会重点讲解一下这二者的不同。 插入节点12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//insert node to last indexpublic func appendToTail(value: T) &#123; let newNode = Node(value: value) if let lastNode = last &#123; //update last node: newNode becomes new last node; //the previous last node becomes the second-last node newNode.previous = lastNode lastNode.next = newNode &#125; else &#123; //blank linked list head = newNode &#125;&#125;//insert node to index 0public func insertToHead(value: T) &#123; let newHead = Node(value: value) if head == nil &#123; //blank linked list head = newHead &#125;else &#123; newHead.next = head head?.previous = newHead head = newHead &#125;&#125;//insert node in specific indexpublic func insert(_ node: Node, atIndex index: Int) &#123; if index &lt; 0 &#123; print("invalid input index") return &#125; let newNode = node if count == 0 &#123; head = newNode &#125;else &#123; if index == 0 &#123; newNode.next = head head?.previous = newNode head = newNode &#125; else &#123; if index &gt; count &#123; print("out of range") return &#125; let prev = self.node(atIndex: index-1) let next = prev?.next newNode.previous = prev newNode.next = prev?.next prev?.next = newNode next?.previous = newNode &#125; &#125;&#125; 链表的插入节点的操作分为三种，按照从上到下的顺序依次是： 在头部插入 在尾部插入 指定index插入 需要注意的是 在前两种插入函数中，需要先判断该链表是否是空的，如果是，则要将链表的该节点赋给链表的head指针。 在第三种插入函数中，还是先判断该链表是否是空的，如果是，则无论index是多少(只要不小于0)，都插在链表的头部。如果不是空的，再判断index是否为0，如果是，则直接插在头部；如果index不为0，则判断index是否大于count，如果是，则无法插入；如果不是，则获取插入位置的前后节点进行重连。 在这里判断链表为空链表后的处理是笔者自己加上去的，笔者在网上的资料里没有看到过。大家不必纠结于这种处理方式，毕竟链表操作的重点在于前后节点的重连。 移除节点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//removing all nodespublic func removeAll() &#123; head = nil&#125;//remove the last nodepublic func removeLast() -&gt; T? &#123; guard !isEmpty else &#123; return nil &#125; return remove(node: last!)&#125;//remove a node by it's refrencepublic func remove(node: Node) -&gt; T? &#123; guard head != nil else &#123; print("linked list is empty") return nil &#125; let prev = node.previous let next = node.next if let prev = prev &#123; prev.next = next &#125; else &#123; head = next &#125; next?.previous = prev node.previous = nil node.next = nil return node.value&#125;//remove a node by it's indexpublic func removeAt(_ index: Int) -&gt; T? &#123; guard head != nil else &#123; print("linked list is empty") return nil &#125; let node = self.node(atIndex: index) guard node != nil else &#123; return nil &#125; return remove(node: node!)&#125; 如果要移除链表上所有节点，只需要将head指针置空就可以了，因为它是所有节点的“源头”，是链表寻址的第一个节点。 在持有某个节点的指针的时候可以指定链表来移除这个节点（使用remove函数）。在这个函数内部，首先需要将该节点的前后节点对接，然后将该几点的前后指针置空。 当有要移除节点的指针但是知道该节点在链表中的index，可以使用removeAt函数。在这个函数内部，首先根据index来获取对应的node的指针，然后再调用remove函数删除这个node。 打印所有节点12345678910111213141516171819202122public func printAllNodes()&#123; guard head != nil else &#123; print("linked list is empty") return &#125; var node = head print("\nstart printing all nodes:") for index in 0..&lt;count &#123; if node == nil &#123; break &#125; print("[\(index)]\(node!.value)") node = node!.next &#125;&#125; 该函数只是为了方便调试，为了跟踪链表的状态而定义的，它并不存在于链表的模型里。 为了验证上面这些方法的有效性，我们来实例化一个链表后实际操作一下，读者可以结合注释来看一下每一步对应的结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879let list = LinkedList&lt;String&gt;()list.isEmpty // truelist.first // nillist.count // 0list.appendToTail(value: "Swift")list.isEmpty // falselist.first!.value // "Swift"list.last!.value // "Swift"list.count //1list.appendToTail(value:"is")list.first!.value // "Swift"list.last!.value // "is"list.count // 2list.appendToTail(value:"great")list.first!.value // "Swift"list.last!.value // "great"list.count // 3list.printAllNodes()//[0]Swift//[1]is//[2]Greatlist.node(atIndex: 0)?.value // Swiftlist.node(atIndex: 1)?.value // islist.node(atIndex: 2)?.value // greatlist.node(atIndex: 3)?.value // nillist.insert(LinkedListNode.init(value: "language"), atIndex: 1)list.printAllNodes()//[0]Swift//[1]language//[2]is//[3]greatlist.remove(node: list.first!)list.printAllNodes()//[0]language//[1]is//[2]greatlist.removeAt(1)list.printAllNodes()//[0]language//[1]greatlist.removeLast()list.printAllNodes()//[0]languagelist.insertToHead(value: "study")list.count // 2list.printAllNodes()//[0]study//[1]languagelist.removeAll()list.printAllNodes()//linked list is emptylist.insert(LinkedListNode.init(value: "new"), atIndex: 3)list.printAllNodes()//[0]newlist.insert(LinkedListNode.init(value: "new"), atIndex: 3) //out of rangelist.printAllNodes()//[0]newlist.insert(LinkedListNode.init(value: "new"), atIndex: 1)list.printAllNodes()//[0]new//[1]new 栈（Stack）栈的讲解从 栈的定义 栈的抽象数据类型 栈的实现 三个部分来展开。 栈的定义首先来看一下栈的定义： 栈是限定仅在表的尾部进行插入和删除操作的线性表。 从定义中可以看出，我们知道我们只能在栈的一端来操作栈： 允许插入和删除的一端成为栈顶 另一端成为栈底 用一张图来看一下栈的操作： 图源：《维基百科：Stack (abstract data type)》 从上图可以看出，最先压入栈里面的只能最后访问，也就是说，栈遵循后进先出（Last In First Out, LIFO）的原则。 栈的抽象数据类型1234567891011121314ADT 栈（Stack）Data linked list:持有的线性表Operation init:初始化 count:栈的元素个数 isEmpty:是否为空 push:入栈 pop:出栈 top:返回顶部元素 endADT 上面的operation可能不全，但是涵盖了栈的一些最基本的操作。那么基于这个抽象数据类型，我们来看一下如何使用Swift来实现它。 栈的实现笔者将数组（顺序存储）作为栈的线性表的实现，同时支持泛型。 123456789101112131415ADT 栈（Stack）Data linked list:持有的线性表Operation init:初始化 count:栈的元素个数 isEmpty:是否为空 push:入栈 pop:出栈 top:返回顶部元素 endADT上面的operation可能不全，但是涵盖了栈的一些最基本的操作。那么基于这个抽象数据类型，我们来看一下如何使用Swift来实现它。 栈的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public struct Stack&lt;T&gt; &#123; //array fileprivate var stackArray = [T]() //count public var count: Int &#123; return stackArray.count &#125; //is empty ? public var isEmpty: Bool &#123; return stackArray.isEmpty &#125; //top element public var top: T? &#123; if isEmpty&#123; return nil &#125;else &#123; return stackArray.last &#125; &#125; //push operation public mutating func push(_ element: T) &#123; stackArray.append(element) &#125; //pop operation public mutating func pop() -&gt; T? &#123; if isEmpty&#123; print("stack is empty") return nil &#125;else &#123; return stackArray.removeLast() &#125; &#125; //print all public mutating func printAllElements() &#123; guard count &gt; 0 else &#123; print("stack is empty") return &#125; print("\nprint all stack elemets:") for (index, value) in stackArray.enumerated() &#123; print("[\(index)]\(value)") &#125; &#125;&#125; fileprivate：是Swift3.0新增的访问控制，表示在定义的声明文件里可访问。它代替了过去意义上的private。而有了fileprivate以后，新的private则代表了真正的私有：在这个类或结构体的外部无法访问。 这里printAllElements方法也不属于抽象数据类型里的方法，也是为了方便调试，可以打印出所有的数据元素。 我们来实例化上面定义的栈实际操作一下： 1234567891011121314151617181920212223242526272829303132333435var stack = Stack.init(stackArray: [])stack.printAllElements() //stack is emptystack.isEmpty //truestack.push(2)stack.printAllElements()//[0]2stack.isEmpty //falsestack.top //2stack.push(3)stack.printAllElements()//[0]2//[1]3stack.isEmpty //falsestack.top //3stack.pop()stack.printAllElements()//[0]2stack.isEmpty //falsestack.top //2stack.pop()stack.printAllElements() //stack is emptystack.top //nilstack.isEmpty //truestack.pop() //stack is empty 队列（Queue）队列的讲解从 队列的定义 队列的抽象数据类型 队列的实现 三个部分来展开。 队列的定义 图源：《维基百科：FIFO (computing and electronics)》 队列的抽象数据类型1234567891011121314ADT 队列（Queue）Data linked list:持有的线性表Operation init:初始化 count:栈的元素个数 isEmpty:是否为空 front:获取队列头元素 enqueue:插入到队尾 dequeue:删除队列头元素并返回 endADT 和上面的栈的实现一致，队列的实现也使用数组来实现队列内部的线性表。 队列的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public struct Queue&lt;T&gt; &#123; //array fileprivate var queueArray = [T]() //count public var count: Int &#123; return queueArray.count &#125; //is empty? public var isEmpty: Bool &#123; return queueArray.isEmpty &#125; //front element public var front: T? &#123; if isEmpty &#123; print("queue is empty") return nil &#125; else &#123; return queueArray.first &#125; &#125; //add element public mutating func enqueue(_ element: T) &#123; queueArray.append(element) &#125; //remove element public mutating func dequeue() -&gt; T? &#123; if isEmpty &#123; print("queue is empty") return nil &#125; else &#123; return queueArray.removeFirst() &#125; &#125; //print all public mutating func printAllElements() &#123; guard count &gt; 0 else &#123; print("queue is empty") return &#125; print("\nprint all queue elemets:") for (index, value) in queueArray.enumerated() &#123; print("[\(index)]\(value)") &#125; &#125; &#125; 我们初始化一个队列后实际操作一下： 123456789101112131415161718192021222324252627282930313233343536373839404142var queue = Queue.init(queueArray: [])queue.printAllElements()//queue is emptyqueue.isEmpty //truequeue.count //0queue.enqueue(2)queue.printAllElements()queue.isEmpty //false//[0]2queue.enqueue(3)queue.printAllElements()//[0]2//[1]3queue.enqueue(4)queue.printAllElements()//[0]2//[1]3//[2]4queue.front //2queue.dequeue()queue.printAllElements()//[0]3//[1]4queue.front //3queue.dequeue()queue.printAllElements()//[0]4queue.front //4queue.dequeue()queue.printAllElements() //queue is emptyqueue.front //return nil, and print : queue is emptyqueue.isEmpty //truequeue.count//0]]></content>
      <categories>
        <category>Data Structure &amp; Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[代码规范]]></title>
    <url>%2F2019%2F08%2F28%2F%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[这篇规范一共分为三个部分： 核心原则：介绍了这篇代码规范所遵循的核心原则。 通用规范：不局限于iOS的通用性的代码规范（使用C语言和Swift语言）。 iOS规范：仅适用于iOS的代码规范（使用Objc语言）。 一. 核心原则原则一：代码应该简洁易懂，逻辑清晰因为软件是需要人来维护的。这个人在未来很可能不是你。所以首先是为人编写程序，其次才是计算机： 不要过分追求技巧，降低程序的可读性。 简洁的代码可以让bug无处藏身。要写出明显没有bug的代码，而不是没有明显bug的代码。 原则二：面向变化编程，而不是面向需求编程。需求是暂时的，只有变化才是永恒的。本次迭代不能仅仅为了当前的需求，写出扩展性强，易修改的程序才是负责任的做法，对自己负责，对公司负责。 原则三：先保证程序的正确性，防止过度工程过度工程（over-engineering）：在正确可用的代码写出之前就过度地考虑扩展，重用的问题，使得工程过度复杂。引用《王垠：编程的智慧》里的话： 先把眼前的问题解决掉，解决好，再考虑将来的扩展问题。 先写出可用的代码，反复推敲，再考虑是否需要重用的问题。 先写出可用，简单，明显没有bug的代码，再考虑测试的问题。 二. 通用规范关于大括号 控制语句(if,for,while,switch)中，大括号开始与行尾 函数中，大括号要开始于行首 推荐这样写： 12345678910//控制语句white(someCondition)&#123;&#125;//函数void function(param1,param2)&#123;&#125; 运算符 1. 运算符与变量之间的间隔1.1 一元运算符与变量之间没有空格：12345!bValue~iValue++iCount*strSource&amp;fSum 1.2 二元运算符与变量之间必须有空格1234fWidth = 5 + 5;fLength = fWidth * 2;fHeight = fWidth + fLength;for(int i = 0; i &lt; 10; i++) 2. 多个不同的运算符同时存在时应该使用括号来明确优先级在多个不同的运算符同时存在的时候应该合理使用括号，不要盲目依赖操作符优先级。因为有的时候不能保证阅读你代码的人就一定能了解你写的算式里面所有操作符的优先级。 来看一下这个算式：2 &lt;&lt; 2 + 1 * 3 - 4 这里的&lt;&lt;是移位操作直观上却很容易认为它的优先级很高，所以就把这个算式误认为：(2 &lt;&lt; 2) + 1 3 - 4但事实上，它的优先级是比加减法还要低的，所以该算式应该等同于：2 &lt;&lt; (2 + 1 3 - 4)。所以在以后写这种复杂一点的算式的时候，尽量多加一点括号，避免让其他人误解（甚至是自己）。 变量 1. 一个变量有且只有一个功能，尽量不要把一个变量用作多种用途2. 变量在使用前应初始化，防止未初始化的变量被引用3. 局部变量应该尽量接近使用它的地方推荐这样写： 123456789101112func someFunction() &#123; let index = ...; //Do something With index ... ... let count = ...; //Do something With count &#125; 不推荐这样写： 1234567891011func someFunction() &#123; let index = ...; let count = ...; //Do something With index ... ... //Do something With count&#125; if语句 1. 必须列出所有分支（穷举所有的情况），而且每个分支都必须给出明确的结果。推荐这样写： 123456var hintStr;if (count &lt; 3) &#123; hintStr = "Good";&#125; else &#123; hintStr = "";&#125; 不推荐这样写： 1234var hintStr;if (count &lt; 3) &#123; hintStr = "Good";&#125; 2. 不要使用过多的分支，要善于使用return来提前返回错误的情况推荐这样写： 123456- (void)someMethod &#123; if (!goodCondition) &#123; return; &#125; //Do something&#125; 不推荐这样写： 12345- (void)someMethod &#123; if (goodCondition) &#123; //Do something &#125;&#125; 比较典型的例子我在JSONModel里遇到过： 12345678910111213141516171819202122232425262728293031323334353637383940-(id)initWithDictionary:(NSDictionary*)dict error:(NSError)err&#123; //方法1. 参数为nil if (!dict) &#123; if (err) *err = [JSONModelError errorInputIsNil]; return nil; &#125; //方法2. 参数不是nil，但也不是字典 if (![dict isKindOfClass:[NSDictionary class]]) &#123; if (err) *err = [JSONModelError errorInvalidDataWithMessage:@"Attempt to initialize JSONModel object using initWithDictionary:error: but the dictionary parameter was not an 'NSDictionary'."]; return nil; &#125; //方法3. 初始化 self = [self init]; if (!self) &#123; //初始化失败 if (err) *err = [JSONModelError errorModelIsInvalid]; return nil; &#125; //方法4. 检查用户定义的模型里的属性集合是否大于传入的字典里的key集合（如果大于，则返回NO） if (![self __doesDictionary:dict matchModelWithKeyMapper:self.__keyMapper error:err]) &#123; return nil; &#125; //方法5. 核心方法：字典的key与模型的属性的映射 if (![self __importDictionary:dict withKeyMapper:self.__keyMapper validation:YES error:err]) &#123; return nil; &#125; //方法6. 可以重写[self validate:err]方法并返回NO，让用户自定义错误并阻拦model的返回 if (![self validate:err]) &#123; return nil; &#125; //方法7. 终于通过了！成功返回model return self;&#125; 可以看到，在这里，首先判断出各种错误的情况然后提前返回，把最正确的情况放到最后返回。 3. 条件表达式如果很长，则需要将他们提取出来赋给一个BOOL值推荐这样写： 123456let nameContainsSwift = sessionName.hasPrefix("Swift")let isCurrentYear = sessionDateCompontents.year == 2014let isSwiftSession = nameContainsSwift &amp;&amp; isCurrentYearif (isSwiftSession) &#123; // Do something&#125; 不推荐这样写： 123if ( sessionName.hasPrefix("Swift") &amp;&amp; (sessionDateCompontents.year == 2014) ) &#123; // Do something&#125; 4. 条件语句的判断应该是变量在左，常量在右推荐这样写： 12if ( count == 6) &#123;&#125; 或者 12if ( object == nil) &#123;&#125; 或者 12if ( !object ) &#123;&#125; 不推荐这样写： 12if ( 6 == count) &#123;&#125; 或者 12if ( nil == object ) &#123;&#125; 5. 每个分支的实现代码都必须被大括号包围推荐这样写： 12if ( nil == object ) &#123;&#125; 不推荐这样写： 12if (!error) return success; 或者 1if (!error) return success; 6. 条件过多，过长的时候应该换行推荐这样写： 123456if (condition1() &amp;&amp; condition2() &amp;&amp; condition3() &amp;&amp; condition4()) &#123; // Do something&#125; 不推荐这样写： 123if (condition1() &amp;&amp; condition2() &amp;&amp; condition3() &amp;&amp; condition4()) &#123; // Do something&#125; for语句 1. 不可在for循环内修改循环变量，防止for循环失去控制。1234for (int index = 0; index &lt; 10; index++)&#123; ... logicToChange(index)&#125; 2. 避免使用continue和break。continue和break所描述的是“什么时候不做什么”，所以为了读懂二者所在的代码，我们需要在头脑里将他们取反。 其实最好不要让这两个东西出现，因为我们的代码只要体现出“什么时候做什么”就好了，而且通过适当的方法，是可以将这两个东西消灭掉的： 2.1 如果出现了continue，只需要把continue的条件取反即可1234567var filteredProducts = Array&lt;String&gt;()for level in products &#123; if level.hasPrefix("bad") &#123; continue &#125; filteredProducts.append(level)&#125; 我们可以看到，通过判断字符串里是否含有“bad”这个prefix来过滤掉一些值。其实我们是可以通过取反，来避免使用continue的： 12345for level in products &#123; if !level.hasPrefix("bad") &#123; filteredProducts.append(level) &#125;&#125; 2.2 消除while里的break：将break的条件取反，并合并到主循环里在while里的block其实就相当于“不存在”，既然是不存在的东西就完全可以在最开始的条件语句中将其排除。 while里的break： 123456while (condition1) &#123; ... if (condition2) &#123; break; &#125;&#125; 取反并合并到主条件： 123while (condition1 &amp;&amp; !condition2) &#123; ...&#125; 2.3 在有返回值的方法里消除break：将break转换为return立即返回有些朋友喜欢这样做：在有返回值的方法里break之后，再返回某个值。其实完全可以在break的那一行直接返回。 12345678910func hasBadProductIn(products: Array&lt;String&gt;) -&gt; Bool &#123; var result = false for level in products &#123; if level.hasPrefix("bad") &#123; result = true &#125; &#125; return result&#125; 遇到错误条件直接返回： 12345678func hasBadProductIn(products: Array&lt;String&gt;) -&gt; Bool &#123; for level in products &#123; if level.hasPrefix("bad") &#123; return true &#125; &#125; return false&#125; 这样写的话不用特意声明一个变量来特意保存需要返回的值，看起来非常简洁，可读性高。 Switch语句 1. 每个分支都必须用大括号括起来推荐这样写： 123456789101112131415161718switch (integer) &#123; case 1: &#123; // ... &#125; break; case 2: &#123; // ... break; &#125; case 3: &#123; // ... break; &#125; default:&#123; // ... break; &#125;&#125; 2. 使用枚举类型时，不能有default分支， 除了使用枚举类型以外，都必须有default分支123456789101112131415RWTLeftMenuTopItemType menuType = RWTLeftMenuTopItemMain; switch (menuType) &#123; case RWTLeftMenuTopItemMain: &#123; // ... break; &#125; case RWTLeftMenuTopItemShows: &#123; // ... break; &#125; case RWTLeftMenuTopItemSchedule: &#123; // ... break; &#125;&#125; 在Switch语句使用枚举类型的时候，如果使用了default分支，在将来就无法通过编译器来检查新增的枚举类型了。 函数 1. 一个函数的长度必须限制在50行以内通常来说，在阅读一个函数的时候，如果视需要跨过很长的垂直距离会非常影响代码的阅读体验。如果需要来回滚动眼球或代码才能看全一个方法，就会很影响思维的连贯性，对阅读代码的速度造成比较大的影响。最好的情况是在不滚动眼球或代码的情况下一眼就能将该方法的全部代码映入眼帘。 2. 一个函数只做一件事（单一原则）每个函数的职责都应该划分的很明确（就像类一样）。 推荐这样写： 12dataConfiguration()viewConfiguration() 不推荐这样写： 12345void dataConfiguration()&#123; ... viewConfiguration()&#125; 3. 对于有返回值的函数（方法），每一个分支都必须有返回值推荐这样写： 12345678910int function()&#123; if(condition1)&#123; return count1 &#125;else if(condition2)&#123; return count2 &#125;else&#123; return defaultCount &#125; &#125; 不推荐这样写： 12345678int function()&#123; if(condition1)&#123; return count1 &#125;else if(condition2)&#123; return count2 &#125;&#125; 4. 对输入参数的正确性和有效性进行检查，参数错误立即返回推荐这样写： 123456789101112void function(param1,param2)&#123; if(param1 is unavailable)&#123; return; &#125; if(param2 is unavailable)&#123; return; &#125; //Do some right thing&#125; 5. 如果在不同的函数内部有相同的功能，应该把相同的功能抽取出来单独作为另一个函数原来的调用： 123456789void logic() &#123; a(); b()； if (logic1 condition) &#123; c(); &#125; else &#123; d(); &#125;&#125; 将a，b函数抽取出来作为单独的函数 1234567891011121314void basicConfig() &#123; a(); b();&#125; void logic1() &#123; basicConfig(); c();&#125;void logic2() &#123; basicConfig(); d();&#125; 6. 将函数内部比较复杂的逻辑提取出来作为单独的函数一个函数内的不清晰（逻辑判断比较多，行数较多）的那片代码，往往可以被提取出去，构成一个新的函数，然后在原来的地方调用它这样你就可以使用有意义的函数名来代替注释，增加程序的可读性。 举一个发送邮件的例子： 123456789openEmailSite();login();writeTitle(title);writeContent(content);writeReceiver(receiver);addAttachment(attachment);send(); 中间的部分稍微长一些，我们可以将它们提取出来： 1234567void writeEmail(title, content,receiver,attachment)&#123; writeTitle(title); writeContent(content); writeReceiver(receiver); addAttachment(attachment); &#125; 然后再看一下原来的代码： 1234openEmailSite();login();writeEmail(title, content,receiver,attachment)send(); 8. 避免使用全局变量，类成员（class member）来传递信息，尽量使用局部变量和参数。在一个类里面，经常会有传递某些变量的情况。而如果需要传递的变量是某个全局变量或者属性的时候，有些朋友不喜欢将它们作为参数，而是在方法内部就直接访问了： 12345678910111213class A &#123; var x; func updateX() &#123; ... x = ...; &#125; func printX() &#123; updateX(); print(x); &#125;&#125; 我们可以看到，在printX方法里面，updateX和print方法之间并没有值的传递，乍一看我们可能不知道x从哪里来的，导致程序的可读性降低了。 而如果你使用局部变量而不是类成员来传递信息，那么这两个函数就不需要依赖于某一个类，而且更加容易理解，不易出错： 123456789func updateX() -&gt; String&#123; x = ...; return x; &#125; func printX() &#123; String x = updateX(); print(x); &#125; 注释 优秀的代码大部分是可以自描述的，我们完全可以用程代码本身来表达它到底在干什么，而不需要注释的辅助。 但并不是说一定不能写注释，有以下三种情况比较适合写注释： 公共接口（注释要告诉阅读代码的人，当前类能实现什么功能）。 涉及到比较深层专业知识的代码（注释要体现出实现原理和思想）。 容易产生歧义的代码（但是严格来说，容易让人产生歧义的代码是不允许存在的）。 除了上述这三种情况，如果别人只能依靠注释才能读懂你的代码的时候，就要反思代码出现了什么问题。 最后，对于注释的内容，相对于“做了什么”，更应该说明“为什么这么做”。 Code Review 换行、注释、方法长度、代码重复等这些是通过机器检查出来的问题，是无需通过人来做的。 而且除了审查需求的实现的程度，bug是否无处藏身以外，更应该关注代码的设计。比如类与类之间的耦合程度，设计的可扩展性，复用性，是否可以将某些方法抽出来作为接口等等。 三. iOS规范变量 1. 变量名必须使用驼峰格式类，协议使用大驼峰： 12HomePageViewController.h&lt;HeaderViewDelegate&gt; 对象等局部变量使用小驼峰： 12NSString *personName = @"";NSUInteger totalCount = 0; 2. 变量的名称必须同时包含功能与类型123UIButton *addBtn //添加按钮UILabel *nameLbl //名字标签NSString *addressStr//地址字符串 3. 系统常用类作实例变量声明时加入后缀 类型 后缀 UIViewController VC UIView View UILabel Lbl UIButton Btn UIImage Img UIImageView ImagView NSArray Array NSMutableArray Marray NSDictionary Dict NSMutableDictionary Mdict NSString Str NSMutableString MStr NSSet Set NSMutableSet Mset 常量 1. 常量以相关类名作为前缀推荐这样写： 1static const NSTimeInterval ZOCSignInViewControllerFadeOutAnimationDuration = 0.4; 不推荐这样写： 1static const NSTimeInterval fadeOutTime = 0.4; 2. 建议使用类型常量，不建议使用#define预处理命令首先比较一下这两种声明常量的区别： 预处理命令：简单的文本替换，不包括类型信息，并且可被任意修改。 类型常量：包括类型信息，并且可以设置其使用范围，而且不可被修改。 使用预处理虽然能达到替换文本的目的，但是本身还是有局限性的： 不具备类型信息。 可以被任意修改。 3. 对外公开某个常量：如果我们需要发送通知，那么就需要在不同的地方拿到通知的“频道”字符串（通知的名称），那么显然这个字符串是不能被轻易更改，而且可以在不同的地方获取。这个时候就需要定义一个外界可见的字符串常量。 推荐这样写： 123456//头文件extern NSString *const ZOCCacheControllerDidClearCacheNotification;//实现文件static NSString * const ZOCCacheControllerDidClearCacheNotification = @"ZOCCacheControllerDidClearCacheNotification";static const CGFloat ZOCImageThumbnailHeight = 50.0f; 不推荐这样写： 12#define CompanyName @"Apple Inc." #define magicNumber 42 宏 1. 宏、常量名都要使用大写字母，用下划线‘_’分割单词。123#define URL_GAIN_QUOTE_LIST @"/v1/quote/list"#define URL_UPDATE_QUOTE_LIST @"/v1/quote/update"#define URL_LOGIN @"/v1/user/login” 2. 宏定义中如果包含表达式或变量，表达式和变量必须用小括号括起来。1#define MY_MIN(A, B) ((A)&gt;(B)?(B):(A)) CGRect函数 其实iOS内部已经提供了相应的获取CGRect各个部分的函数了，它们的可读性比较高，而且简短，推荐使用： 推荐这样写： 123456CGRect frame = self.view.frame; CGFloat x = CGRectGetMinX(frame); CGFloat y = CGRectGetMinY(frame); CGFloat width = CGRectGetWidth(frame); CGFloat height = CGRectGetHeight(frame); CGRect frame = CGRectMake(0.0, 0.0, width, height); 而不是 123456CGRect frame = self.view.frame; CGFloat x = frame.origin.x; CGFloat y = frame.origin.y; CGFloat width = frame.size.width; CGFloat height = frame.size.height; CGRect frame = (CGRect)&#123; .origin = CGPointZero, .size = frame.size &#125;; 范型 建议在定义NSArray和NSDictionary时使用泛型，可以保证程序的安全性： 12NSArray&lt;NSString *&gt; *testArr = [NSArray arrayWithObjects:@"Hello", @"world", nil];NSDictionary&lt;NSString *, NSNumber *&gt; *dic = @&#123;@"key":@(1), @"age":@(10)&#125;; Block 为常用的Block类型创建typedef 如果我们需要重复创建某种block（相同参数，返回值）的变量，我们就可以通过typedef来给某一种块定义属于它自己的新类型 例如： 1234int (^variableName)(BOOL flag, int value) =^(BOOL flag, int value)&#123; // Implementation return someInt;&#125; 这个Block有一个bool参数和一个int参数，并返回int类型。我们可以给它定义类型： 1int(^EOCSomeBlock)(BOOL flag, int value); 再次定义的时候，就可以通过简单的赋值来实现： 123EOCSomeBlock block = ^(BOOL flag, int value)&#123;// Implementation&#125;; 定义作为参数的Block： 1- (void)startWithCompletionHandler: (void(^)(NSData *data, NSError* error))completion; 这里的Block有一个NSData参数，一个NSError参数并没有返回值 12typedef void(^EOCCompletionHandler)(NSData *data, NSError* error);(void)startWithCompletionHandler:(EOCCompletionHandler)completion;” 通过typedef定义Block签名的好处是:如果要某种块增加参数，那么只修改定义签名的那行代码即可。 字面量语法 尽量使用字面量值来创建 NSString , NSDictionary , NSArray , NSNumber 这些不可变对象： 123NSArray *names = @[@"Brian", @"Matt", @"Chris", @"Alex", @"Steve", @"Paul"];NSDictionary *productManagers = @&#123;@"iPhone" : @"Kate", @"iPad" : @"Kamal", @"Mobile Web" : @"Bill"&#125;;NSNumber *shouldUseLiterals = @YES;NSNumber *buildingZIPCode = @10018; 不推荐这样写： 123NSArray *names = [NSArray arrayWithObjects:@"Brian", @"Matt", @"Chris", @"Alex", @"Steve", @"Paul", nil];NSDictionary *productManagers = [NSDictionary dictionaryWithObjectsAndKeys: @"Kate", @"iPhone", @"Kamal", @"iPad", @"Bill" ];NSNumber *shouldUseLiterals = [NSNumber numberWithBool:YES];NSNumber *buildingZIPCode = [NSNumber numberWithInteger:10018]; 属性 1. 属性的命名使用小驼峰推荐这样写： 1@property (nonatomic, readwrite, strong) UIButton *confirmButton; 2. 属性的关键字推荐按照 原子性，读写，内存管理的顺序排列推荐这样写： 123@property (nonatomic, readwrite, copy) NSString *name;@property (nonatomic, readonly, copy) NSString *gender;@property (nonatomic, readwrite, strong) UIView *headerView; 3. Block属性应该使用copy关键字推荐这样写： 12typedef void (^ErrorCodeBlock) (id errorCode,NSString *message);@property (nonatomic, readwrite, copy) ErrorCodeBlock errorBlock;//将block拷贝到堆中 4. 形容词性的BOOL属性的getter应该加上is前缀推荐这样写： 1@property (assign, getter=isEditable) BOOL editable; 5. 使用getter方法做懒加载实例化一个对象是需要耗费资源的，如果这个对象里的某个属性的实例化要调用很多配置和计算，就需要懒加载它，在使用它的前一刻对它进行实例化： 123456789- (NSDateFormatter *)dateFormatter &#123; if (!_dateFormatter) &#123; _dateFormatter = [[NSDateFormatter alloc] init]; NSLocale *enUSPOSIXLocale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"]; [_dateFormatter setLocale:enUSPOSIXLocale]; [_dateFormatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ss.SSS"]; &#125; return _dateFormatter;&#125; 但是也有对这种做法的争议：getter方法可能会产生某些副作用，例如如果它修改了全局变量，可能会产生难以排查的错误。 6. 除了init和dealloc方法，建议都使用点语法访问属性使用点语法的好处： setter： setter会遵守内存管理语义(strong, copy, weak)。 通过在内部设置断点，有助于调试bug。 可以过滤一些外部传入的值。 捕捉KVO通知。 getter： 允许子类化。 通过在内部设置断点，有助于调试bug。 实现懒加载（lazy initialization）。 注意： 懒加载的属性，必须通过点语法来读取数据。因为懒加载是通过重写getter方法来初始化实例变量的，如果不通过属性来读取该实例变量，那么这个实例变量就永远不会被初始化。 在init和dealloc方法里面使用点语法的后果是：因为没有绕过setter和getter，在setter和getter里面可能会有很多其他的操作。而且如果它的子类重载了它的setter和getter方法，那么就可能导致该子类调用其他的方法。 7. 不要滥用点语法，要区分好方法调用和属性访问推荐这样写： 12view.backgroundColor = [UIColor orangeColor]; [UIApplication sharedApplication].delegate; 不推荐这样写： 12[view setBackgroundColor:[UIColor orangeColor]]; UIApplication.sharedApplication.delegate; 8. 尽量使用不可变对象建议尽量把对外公布出来的属性设置为只读，在实现文件内部设为读写。具体做法是： 在头文件中，设置对象属性为 在实现文件中设置为readwrite。 这样一来，在外部就只能读取该数据，而不能修改它，使得这个类的实例所持有的数据更加安全。而且，对于集合类的对象，更应该仔细考虑是否可以将其设为可变的。 如果在公开部分只能设置其为只读属性，那么就在非公开部分存储一个可变型。所以当在外部获取这个属性时，获取的只是内部可变型的一个不可变版本,例如： 在公共API中： 12345678910@interface EOCPerson : NSObject@property (nonatomic, copy, readonly) NSString firstName;@property (nonatomic, copy, readonly) NSString lastName;@property (nonatomic, strong, readonly) NSSet *friends //向外公开的不可变集合(id)initWithFirstName:(NSString)firstName andLastName:(NSString)lastName;(void)addFriend:(EOCPerson*)person;(void)removeFriend:(EOCPerson*)person;@end 在这里，我们将friends属性设置为不可变的set。然后，提供了来增加和删除这个set里的元素的公共接口。 在实现文件里： 12345678910111213141516171819202122232425262728293031@interface EOCPerson ()@property (nonatomic, copy, readwrite) NSString *firstName;@property (nonatomic, copy, readwrite) NSString* lastName;@end@implementation EOCPerson &#123; NSMutableSet *_internalFriends; //实现文件里的可变集合&#125;- (NSSet*)friends &#123; return [_internalFriends copy]; //get方法返回的永远是可变set的不可变型&#125;- (void)addFriend:(EOCPerson*)person &#123; [_internalFriends addObject:person]; //在外部增加集合元素的操作 //do something when add element&#125;- (void)removeFriend:(EOCPerson*)person &#123; [_internalFriends removeObject:person]; //在外部移除元素的操作 //do something when remove element&#125;- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName &#123; if ((self = [super init])) &#123; ... &#125; return self;&#125; 我们可以看到，在实现文件里，保存一个可变set来记录外部的增删操作。 这里最重要的代码是： 123- (NSSet *)friends &#123; return [_internalFriends copy];&#125; 这个是friends属性的获取方法：它将当前保存的可变set复制了一不可变的set并返回。因此，外部读取到的set都将是不可变的版本。 方法 1. 方法名中不应使用and，而且签名要与对应的参数名保持高度一致推荐这样写： 1- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height; 不推荐这样写： 12- (instancetype)initWithWidth:(CGFloat)width andHeight:(CGFloat)height;- (instancetype)initWith:(int)width and:(int)height; 2. 方法实现时，如果参数过长，则令每个参数占用一行，以冒号对齐。123456- (void)doSomethingWith:(NSString *)theFoo rect:(CGRect)theRect interval:(CGFloat)theInterval&#123; //Implementation&#125; 3. 私有方法应该在实现文件中申明。12345678910@interface ViewController ()- (void)basicConfiguration;@end@implementation ViewController- (void)basicConfiguration&#123; //Do some basic configuration&#125;@end 4. 方法名用小写字母开头的单词组合而成1- (NSString *)descriptionWithLocale:(id)locale; 5. 方法名前缀 刷新视图的方法名要以refresh为首。 更新数据的方法名要以update为首。 推荐这样写： 12- (void)updateDataSourceWithViewModel:(ViewModel*)viewModel;- (void)updateDataSourceWithViewModel:(ViewModel*)viewModel; 面向协议编程 如果某些功能（方法）具备可复用性，我们就需要将它们抽取出来放入一个抽象接口文件中（在iOS中，抽象接口即协议），让不同类型的对象遵循这个协议，从而拥有相同的功能。 因为协议是不依赖于某个对象的，所以通过协议，我们可以解开两个对象之间的耦合。如何理解呢？我们来看一下下面这个例子： 现在有一个需求：在一个UITableViewController里面拉取feed并展示出来。 方案一：定义一个拉取feed的类ZOCFeedParser，这个类有一些代理方法实现feed相关功能： 12345678910111213141516@protocol ZOCFeedParserDelegate &lt;NSObject&gt;@optional- (void)feedParserDidStart:(ZOCFeedParser *)parser;- (void)feedParser:(ZOCFeedParser *)parser didParseFeedInfo:(ZOCFeedInfoDTO *)info; - (void)feedParser:(ZOCFeedParser *)parser didParseFeedItem:(ZOCFeedItemDTO *)item; - (void)feedParserDidFinish:(ZOCFeedParser *)parser;- (void)feedParser:(ZOCFeedParser *)parser didFailWithError:(NSError *)error;@end @interface ZOCFeedParser : NSObject@property (nonatomic, weak) id &lt;ZOCFeedParserDelegate&gt; delegate; @property (nonatomic, strong) NSURL *url; - (id)initWithURL:(NSURL *)url; - (BOOL)start; - (void)stop; @end 然后在ZOCTableViewController里面传入ZOCFeedParser，并遵循其代理方法，实现feed的拉取功能。 123@interface ZOCTableViewController : UITableViewController&lt;ZOCFeedParserDelegate&gt;- (instancetype)initWithFeedParser:(ZOCFeedParser *)feedParser; @end 具体应用： 1234NSURL *feedURL = [NSURL URLWithString:@"http://bbc.co.uk/feed.rss"]; ZOCFeedParser *feedParser = [[ZOCFeedParser alloc] initWithURL:feedURL]; ZOCTableViewController *tableViewController = [[ZOCTableViewController alloc] initWithFeedParser:feedParser]; feedParser.delegate = tableViewController; OK，现在我们实现了需求：在ZOCTableViewController里面存放了一个ZOCFeedParser对象来处理feed的拉取功能。 但这里有一个严重的耦合问题：ZOCTableViewController只能通过ZOCFeedParser对象来处理feed的拉取功能。于是我们重新审视一下这个需求：其实我们实际上只需要ZOCTableViewController拉取feed就可以了，而具体是由哪个对象来拉取，ZOCTableViewController并不需要关心。 也就是说，我们需要提供给ZOCTableViewController的是一个更范型的对象，这个对象具备了拉取feed的功能就好了，而不应该仅仅局限于某个具体的对象（ZOCFeedParser）。所以，刚才的设计需要重新做一次修改： 方案二：首先需要在一个接口文件ZOCFeedParserProtocol.h里面定义抽象的，具有拉取feed功能的协议： 12345678910111213141516@protocol ZOCFeedParserDelegate &lt;NSObject&gt;@optional- (void)feedParserDidStart:(id&lt;ZOCFeedParserProtocol&gt;)parser;- (void)feedParser:(id&lt;ZOCFeedParserProtocol&gt;)parser didParseFeedInfo:(ZOCFeedInfoDTO *)info; - (void)feedParser:(id&lt;ZOCFeedParserProtocol&gt;)parser didParseFeedItem:(ZOCFeedItemDTO *)item; - (void)feedParserDidFinish:(id&lt;ZOCFeedParserProtocol&gt;)parser;- (void)feedParser:(id&lt;ZOCFeedParserProtocol&gt;)parser didFailWithError:(NSError *)error;@end @protocol ZOCFeedParserProtocol &lt;NSObject&gt;@property (nonatomic, weak) id &lt;ZOCFeedParserDelegate&gt; delegate; @property (nonatomic, strong) NSURL *url;- (BOOL)start;- (void)stop;@end 而原来的ZOCFeedParser仅仅是需要遵循上面这个协议就具备了拉取feed的功能： 123@interface ZOCFeedParser : NSObject &lt;ZOCFeedParserProtocol&gt; - (id)initWithURL:(NSURL *)url;//仅仅需要通过传入url即可，其他事情都交给ZOCFeedParserProtocol@end 而且，ZOCTableViewController也不直接依赖于ZOCFeedParser对象，我们只需要传给它一个遵循&lt;ZOCFeedParserProtocol&gt;的对象即可。 123@interface ZOCTableViewController : UITableViewController &lt;ZOCFeedParserDelegate&gt;- (instancetype)initWithFeedParser:(id&lt;ZOCFeedParserProtocol&gt;)feedParser;@end 这样一来，ZOCTableViewController和ZOCFeedParser之间就没有直接的关系了。以后，如果我们想： 给这个feed拉取器增加新的功能：仅需要修改ZOCFeedParserProtocol.h文件。 更换一个feed拉取器实例：创建一个新类型来遵循ZOCFeedParserProtocol.h即可。 iOS 中委托的设计 1. 要区分好代理和数据源的区别在iOS开发中的委托模式包含了delegate（代理）和datasource（数据源）。虽然二者同属于委托模式，但是这两者是有区别的。这个区别就是二者的信息流方向是不同的： delegate ：事件发生的时候，委托者需要通知代理。（信息流从委托者到代理） datasource：委托者需要从数据源拉取数据。（信息流从数据源到委托者） 然而包括苹果也没有做好榜样，将它们彻底的区分开。就拿UITableView来说，在它的delegate方法中有一个方法： 1- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath; 这个方法正确地体现了代理的作用：委托者（tableview）告诉代理（控制器）“我的某个cell被点击了”。但是，UITableViewDelegate的方法列表里还有这个方法： 1- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath; 该方法的作用是 由控制器来告诉tabievlew的行高，也就是说，它的信息流是从控制器（数据源）到委托者（tableview）的。准确来讲，它应该是一个数据源方法，而不是代理方法。 在UITableViewDataSource中，就有标准的数据源方法： 1- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView; 这个方法的作用就是让tableview向控制器拉取一个section数量的数据。 所以，在我们设计一个视图控件的代理和数据源时，一定要区分好二者的区别，合理地划分哪些方法属于代理方法，哪些方法属于数据源方法。 2. 代理方法的第一个参数必须为委托者代理方法必须以委托者作为第一个参数（参考UITableViewDelegate）的方法。其目的是为了区分不同委托着的实例。因为同一个控制器是可以作为多个tableview的代理的。若要区分到底是哪个tableview的cell被点击了，就需要在 1- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath* )indexPath 方法中做个区分。 向代理发送消息时需要判断其是否实现该方法最后，在委托着向代理发送消息的时候，需要判断委托着是否实现了这个代理方法: 123if ([self.delegate respondsToSelector:@selector(signUpViewControllerDidPressSignUpButton:)]) &#123; [self.delegate signUpViewControllerDidPressSignUpButton:self];&#125; 3. 遵循代理过多的时候，换行对齐显示1234@interface ShopViewController () &lt;UIGestureRecognizerDelegate, HXSClickEventDelegate, UITableViewDelegate, UITableViewDataSource&gt; 4. 代理的方法需要明确必须执行和可不执行代理方法在默认情况下都是必须执行的，然而在设计一组代理方法的时候，有些方法可以不是必须执行（是因为存在默认配置），这些方法就需要使用@optional关键字来修饰： 12@protocol ZOCServiceDelegate &lt;NSObject&gt;@optional- (void)generalService:(ZOCGeneralService *)service didRetrieveEntries:(NSArray *)entries; @end 类 1. 类的名称应该以三个大写字母为前缀；创建子类的时候，应该把代表子类特点的部分放在前缀和父类名的中间推荐这样写： 123456//父类ZOCSalesListViewController//子类ZOCDaySalesListViewControllerZOCMonthSalesListViewController 2. initializer &amp;&amp; dealloc推荐： 将 dealloc 方法放在实现文件的最前面 将init方法放在dealloc方法后面。如果有多个初始化方法，应该将指定初始化方法放在最前面，其他初始化方法放在其后。 2.1 dealloc方法里面应该直接访问实例变量，不应该用点语法访问2.2 init方法的写法： init方法返回类型必须是instancetype，不能是id。 必须先实现[super init]。 1234567- (instancetype)init &#123; self = [super init]; // call the designated initializer if (self) &#123; // Custom initialization &#125; return self; &#125; 2.3 指定初始化方法指定初始化方法(designated initializer)是提供所有的（最多的）参数的初始化方法，间接初始化方法(secondary initializer)有一个或部分参数的初始化方法。 注意事项1：间接初始化方法必须调用指定初始化方法。 123456789101112131415161718192021222324252627@implementation ZOCEvent //指定初始化方法- (instancetype)initWithTitle:(NSString *)title date:(NSDate *)date location:(CLLocation *)location&#123; self = [super init]; if (self) &#123; _title = title; _date = date; _location = location; &#125; return self; &#125; //间接初始化方法- (instancetype)initWithTitle:(NSString *)title date:(NSDate *)date&#123; return [self initWithTitle:title date:date location:nil];&#125;//间接初始化方法- (instancetype)initWithTitle:(NSString *)title &#123; return [self initWithTitle:title date:[NSDate date] location:nil];&#125;@end 注意事项2：如果直接父类有指定初始化方法，则必须调用其指定初始化方法 123456- (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil &#123; self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil]; if (self) &#123; &#125; return self; &#125; 注意事项3：如果想在当前类自定义一个新的全能初始化方法，则需要如下几个步骤 定义新的指定初始化方法，并确保调用了直接父类的初始化方法。 重载直接父类的初始化方法，在内部调用新定义的指定初始化方法。 为新的指定初始化方法写文档。 看一个标准的例子： 12345678910111213141516@implementation ZOCNewsViewController//新的指定初始化方法- (id)initWithNews:(ZOCNews *)news &#123; self = [super initWithNibName:nil bundle:nil]; if (self) &#123; _news = news; &#125; return self;&#125; // 重载父类的初始化方法- (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil&#123; return [self initWithNews:nil]; &#125;@end 在这里，重载父类的初始化方法并在内部调用新定义的指定初始化方法的原因是你不能确定调用者调用的就一定是你定义的这个新的指定初始化方法，而不是原来从父类继承来的指定初始化方法。 假设你没有重载父类的指定初始化方法，而调用者却恰恰调用了父类的初始化方法。那么调用者可能永远都调用不到你自己定义的新指定初始化方法了。 而如果你成功定义了一个新的指定初始化方法并能保证调用者一定能调用它，你最好要在文档中明确写出哪一个才是你定义的新初始化方法。或者你也可以使用编译器指令__attribute__((objc_designated_initializer))来标记它。 3. 所有返回类对象和实例对象的方法都应该使用instancetype将instancetype关键字作为返回值的时候，可以让编译器进行类型检查，同时适用于子类的检查，这样就保证了返回类型的正确性（一定为当前的类对象或实例对象） 推荐这样写： 123@interface ZOCPerson+ (instancetype)personWithName:(NSString *)name; @end 不推荐这样写： 123@interface ZOCPerson+ (id)personWithName:(NSString *)name; @end 4. 在类的头文件中尽量少引用其他头文件有时，类A需要将类B的实例变量作为它公共API的属性。这个时候，我们不应该引入类B的头文件，而应该使用向前声明（forward declaring）使用class关键字，并且在A的实现文件引用B的头文件。 123456789101112131415// EOCPerson.h#import &lt;Foundation/Foundation.h&gt;@class EOCEmployer;@interface EOCPerson : NSObject@property (nonatomic, copy) NSString *firstName;@property (nonatomic, copy) NSString *lastName;@property (nonatomic, strong) EOCEmployer *employer;//将EOCEmployer作为属性@end// EOCPerson.m#import "EOCEmployer.h" 这样做有什么优点呢： 不在A的头文件中引入B的头文件，就不会一并引入B的全部内容，这样就减少了编译时间。 可以避免循环引用：因为如果两个类在自己的头文件中都引入了对方的头文件，那么就会导致其中一个类无法被正确编译。 但是个别的时候，必须在头文件中引入其他类的头文件: 主要有两种情况： 该类继承于某个类，则应该引入父类的头文件。 该类遵从某个协议，则应该引入该协议的头文件。而且最好将协议单独放在一个头文件中。 5. 类的布局1234567891011121314151617181920212223242526272829#pragma mark - Life Cycle Methods- (instancetype)init- (void)dealloc- (void)viewWillAppear:(BOOL)animated- (void)viewDidAppear:(BOOL)animated- (void)viewWillDisappear:(BOOL)animated- (void)viewDidDisappear:(BOOL)animated#pragma mark - Override Methods#pragma mark - Intial Methods#pragma mark - Network Methods#pragma mark - Target Methods#pragma mark - Public Methods#pragma mark - Private Methods#pragma mark - UITableViewDataSource #pragma mark - UITableViewDelegate #pragma mark - Lazy Loads#pragma mark - NSCopying #pragma mark - NSObject Methods 分类 1. 分类添加的方法需要添加前缀和下划线推荐这样写： 123@interface NSDate (ZOCTimeExtensions) - (NSString *)zoc_timeAgoShort;@end 不推荐这样写： 123@interface NSDate (ZOCTimeExtensions) - (NSString *)timeAgoShort;@end 2. 把类的实现代码分散到便于管理的多个分类中一个类可能会有很多公共方法，而且这些方法往往可以用某种特有的逻辑来分组。我们可以利用Objecctive-C的分类机制，将类的这些方法按一定的逻辑划入几个分区中。 举个🌰： 先看一个没有使用无分类的类： 123456789101112131415161718192021222324#import &lt;Foundation/Foundation.h&gt;@interface EOCPerson : NSObject@property (nonatomic, copy, readonly) NSString *firstName;@property (nonatomic, copy, readonly) NSString *lastName;@property (nonatomic, strong, readonly) NSArray *friends;- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName;/* Friendship methods */- (void)addFriend:(EOCPerson*)person;- (void)removeFriend:(EOCPerson*)person;- (BOOL)isFriendsWith:(EOCPerson*)person;/* Work methods */- (void)performDaysWork;- (void)takeVacationFromWork;/* Play methods */- (void)goToTheCinema;- (void)goToSportsGame;@end 分类之后： 1234567891011121314151617181920212223242526272829303132333435#import &lt;Foundation/Foundation.h&gt;@interface EOCPerson : NSObject@property (nonatomic, copy, readonly) NSString *firstName;@property (nonatomic, copy, readonly) NSString *lastName;@property (nonatomic, strong, readonly) NSArray *friends;- (id)initWithFirstName:(NSString*)firstNameandLastName:(NSString*)lastName;@end@interface EOCPerson (Friendship)- (void)addFriend:(EOCPerson*)person;- (void)removeFriend:(EOCPerson*)person;- (BOOL)isFriendsWith:(EOCPerson*)person;@end@interface EOCPerson (Work)- (void)performDaysWork;- (void)takeVacationFromWork;@end@interface EOCPerson (Play)- (void)goToTheCinema;- (void)goToSportsGame;@end 其中，FriendShip分类的实现代码可以这么写： 1234567891011121314151617181920212223242526272829// EOCPerson+Friendship.h#import "EOCPerson.h"@interface EOCPerson (Friendship)- (void)addFriend:(EOCPerson*)person;- (void)removeFriend:(EOCPerson*)person;- (BOOL)isFriendsWith:(EOCPerson*)person;@end// EOCPerson+Friendship.m#import "EOCPerson+Friendship.h"@implementation EOCPerson (Friendship)- (void)addFriend:(EOCPerson*)person &#123; /* ... */&#125;- (void)removeFriend:(EOCPerson*)person &#123; /* ... */&#125;- (BOOL)isFriendsWith:(EOCPerson*)person &#123; /* ... */&#125;@end 注意：在新建分类文件时，一定要引入被分类的类文件。 通过分类机制，可以把类代码分成很多个易于管理的功能区，同时也便于调试。因为分类的方法名称会包含分类的名称，可以马上看到该方法属于哪个分类中。 利用这一点，我们可以创建名为Private的分类，将所有私有方法都放在该类里。这样一来，我们就可以根据private一词的出现位置来判断调用的合理性，这也是一种编写“自我描述式代码（self-documenting）”的办法。 单例 1. 单例不能作为容器对象来使用单例对象不应该暴露出任何属性，也就是说它不能作为让外部存放对象的容器。它应该是一个处理某些特定任务的工具，比如在iOS中的GPS和加速度传感器。我们只能从他们那里得到一些特定的数据。 2. 使用dispatch_once来生成单例推荐这样写： 12345678+ (instancetype)sharedInstance &#123; static id sharedInstance = nil; static dispatch_once_t onceToken = 0; dispatch_once(&amp;onceToken, ^&#123; sharedInstance = [[self alloc] init]; &#125;); return sharedInstance; &#125; 不推荐这样写： 1234567+ (instancetype)sharedInstance &#123; static id sharedInstance; @synchronized(self) &#123; if (sharedInstance == nil) &#123; sharedInstance = [[MyClass alloc] init]; &#125; &#125; return sharedInstance; &#125; 相等性的判断 判断两个person类是否相等的合理做法： 1234567891011121314- (BOOL)isEqual:(id)object &#123; if (self == object) &#123; return YES; //判断内存地址 &#125; if (![object isKindOfClass:[ZOCPerson class]]) &#123; return NO; //是否为当前类或派生类 &#125; return [self isEqualToPerson:(ZOCPerson *)object]; &#125;//自定义的判断相等性的方法- (BOOL)isEqualToPerson:(Person *)person &#123; if (!person) &#123; return NO; &#125; BOOL namesMatch = (!self.name &amp;&amp; !person.name) || [self.name isEqualToString:person.name]; BOOL birthdaysMatch = (!self.birthday &amp;&amp; !person.birthday) || [self.birthday isEqualToDate:person.birthday]; return haveEqualNames &amp;&amp; haveEqualBirthdays; &#125; 方法文档 一个函数(方法)必须有一个字符串文档来解释，除非它： 非公开，私有函数。 很短。 显而易见。 而其余的，包括公开接口，重要的方法，分类，以及协议，都应该伴随文档（注释）： 以/开始 第二行识总结性的语句 第三行永远是空行 在与第二行开头对齐的位置写剩下的注释。 建议这样写： 12345/This comment serves to demonstrate the format of a doc string.Note that the summary line is always at most one line long, and after the opening block comment,and each line of text is preceded by a single space.*/ 看一个指定初始化方法的注释： 1234567/ * Designated initializer. * * @param store The store for CRUD operations. * @param searchService The search service used to query the store. * @return A ZOCCRUDOperationsStore object. */ - (instancetype)initWithOperationsStore:(id&lt;ZOCGenericStoreProtocol&gt;)store searchService:(id&lt;ZOCGenericSearchServiceProtocol&gt;)searchService; 多用队列，少用同步锁来避免资源抢夺 多个线程执行同一份代码时，很可能会造成数据不同步。建议使用GCD来为代码加锁的方式解决这个问题。 方案一：使用串行同步队列来将读写操作都安排到同一个队列里：1234567891011121314151617181920_syncQueue = dispatch_queue_create("com.effectiveobjectivec.syncQueue", NULL);//读取字符串- (NSString*)someString &#123; __block NSString *localSomeString; dispatch_sync(_syncQueue, ^&#123; localSomeString = _someString; &#125;); return localSomeString;&#125;//设置字符串- (void)setSomeString:(NSString*)someString &#123; dispatch_sync(_syncQueue, ^&#123; _someString = someString; &#125;);&#125; 这样一来，读写操作都在串行队列进行，就不容易出错。 但是，还有一种方法可以让性能更高： 方案二：将写操作放入栅栏快中，让他们单独执行；将读取操作并发执行。12345678910111213141516171819_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);//读取字符串- (NSString*)someString &#123; __block NSString *localSomeString; dispatch_sync(_syncQueue, ^&#123; localSomeString = _someString; &#125;); return localSomeString;&#125;//设置字符串- (void)setSomeString:(NSString*)someString &#123; dispatch_barrier_async(_syncQueue, ^&#123; _someString = someString; &#125;);&#125; 显然，数据的正确性主要取决于写入操作，那么只要保证写入时，线程是安全的，那么即便读取操作是并发的，也可以保证数据是同步的。这里的dispatch_barrier_async方法使得操作放在了同步队列里“有序进行”，保证了写入操作的任务是在串行队列里。 实现description方法打印自定义对象信息 在打印我们自己定义的类的实例对象时，在控制台输出的结果往往是这样的：object = &lt;EOCPerson: 0x7fd9a1600600&gt; 这里只包含了类名和内存地址，它的信息显然是不具体的,远达不到调试的要求。 但是！如果在我们自己定义的类覆写description方法，我们就可以在打印这个类的实例时输出我们想要的信息。 例如： 123- (NSString*)description &#123; return [NSString stringWithFormat:@"&lt;%@: %p, %@ %@&gt;", [self class], self, firstName, lastName];&#125; 在这里，显示了内存地址，还有该类的所有属性。 而且，如果我们将这些属性值放在字典里打印，则更具有可读性： 123456789- (NSString*)description &#123; return [NSString stringWithFormat:@"&lt;%@: %p, %@&gt;",[self class],self, @&#123; @"title":_title, @"latitude":@(_latitude), @"longitude":@(_longitude)&#125; ];&#125; 输出结果： 123456location = &lt;EOCLocation: 0x7f98f2e01d20, &#123; latitude = "51.506"; longitude = 0; title = London;&#125; 我们可以看到，通过重写description方法可以让我们更加了解对象的情况，便于后期的调试，节省开发时间。 NSArray&amp; NSMutableArray 1. addObject之前要非空判断。2. 取下标的时候要判断是否越界。3. 取第一个元素或最后一个元素的时候使用firtstObject和lastObjectNSCache 1. 构建缓存时选用NSCache 而非NSDictionary如果我们缓存使用得当，那么应用程序的响应速度就会提高。只有那种“重新计算起来很费事的数据，才值得放入缓存”，比如那些需要从网络获取或从磁盘读取的数据。 在构建缓存的时候很多人习惯用NSDictionary或者NSMutableDictionary，但是作者建议大家使用NSCache，它作为管理缓存的类，有很多特点要优于字典，因为它本来就是为了管理缓存而设计的。 2. NSCache优于NSDictionary的几点： 当系统资源将要耗尽时，NSCache具备自动删减缓冲的功能。并且还会先删减“最久未使用”的对象。 NSCache不拷贝键，而是保留键。因为并不是所有的键都遵从拷贝协议（字典的键是必须要支持拷贝协议的，有局限性）。 NSCache是线程安全的：不编写加锁代码的前提下，多个线程可以同时访问NSCache。 NSNotification 1. 通知的名称建议将通知的名字作为常量，保存在一个专门的类中： 12345// Const.hextern NSString * const ZOCFooDidBecomeBarNotification// Const.mNSString * const ZOCFooDidBecomeBarNotification = @"ZOCFooDidBecomeBarNotification"; 2. 通知的移除通知必须要在对象销毁之前移除掉。 其他 1. Xcode工程文件的物理路径要和逻辑路径保持一致。2. 忽略没有使用变量的编译警告对于某些暂时不用，以后可能用到的临时变量，为了避免警告，我们可以使用如下方法将这个警告消除： 12345- (NSInteger)giveMeFive &#123; NSString *foo; #pragma unused (foo) return 5; &#125; 3. 手动标明警告和错误手动明确一个错误：1234- (NSInteger)divide:(NSInteger)dividend by:(NSInteger)divisor &#123; #error Whoa, buddy, you need to check for zero here! return (dividend / divisor); &#125; 手动明确一个警告：12345678- (float)divide:(float)dividend by:(float)divisor &#123; #warning Dude, don't compare floating point numbers like this! if (divisor != 0.0) &#123; return (dividend / divisor); &#125; else &#123; return NAN; &#125; &#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS ImageView contentMode 图片填充模式]]></title>
    <url>%2F2019%2F07%2F12%2FiOS-ImageView-contentMode-%E5%9B%BE%E7%89%87%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[摘要： UIImageView的contentMode这个属性是用来设置图片的显示方式,如居中、居右,是否缩放等,系统给出的有枚举类型,以下示例图片比例大于imageViewUIViewContentModeScaleToFill,&lt;默认属性,图片根据imageView大小显示,会使图片变形&gt;根据视图的比例去拉伸图片内容UIViewContentModeScaleAspectFit,//contentsscaledtofitwithfixedaspect.remainde UIImageView的contentMode这个属性是用来设置图片的显示方式,如居中、居右,是否缩放等,系统给出的有枚举类型,以下示例图片比例大于imageView UIViewContentModeScaleToFill,&lt;默认属性,图片根据imageView大小显示,会使图片变形&gt; 根据视图的比例去拉伸图片内容 UIViewContentModeScaleAspectFit,/ /contents scaled to fit with fixed aspect. remainder is transparent (内容符合固定的方面。剩余部分是透明的) &lt;图片根据自身比例进行显示,图片小于imageView的部分会透明显示&gt; 保持图片内容的纵横比例,来适应视图的大小 UIViewContentModeScaleAspectFill,// contents scaled to fill with fixed aspect. some portion of content may be clipped.&lt;内容扩展填充固定方面。部分内容可能剪。&gt; &lt;图片按imageView大小比例居中显示,图片可能会失真并且不会显示完整,只显示中间部分&gt; 用图片内容来填充视图的大小,多余得部分可以被修剪掉来填充整个视图边界 UIViewContentModeRedraw,// redraw on bounds change (calls - setNeedsDisplay) &lt;重划边界变化(重设 - setNeedsDisplay)&gt; 这个选项是单视图的尺寸位置发生变化的时候通过调用setNeedsDisplay方法来重新显示 UIViewContentModeCenter,// contents remain same size. positioned adjusted.&lt;内容保持相同大小。定位调整&gt; 保持图片原比例在视图中间显示图片内容,如果视图大小小于图片的尺寸,则图片会超出视图边界,下面类同 UIViewContentModeTop, 保持图片原比例在视图中间顶部显示图片内容 UIViewContentModeBottom, 保持图片原比例在视图中间底部显示图片内容 UIViewContentModeLeft, 保持图片原比例在视图中间左边显示图片内容 UIViewContentModeRight, 保持图片原比例在视图中间右边显示图片内容 UIViewContentModeTopLeft, 保持图片原比例在视图左上角显示图片内容 UIViewContentModeTopRight, 保持图片原比例在视图右上角显示图片内容 UIViewContentModeBottomLeft, 保持图片原比例在视图左下角显示图片内容 UIViewContentModeBottomRight, 保持图片原比例在视图右下角显示图片内容]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS八种更新方式]]></title>
    <url>%2F2019%2F07%2F12%2FiOS%E5%85%AB%E7%A7%8D%E6%9B%B4%E6%96%B0%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、JSPatch热更新时，从服务器拉去js脚本。理论上可以修改和新建所有的模块，但是不建议这样做。建议 用来做紧急的小需求和 修复严重的线上bug。二、lua脚本比如： wax。热更新时，从服务器拉去lua脚本。游戏开发经常用到。三、Weex跨平台，一套代码，iOS、Android都可以运行。用前端语法实现原生效果。比React Native更好用。 weex基于vue.js，ReactNative使用React。 ReactNative安装配置麻烦。 weex安装cli之后就可以使用。 react模板JSX有一定的学习成本，vue和常用的web开发类似，模板是普通的html，数据绑定用mustache风格，样式直接使用css。 淘宝干的漂亮，中国在编码的实力越来越牛叉了。威武！！！ 四、React Native不像Weex能一套代码多端运行，需要自己分别做修改。 React Native 可以动态添加业务模块，但无法做到修改原生OC代码。 JSPatch、lua 配合React Native可以让一个原生APP时刻处于可扩展可修改的状态。 五、Hybrid像PhoneGap之类的框架, 基本概念和web差不多, 通过更新js/html来实现动态化，没有原生的效果流畅。 六、动态库可以做demo用，真实使用的时候会被苹果禁止。 因为 打包发到AppStore的ipa安装包 里的每个动态库 都有唯一的编码，iOS系统会进行验证，所以动态通过网络获取 新的动态库 也用不了。 七、rollout.ioRollout紧急修复线上bug。后端有相关的管理页面。因为是国外的网站，然后呢，要FQ才能使用。 八、DynamicCocoa滴滴iOS的一个框架，准备在2017年初开源，与JSPatch比更加智能化，用OC在XCode中写完代码，用工具可以自动生成可以更新的js文件。 转自 iOS热更新-8种实现方式]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>热更新</tag>
      </tags>
  </entry>
</search>
