<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[这书能让你戒烟]]></title>
    <url>%2F2020%2F06%2F30%2F%E8%BF%99%E4%B9%A6%E8%83%BD%E8%AE%A9%E4%BD%A0%E6%88%92%E7%83%9F-22-28%2F</url>
    <content type="text"><![CDATA[第22章 意志力戒烟法的弊端&emsp;&emsp;人们似乎普遍认为戒烟是一件难事，即使是戒烟方面的书籍，通常也会在开头部分描述戒烟的困难。其实，戒烟是一件无比简单的事情。我知道你仍然心存怀疑，但是请先听我说。&emsp;&emsp;如果你的目标是在4分钟内跑完1600米，那么这的确很难，你需要多年的艰苦训练，即使这样也并不一定能成功（人类取得的突破一性一成就，很多都是打 破固定思维模一式的结果。在罗杰?班尼斯特4分钟之内跑完1600米之前，人们都认为这是不可能的。但在今天，许多优秀运动员的成绩已经远远超过这一水 平）。 &emsp;&emsp;不过，如果你的目标是戒烟的话，那你只要停止吸烟就可以了。没有人强迫你吸烟（除了你自己），而且吸烟并不是你的生存需要。所以如果你决定停止吸 烟的话，又能有什么困难？事实上，困难是吸烟者自己创造的，因为他们使用的是意志力戒烟法。任何会让吸烟者觉得戒烟是一种牺牲的戒烟方法，我都定义为意志 力戒烟法。下面就来分析一下这类方法。 &emsp;&emsp;我们并不是自主决定成为吸烟者的。我们最初只不过是想尝试一下吸烟的感觉，因为那感觉十分糟糕，我们觉得自己如果想戒烟的话，肯定随时都能成功。起初我们只有在想到时才会吸烟，而且通常是在身边有其他吸烟者的时候。&emsp;&emsp;然而不知不觉间，我们开始经常买烟，吸烟也变成了下意识的行为，而且每天都要吸许多支。吸烟变成了生活的一部分，我们总是随身带着烟盒。我们相 信，吸烟能缓解压力，帮我们放松，让我们更享受饭后的感觉。我们并没有意识到，饭后吸烟与其他时间吸烟，烟味是一样的。事实上，吸烟既无助于缓解压力，也 不能帮我们放松，更无法让我们享受。这些只不过是吸烟者的错觉而已。 &emsp;&emsp;通常要过很多时间，我们才会意识到自己染上了烟瘾，因为我们误以为吸烟是一种享受，而不是一种毒瘾。事实上，我们不仅无法从吸烟中得到享受（这是不可能的），而且还对香烟形成了依赖。 &emsp;&emsp;直到尝试戒烟的时候，我们才会发现，事情并不是那么简单。年轻时戒烟通常是为了省钱，或者是出于健康方面的考虑。无论是出于何种原因，只有在感觉 到压力的时候，我们才会想到戒烟。一旦停止吸烟，尼古丁戒断症状就会出现，让我们产生心理上的空虚感。我们想靠吸烟来缓解这种感觉，但是又没有烟一抽一，于是 心情抑郁不振。抑郁了一段时间之后，我们通常会妥协：“我不会像以前一抽一那么多”、“现在戒烟时机不对”、“等到生活没有了压力再说”。然而，一旦没有了压 力，我们就失去了戒烟的理由，直到下一次感觉到压力为止。我们永远感觉时机不对，因为随着烟瘾的加深，我们会感觉到越来越重的压力。 &emsp;&emsp;事实上，我们承受的外在压力并没有增加，增加的压力正是尼古丁毒瘾导致的。这一机制会在第28章中详细讨论。 &emsp;&emsp;第一次戒烟失败后，我们会努力欺骗自己，幻想某一天一觉醒来，我们会忽然不再想吸烟了。这样的幻想通常来源于别人的戒烟经历（如“我有一阵子患了流感，病好了之后，我发现自己一点都不想吸烟了”）。 &emsp;&emsp;不要欺骗你自己。我进行过深入调查，类似这样的戒烟经历，并不像表面看上去那么简单。在得流感之前，故事中的戒烟者已经做好了戒烟的心理准备，流 感只不过是一个契机。我花了30多年时间等待这样一天的到来，然而每次患感冒或流感的时候，我唯一期待的就是病快点好，免得影响我吸烟。 &emsp;&emsp;通常情况下，这些“莫名其妙”成功戒烟的人都经历过某种冲击，比如某个亲友因吸烟引发的疾病而死，或是他们自己意识到了吸烟的危害一性一。他们之所以对这一过程轻描淡写，是因为这样描述更容易一些。不要欺骗你自己，戒烟过程绝不是自发的，而是需要你的主观能动一性一。 &emsp;&emsp;让我们仔细分析一下，为什么意志力戒烟法如此之难。自从染上烟瘾以来，我们一直把头埋在沙子里，用“明天我就能戒烟成功”之类的幻想欺骗自己。 &emsp;&emsp;偶尔我们也会受到一些刺激，从而决定戒烟。这刺激或许是健康、金钱和社会形象方面的考虑，或许是因为我们意识到吸烟并不是享受，等等。 &emsp;&emsp;无论是出于什么原因，我们不再把头埋一进沙子里，开始权衡吸烟的利弊得失。我们的理一性一立即意识到，吸烟有弊无利，必须马上停止。 &emsp;&emsp;假如你坐下来，分别为戒烟的好处和吸烟的“好处”逐条打分，那么前者的总分肯定远远高于后者。 &emsp;&emsp;不过，尽管你知道戒烟有这么多好处，却在心底把戒烟当成一种牺牲。尽管这只是一种错觉，其暗示力量却十分强大。你并不知道个中原因，但你的确认为，吸烟对你的生活有所帮助。 &emsp;&emsp;尝试戒烟之前，你早已受到社会洗脑的影响，再加上你自己对自己的洗脑，你觉得“放弃是一桩难事”。 &emsp;&emsp;你曾听说过，有些人戒烟已经好几个月，仍然对烟卷念念不忘。你也听说过，有些人尽管终生不再吸烟，却并没能摆脱烟瘾的折磨。还有些人戒烟多年，生 活幸福美满，但却又突然恢复了吸烟的“习惯”。或许你认识一些重度吸烟者，尽管他们的健康已经接近崩溃，而且绝对不是在“享受”吸烟的感觉，但他们却仍在 吸烟。你甚至亲身一体验过这样的感觉。 &emsp;&emsp;所以，你的反应不是“太棒了！你听说了吗？我再也不用吸烟了”，而是感觉自己正面临一桩不可能完成的任务，仿佛攀登珠穆朗玛峰一样。你深信不疑， 一旦染上了烟瘾，终生都无法摆脱。许多吸烟者开始戒烟时，甚至会对亲友们说这样的话：“对不起，我打算戒烟，接下来几个星期我可能脾气很不好。求你们尽量 忍受。”这样的戒烟尝试，还没开始就注定要失败。 &emsp;&emsp;假设你强忍住不吸烟，这样过了几天，你肺部的有毒物质迅速减少。因为你这几天没有买烟，口袋里的钱多了不少。这样，你最初戒烟的原因就不复存在 了。这就像是开车时目睹一起一交一 通事故，你或许会暂时放慢车速，但是下次你需要赶时间开车赴约的时候，又会一脚把油门踩到底。 &emsp;&emsp;另一方面，你身一体对尼古丁的渴求还没有消失。戒断症状十分轻微，而且没有生理上的疼痛，只有心理上的空虚感。但你并不知道这就是戒断症状，你只是 感觉想一抽一支烟，至于为什么想，你完全不清楚。这种感觉会很快从潜意识上升到意识层面，过不了多久你就会搜肠刮肚，努力寻找吸烟的理由。你或许会说： &emsp;&emsp;1.人生苦短。或许我体内已经有了癌细胞。或许我明天就会出车祸死掉。现在戒烟反正也晚了。再说，这年头癌症的发病率实在太高了。 &emsp;&emsp;2.我选错了时机。我应该等到非周末时间/假期结束/熬过这段日子，再开始戒烟。 &emsp;&emsp;3.我无法集中注意力，容易激动，脾气也变坏了。我无法正常工作，家人和朋友也不喜欢我这样。为了他们的缘故，我必须得恢复吸烟。反正我也是个重度吸烟者了，不吸烟的话，我永远都没办法开心起来（我自己当初的理由就是这样）。 &emsp;&emsp;到了这一阶段，你通常会向自己投降。你点起一支烟，心中的矛盾越发严重了。一方面，你对尼古丁的饥一渴终于得到了缓解；另一方面，因为很久没吸烟 了，烟味感觉很糟糕，你不明白自己怎么能忍受得了。或许你会责怪自己意志薄弱。事实上，你缺乏的绝不是意志力。你只不过是就情况的变化做出了新的选择。如 果连生活质量都无法保证，健康又有什么意义？财富又有什么意义？如果能提高生活质量，寿命短一点又有什么关系？ &emsp;&emsp;事实上，非吸烟者的生活质量比吸烟者要高得多，但是你却会产生相反的错觉。正是这样的错觉，让我甘心做了33年的烟鬼。我必须承认，假使事实真的是这样，那我一定不会戒烟的——尽管那样我绝对活不到今天。 &emsp;&emsp;吸烟者的痛苦与尼古丁戒断症状并无关系。的确，痛苦是由戒断症状引发的，但真正的问题在于你的心态，你心中的犹豫和怀疑。因为认定戒烟是一种牺 牲，你会感觉生活仿佛缺少了什么——而这样的感觉会产生压力。压一种牺 牲，你会感觉生活仿佛缺少了什么——而这样的感觉会产生压力。压力是导致你想吸烟的因素之一，但是现在你正在戒烟，二者之间的矛盾会进一步加重压力。 &emsp;&emsp;意志力戒烟法的困难还有一个原因：你不得不保持等待的心态。假如你的目标是通过驾照考试，那么通过之后你就可以告诉自己，你已经达到了目标。但是使用意志力法戒烟时，你告诉自己的是“如果我能忍住不吸烟，过了足够长的时间，烟瘾就会自然消失”。 &emsp;&emsp;“足够长的时间”到底是多长？你完全没办法判断，只能慢慢等待，期盼着某件事可以作为标志，让你知道戒烟确实成功了。事实上，在你熄灭最后一支烟的那一瞬间，戒烟就已经成功了；你所等待的，不过是戒烟再次失败的那一刻——你向自己屈服的那一刻。 &emsp;&emsp;我已经说过，吸烟者的痛苦是心理上的，是犹豫和怀疑的结果。尽管没有生理上的疼痛，但心理上的痛苦同样难以承担。你的生活没有任何幸福感和安全感可言。你原本应该把吸烟这回事彻底忘掉，然而你的意识却偏要纠缠不休。 &emsp;&emsp;这种痛苦可能持续几天，甚至几个星期。你的头脑里充满了这样的想法： &emsp;&emsp;“烟瘾究竟还要持续多久？” &emsp;&emsp;“我还能找到幸福吗？” &emsp;&emsp;“我每天早上会愿意起床 吗？” &emsp;&emsp;“我还能享受饭后的时光吗？” &emsp;&emsp;“我将来该怎么缓解压力？” &emsp;&emsp;“我该怎么应付社一交一 场合？” &emsp;&emsp;你在这样想的时候，对香烟的渴望就会越来越强。 &emsp;&emsp;事实上，只要你坚持三个星期不吸烟，身一体对尼古丁的饥一渴就会消失。虽然尼古丁戒断症状十分轻微，但在症状消失时，许多戒烟者还是意识得到，他们已 经“摆脱了烟瘾”。他们会点起一支烟来证明这一点。烟味让他们感觉很糟糕，似乎烟瘾的确已经消失了。然而这么一来，他们又摄入了新的尼古丁，香烟熄灭之 后，戒断症状又会重新出现。他们会下意识地想：“我还得再来一支。”他们原本已经摆脱了烟瘾，这样一来又重新染上了。 &emsp;&emsp;他们并不会立刻点起第二支烟，因为他们还抱着这样的心理：“我不能重蹈覆辙。”所以他们会等上一段时间，直到感觉安全了为止。过了几个小时，几 天，几个星期之后，他们会想：“看来我的确是摆脱烟瘾了，所以现在再一抽一一支也无所谓。”殊不知，他们正在一点点滑一向原本已经挣脱的陷阱。 &emsp;&emsp;意志力戒烟法通常需要很长的时间，因为戒烟的最大问题在于洗脑，而不是生理上的毒瘾。即使尼古丁上瘾症状已经消失了很久，戒烟者仍然会从心理上渴 望再来一支烟。不过最终，如果时间真的足够久，他们或许会意识到自己的确已经挣脱了陷阱。他不会再渴望吸烟，因为他已经意识到，没有香烟的生活其实更加美 好。 第23章减量戒烟法：当心！102&emsp;&emsp;一些吸烟者会采用所谓的减量戒烟法，目的可能是彻底戒烟，也可能只是为了控制吸烟的量。许多医生和顾问也推荐减量戒严法。 &emsp;&emsp;你吸的烟越少，对你的生活影响就越小，这是显而易见的。不过如果打算把减量法作为戒烟手段，那可就大错特错了。正是因为这种姑息纵容的态度，我们才无法与烟瘾真正决裂。 &emsp;&emsp;“现在我可以游泳、骑车、冲一浪一、跑步、玩帆板，再也不会气喘吁吁了。每半个小时喷一次哮喘喷剂的日子，永远一去不复返了。” ——凯文.M &emsp;&emsp;通常是在尝试戒烟失败之后，吸烟者才会考虑减量法。一段时间强忍着不吸烟之后，他们会对自己说：“我现在还受不了没有香烟的生活，所以从现在开始，我只在最关键时候才抽烟，每天的量不超过10支。假如我能习惯每天只一抽一10支烟，那我就能一抽一得更少。” &emsp;&emsp;他没有意识到的是： &emsp;&emsp;1. 他现在处于最糟糕的状态。他的身一体和头脑都没有脱离烟瘾的掌控。 &emsp;&emsp;2. 现在他无时无刻不渴望着下一支烟。 &emsp;&emsp;3. 采用减量法之前，他想吸烟时就会点上一支，这样至少可以部分缓解尼古丁戒断症状。现在，除了正常的生活压力之外，他还主动让自己经历戒断症状。他的生活质量会大幅度下降，脾气也会越来越坏。 &emsp;&emsp;4. 过去他意识不到自己正在吸烟。吸烟只是一个下意识的过程，他并不认为自己很“享受”这一过程，除了在某些特定情境之下（早起、饭后第一支烟等）。现在，他每吸一支烟都变成了有意识的行为。间隔时间越长，他就会越觉得自己是在“享受”每一支烟，因为戒断症状比先前更重，尼古丁带来的缓解作用也就更明显。在痛苦中忍受得越久，他就越“享受”暂时缓解痛苦的机会。 &emsp;&emsp;戒烟的最大障碍并不在于生理上的毒瘾。尼古丁上瘾的戒断症状非常轻微，吸烟者夜里睡觉时，截断症状甚至不会让他们醒来。许多吸烟者起床 后并不会立即点燃香烟，而是会先吃早饭，甚至先上班工作。 &emsp;&emsp;睡眠时，他们可以轻松忍受10个小时的戒断症状，但在白天，10个小时不吸烟却会让他们抓狂。 &emsp;&emsp;许多吸烟者买了新车之后，都会忍不住在车里吸烟。他们会花好几个小时看电一影 、逛超市、乘坐地铁，尽管这些地方禁止吸烟，对他们也没什么影响。他们并不在意身边有非吸烟者，事实上，他们巴不得有这样一个理由，可以暂时不用吸烟。吸烟者长期不用吸烟时，内心的快乐实际上多于痛苦，因为他们感觉到了希望，觉得将来或许真能戒烟成功。 &emsp;&emsp;戒烟的最大障碍在于心理上的洗脑，在于误以为吸烟是一种享受，戒烟意味着放弃这种享受。减量法并不能降低你对吸烟的心理依赖，只能增加你的痛苦和不安全感，让你相信香烟是世界上最好的东西，戒烟会剥夺你生活的快乐。 &emsp;&emsp;一旦采用减量戒烟法，戒烟者就陷入了十分矛盾的境地。他的想法是，吸的烟越少，他就越不想吸烟。事实则正好相反，他吸的烟越少，戒断症状 就越严重，他对尼古丁的饥一渴也就越迫切。相反，他吸的烟越多，丢烟味就越难以忍受，但这也不会让他停止吸烟。 &emsp;&emsp;这一切与烟味的感觉无关。世上没有喜欢烟味的吸烟者，你不相信？那好，一天中味道最糟糕的是哪一支烟？没错，是第一支。仔细想一想，你究竟是在享受烟味，还是急于缓解九个多小时带来的戒断症状？ &emsp;&emsp;如果真心希望戒烟，我们就不能抱有任何幻想。如果熄灭最后一支烟时，你仍然相信吸烟是一种享受，那你以后就无法验证这一点，除非重新染上烟瘾。所以，如果你现在嘴上没叼着烟，那就点起一支来，深吸一口，你能不能告诉我，烟味究竟有什么好的?或许你相信，只有在特定情境下，比如饭后，吸烟才是一种享受。如果是这样，那你为什么其他时候也会吸烟?是因为习惯吗?既然烟味如此糟糕，任何人有可能养成这样的习惯吗?而且同样的品牌，同样的香烟，饭后的烟味跟平时有区别吗?吸烟并不会改变食物的味道，那么食物怎么可能改变烟味? &emsp;&emsp;空口无凭，你可以试一试：饭后，有意识地吸一支烟，你会发现烟味跟平时没有任何区别。之所以吸烟者会以为饭后或社一交一 场合吸烟感觉更好，是因为这些本来就是轻松快乐的场合，无论对吸烟者还是非吸烟者都一样。 &emsp;&emsp;当然，由于尼古丁上瘾的缘故，吸烟者的快乐程度永远赶不上非吸烟者。这跟烟味有什么关系?烟又不是用来吃的。如果吸烟者没法缓解戒断症状的话，就会感觉非常痛苦，吸烟只能让他们相对没那么痛苦，这样能称为“享受”吗?说是“忍受”或许还更贴切—些。 &emsp;&emsp;减量戒烟法不仅没有任何效果，而且过程非常痛苦。没有效果是因为戒烟者原本希望逐渐消除烟瘾，结果却无法如愿。只有习惯才能用这样的方式改掉，而烟瘾并不是习惯，只是尼古丁毒瘾而已。毒瘾的特点是会随着每次吸毒而增强，绝不会因吸毒而减弱。减量戒烟法需要相当强的意志力，让戒烟者相当痛苦，却完全起不到减弱烟瘾的作用。 &emsp;&emsp;尼古丁毒瘾还不是最难对付的，最难对付的是错误的想法和态度。由于来自社会和我们自己的洗脑，我们误以为吸烟是一种享受。减量法唯一的作用，就是进一步加深这种误解，导致我们余生都对吸烟念念不忘，无时无刻不在盼望着下一支烟。减量戒烟对意志力的要求，比彻底戒烟还要高得多。如果你不能彻底戒烟的话，你就更不可能成功减量。彻底戒烟不仅更容易，造成的痛苦也更小。 &emsp;&emsp;在我关注过的减量戒烟者中，绝大多数最后都失败了，只有极少数的成功者，而且都是在开始减量后不久就彻底戒烟的。他们能成功戒烟并不是减量的结果，事实上，减量戒烟法只会影响戒烟过程，延长戒烟者的痛苦。 一旦减量戒烟失败，戒烟者的心理会受到严重的打击，甚至对戒烟彻底绝望。承受过这样的打击，他至少要再过五年才能重新鼓起勇气戒烟。 &emsp;&emsp;不过，减量戒烟法的确暴露了一件事情，那就是吸烟其实毫无意义。只有在戒断症状的痛苦之中，吸烟才会被误解为“享受”——如果你能把拼命用头撞墙，然后再停下来的感觉称为享受的话。 &emsp;&emsp;所以你的选择包括： &emsp;&emsp;1．一辈子减量吸烟。这样你会越来越痛苦，最后迟早会放弃。 &emsp;&emsp;2．像原来一样放任自己吸烟。戒烟又有什么意义? &emsp;&emsp;3．对你自己好一点。一次一性一把烟戒掉。减量戒烟法还暴露了另一件事情：任何一支烟都不是偶然的。吸烟会形成连锁反应，每点燃一支烟，都会引发第二支，第三支………直到你的生命结束，或者你彻底戒烟。 &emsp;&emsp;记住，“减量”并不能“戒烟”。 24章只要一支烟108&emsp;&emsp;把“只要一支烟”这样的想法彻底赶出你的脑海。 &emsp;&emsp;当初，只是一支烟，我们就染上了烟瘾。 &emsp;&emsp;戒烟进行到最困难的时候，只要一支烟，我们先前的努力就全部付诸东流。 &emsp;&emsp;戒烟成功之后，只要一支烟，我们就会重新掉进烟瘾的陷阱。或许这一支烟只是为了证明我们已经摆脱了烟瘾，结果却起到了相反的效果。因为烟味的感觉极端糟糕，我们自以为再也不会染上烟瘾了——然而事实却正好相反。 &emsp;&emsp;让吸烟者无法下定决心戒烟的，或许只不过是对某一支烟的记挂——早上或者饭后的第一支。即使在决心戒烟之后，他们仍然会记挂这一支烟。 &emsp;&emsp;记住，根本就不存在“一支烟”这个概念。吸烟是一个连锁反应，每一支烟都会让你接着吸下一支，直到你生命的结束——除非你成功戒烟。 &emsp;&emsp;不要考虑某一支烟或者某一盒烟，把吸烟这件事情作为一个整体来看待。任何一支烟都意味着一辈子浪费金钱，摧毁健康，甘心忍受烟瘾的一奴一役。 &emsp;&emsp;我们总是觉得，在某些特定的情境下，吸烟是一种享受。这是不可能的。你只有两条路可走：要么继续吸烟，一辈子忍受痛苦；要么把自己从这种痛苦中解放出来。你就算再享受杏仁的味道，也绝不会去服用剧毒的苦杏仁苷。烟味本来就没什么可享受的，你为什么要用尼古丁毒害自己? &emsp;&emsp;随便问一个吸烟者：“如果你有机会回到吸第一支烟之前的状态，你还会选择吸烟吗?”答案必然是：“绝对不会!”然而吸烟者每天都有选择戒烟的机会，为什么他不肯行动呢?因为恐惧的缘故，他恐惧戒烟会永远剥夺他的“享受”。 &emsp;&emsp;不要欺骗你自己。你完全做得到，任何人都做得到。戒烟其实真的非常容易。 &emsp;&emsp;要想让戒烟变得容易，你必须首先弄清楚几个概念。我们已经详细分析了其中三个： &emsp;&emsp;1．戒烟并不需要放弃任何东西，只会得到许多收获。 &emsp;&emsp;2．不要考虑某一支烟。吸烟这件事情是一个整体，任何一支烟都意味着一辈子做烟瘾的一奴一隶。 &emsp;&emsp;3．你的情况跟别人并没有什么区别。所有吸烟者都可以轻松戒烟。许多吸烟者觉得自己的烟瘾已经深人膏盲，或者是一性一格上有缺陷，于是彻底失去了戒烟的信心。我向你保证，绝没有这样的事情。没有任何人“需要”吸烟，直到他染上尼古丁毒瘾为止。吸烟是毒瘾的结果，不是你自己的问题。你的一性一格没有任何缺陷。不要在心理上依赖尼古丁，否则即使生理上的毒瘾已经消除，你仍然无法得到解脱。不要再让自己蒙在鼓里。 第25章吸烟者的类型111&emsp;&emsp;重度吸烟者经常会羡慕轻度吸烟者。他们会说：“告诉你，我一个星期不吸烟都没关系。我其实并不在乎。”我们会想：“要是我能像那样就好了。”不过别忘了，即使对于轻度吸烟者，吸烟同样不是享受。记住： &emsp;&emsp;?没有人是自主选择成为吸烟者的，无论程度轻重； &emsp;&emsp;所以： &emsp;&emsp;?所有吸烟者都觉得自己很愚蠢，所以： &emsp;&emsp;?所有吸烟者都需要自欺欺人，为自己的愚蠢寻找理由。 &emsp;&emsp;我狂一热一爱一好高尔夫球的时候，经常跟人吹嘘我打球有多么频繁。那么吸烟者为什么要吹嘘他们用不着经常吸烟?如果这值得吹嘘的话，那彻底戒烟不是更好吗? &emsp;&emsp;“我的皮肤重新变好了!脸上再也不会感觉干干的，也没有青春痘了，只有干净的、柔软的皮肤!焕发出健康的光泽!我几乎无法相信，我的脸颊又恢复了红一润!”——黛比?S &emsp;&emsp;假如我对你说：“告诉你，我一个星期不吃一胡一 萝卜都没关系，我其实并不在乎。”你肯定会觉得我脑筋有问题。如果我一爱一吃一胡一 萝卜的话，为什么要强忍着一个星期不吃?如果我不一爱一吃一胡一 萝卜，为什么要说这种话?所以当吸烟者说“我一个星期不吸烟都没关系”的时候，他其实是想让自己和别人相信，他并没有任何问题。不过如果真的没问题，他就没必要说这种话。他的真正意思是：“我强忍着一个星期没吸烟。”同其他吸烟者一样，他情愿一辈子再也不吸烟，但他又误以为吸烟是一种享受，所以最多只能忍一个星期。 &emsp;&emsp;所以，轻度吸烟者的烟瘾其实比重度吸烟者更重：他们更相信吸烟是一种享受，而且戒烟的理由也不够充足，因为他们浪费在吸烟上的钱相对较少，健康遭受的损害也较小。 &emsp;&emsp;记住，吸烟者从吸烟中能得到的唯一“享受”，就是尼古丁戒断症状的暂时缓解(小小我非常赞同这句话)。我已经解释过，这绝不是真正的享受。把烟瘾想象成身上某个地方发一痒，只不过感觉非常轻微，你通常意识不到。 &emsp;&emsp;既然发一痒，你自然会想去挠。随着身一体的适应，尼古丁对你的刺激越来越小，于是“挠痒”的需求也越来越大，你巴不得能随时处于吸烟状态。 &emsp;&emsp;然而有三个因素阻止你这样做： &emsp;&emsp;1．金钱。大多数人买不起这么多烟。 &emsp;&emsp;2．健康。为了缓解戒断症状，我们必须承受焦油等有害物质的毒害。身一体的承受能力并不是无限的，所以吸烟的频率也有上限，并不是所有人都能连续吸烟。 &emsp;&emsp;3．自我约束。这是由社会观念、吸烟者的生活和工作环境、亲友以及吸烟者自己共同决定的。究竟是吸烟还是戒烟，每个吸烟者头脑里都会反复斗争。 &emsp;&emsp;我曾经是个连续吸烟者。我不清楚别人怎么能每天只吸10支或20支烟。我知道自己的意志力其实很强，但我从来没想过，大多数吸烟者承受不了连续吸烟对身一体的损害。那些每天只吸5支烟的人，有的是因为身一体较为虚弱，无法承受超过5支烟的毒害；有的是因为买不起更多的烟；有的是因为工作和生活环境、亲友或自己的态度等原因，才没有吸更多的烟。 &emsp;&emsp;这里我会顺便解释几个概念。 &emsp;&emsp;非吸烟者：从未掉进过烟瘾陷阱的人。非吸烟者不要自鸣得意，因为他们只是碰巧没有染上烟瘾而已。所有吸烟者在成为吸烟者之前，都不相信自己会染上烟瘾，而某些非吸烟者偶尔也会尝试吸烟。 &emsp;&emsp;轻度吸烟者：轻度吸烟者可分为两大类。 &emsp;&emsp;1．尽管已经染上烟瘾， 自己却没有意识到。这样的吸烟者并不值得羡慕，他们很有可能成为重度吸烟者。记住，所有酒鬼都是从偶尔贪杯开始的，烟鬼也是一样。 &emsp;&emsp;2．曾经是重度吸烟者，经过减量法戒烟变成轻度吸烟者。这样的吸烟者最为可怜。这一大类又可划分咸几个小类，需要分别加以评论。 &emsp;&emsp;“每天五支烟”型吸烟者：如果他真的享受吸烟的过程，为什么每天只吸五支烟?如果他并不享受，又何必要吸烟呢?记住，吸烟并不是习惯，只是 为了缓解毒瘾戒断症状。“每天五支烟”型的吸烟者，每天只有五次机会缓解戒断症状，每次不超过—个小时。余下的时间里，他都要忍受毒瘾的折磨，尽管他自己意识不到。他每天只吸五支烟，或许是因为买不起更多的烟，或许是担心吸烟有害健康。要说服他相信吸烟并不是享受，比说服一个重度吸烟者要难很多。任何尝试过减量戒烟法的吸烟者都知道，这种方法非但不能戒烟，而且还是最痛苦的折磨。 &emsp;&emsp;“只在上午或下午吸烟”型吸烟者：每天有一半的时间，他需要忍受戒断症状的痛苦，另一半时间则都在毒害他自己的身一体。如果他真的享受吸烟的过程，为什么不整天都吸烟?如果他并不享受，又何必要吸烟呢? &emsp;&emsp;“半年吸烟，半年戒烟”型吸烟者：他的一贯观念是“我只要想，随时都可以戒烟，我已经成功过许多次了。”如果他真的享受吸烟的过程，为什么一年有半年戒烟?如果他并不享受，为什么一年有半年吸烟?实际上，每次戒烟时，他摆脱的只是生理上的烟瘾，并没有摆脱心理上对吸烟的依赖。他没有意识到吸烟是洗脑的结果。每次他都希望能一劳永逸，永远不用再吸烟，可每次又都以失败告终。许多人都羡慕这样的吸烟者，认为他们能够控制自己的烟瘾，想吸烟就随便吸，想戒烟就可以戒掉。实际上，这样的吸烟者完全没有任何控制权。吸烟时他们希望自己戒烟，戒烟后他们又渴望着吸烟。他们永远无法满足。事实上，这样的论断对所有吸烟者都成立。只有当某种因素组织我们吸烟时，我们才会把吸烟当成一件好事。吸烟者永远得不到享受，因为所谓“吸烟的享受”只不过是一种幻觉。摆脱幻觉的唯一方法是戒烟，从生理和心理上摆脱烟瘾。 &emsp;&emsp;“只在特定场合吸烟”型吸烟者：没错，我们开始吸烟时都是这样的，但是很快，任何时间和地点都会成为“可以吸烟”的 “特定场合”。 &emsp;&emsp;“我已经戒烟了，只是偶尔还会来上一支”型吸烟者：他同样没有摆脱对烟瘾的心理依赖。他有可能一辈子感觉失落，相信戒烟意味着失去了很多东西，也有可能把“一支烟”变成两支，三支，重新走上吸烟之路。他们就像处于滑一溜溜的陷阱边缘，唯一的可能一性一就是往下滑。他们会重新跌回陷阱里，只是迟早的事情。 &emsp;&emsp;除此之外，轻度吸烟者还包括两类。第一类是那种为了应酬，不得不在某些社一交一 场合点上一支烟的吸烟者。这样的人其实属于非吸烟者，他们完全没有“吸烟是一种享受”的幻觉，只不过是想与身边的人保持一致。我们染上烟瘾之前都是这样的。下一次在社一交一 场合，有人分发雪茄的时候，注意观察那些吸烟者。过不了多久，他们就会表现得坐立不安，巴不得手上的雪茄早点熄灭，即使是重度吸烟者也是一样。雪茄越贵，越长，他们的反应就越严重——该死的雪茄仿佛能烧一晚上第二类则相当罕见，事实上，在我所帮助戒烟的数千人中，这一类吸烟者只占十几例。我会用最近发生的一个例子来说明。一位女士打来电话，预约我的个人咨询服务。她是一位律师，有12年的吸烟吏，每天不多不少，恰好两支烟。她表现出了非常强的意志力。我向她解释，个人咨询的成功率并不比群体咨询高，而且只有对身份特殊、会影响群体咨询效果的戒烟者，我才会提一供个人咨询服务。她开始哭，最后把我说服了。 &emsp;&emsp;咨询费非常昂贵。大多数吸烟者都不会理解她想戒烟的原因，他们宁愿付出双倍的咨询费，只要能达到她的“每天两支烟”状态就够了。他们以为轻度吸烟者的生活比重度吸烟者更快乐，事实却往往不是这样。在这位女士的例子中，她的父母都在她染上烟瘾之前死于肺癌。像我一样，尝试第一支烟之前，她电对吸烟充满了恐惧，而且她也特别讨厌烟味。与我不同的是，她并没有成为一名连续吸烟者。 &emsp;&emsp;我已经多次解释过，吸烟能提一供的唯一“享受”就是暂时缓解尼古丁毒瘾，满足吸烟者心理上对吸烟的依赖。吸烟本身十分痛苦，绝没有任何值得享受之处。所以，吸烟者只有在一段时间无法吸烟之后，才会感觉到对吸烟的渴望。这就与生理上的饥饿一样，你饿得越久，最终吃到东西时的感觉就越好。只不过，对吸烟的“饥饿”主要是心理上的。很多吸烟者都误以为吸烟是一种习惯。他们想：“如果我能管住自己，每天只吸若干支烟，或者只在特定的场合吸烟，那我就会逐渐适应新的习惯，之后还可以进一步减少吸烟的量。”你一定要清楚，吸烟根本不是习惯，所以也不能用这样的方法“改掉”。吸烟是一种毒瘾，人一体 对毒瘾的自然反应是摄入更多的毒一品 ，如果没有及时摄人，就会出现戒断症状。即使你只是维持现在的吸烟程度，也需要相当程度的意志力，因为随着你的烟瘾越来越重，对尼古丁刺激的依赖一性一也会逐渐增。吸烟会摧毁你的健康和意志，让你丧失信心和勇气，越来越难以忍受两支烟之间的间隔。这样就解释了为什么只有在染上烟瘾的早期，我们才能“控制”吸烟的量；为什么因为得了感冒而停止吸烟，我们不会感到难受。感冒是一个正当理由，不会触发我们心理上对吸烟的依赖。这样也解释了为什么我当年虽然并不认为吸烟是一种享受，却还是每天连续吸烟，尽管每一支烟都是生理上的折磨。 &emsp;&emsp;不要羡慕那位女士。如果你每过12小时吸一支烟，就会觉得那支烟是世界上最好的东西。那位可怜的女士12年来一直处于内心的矛盾中，一方面无法戒烟，一方面又因为恐惧而不愿增加吸烟的量。每天20多个小时，除了吸烟的那几十分钟之外，她都得抗拒香烟的诱一惑。若不是她意志力很强，根本不可能坚持这么久，所以她才会在电话里开始哭泣。按照正常的逻辑，吸烟要么是一种享受，要么不是。如果吸烟真的是享受，那为什么要等上一个小 时，一天，一个星期?为什么等待过程中，你没法享受别的东西?而如果吸烟不是享受，那为什么要吸烟呢? &emsp;&emsp;我还记得另一位“每天五支烟”型的男士。电话里，他的第一句话是：“卡尔先生，我只希望在死之前能成功戒烟。”他是这样描述自己的：“我已经61岁了，因为吸烟患上了喉癌。现在我每天最多吸五支烟，再多喉咙就受不了。” &emsp;&emsp;“过去我睡眠质量很好，但现在夜里经常醒来，每次心里都惦记着吸烟。就算在睡得着的时候，我梦见的也是吸烟。” &emsp;&emsp;“我的第一支烟必须等到十点钟。我五点钟就起床 ，一杯接一杯地喝茶。我妻子大约八点起床 ，因为我脾气太坏，她不允许我待在宅子里。我只能去一温一 室散步，满脑子都想着那支烟。到了九点钟，我开始掏出烟叶自己卷烟，动作故意放得很慢，因为卷快了也只能等着。等到十点的时候，我的手会不自觉地开始颤一抖。我一般不会马上把烟点燃，免得再等上三个小时。矛盾了很久之后，我会点燃烟卷，一抽一一口，然后立即把烟卷熄掉，这样一支烟可以一抽一上一个小时。我把整支烟卷吸完，然后开始下一轮的等待。” &emsp;&emsp;这样做的结果之一是，他的嘴唇和手指都被烟卷烫得满是水疱。或许你心目中已经浮现出一个可怜的白痴形象。然而事实却是，他身高一米八以上，曾在海军陆战队做过军官，之前曾是个运动员。他并不是自愿成为吸烟者的，但是在“二战”期间，人们普遍认为吸烟能提高勇气，军入都有免费的香烟配发。他几乎是被强迫开始吸烟的。在接下来的年头里，他为了烟瘾浪费了无数纳税人的钱，而且身一体和心理都受到了严重影响。假如他是一只动物， &emsp;&emsp;我们的社会会对这样的动物执行安乐死，然而即使在今天，我们仍然允许原本身心健康的青少年成为吸烟者。 &emsp;&emsp;或许你认为以上的例子被夸大了。我可以负责任地说，完全没有。尽管有些极端，但这样的例子并不是唯一的。类{以的吸烟者还有成千上万。那位男士对我倾诉了他的痛苦，但是可以预见，许多吸烟者都会羡慕他——因为他每天只吸五支烟。如果你觉得自己绝不会堕落成这样，那我要说：停止自欺欺人吧! &emsp;&emsp;你现在就正在堕落。 &emsp;&emsp;吸烟者几乎都会撒谎，即使是对他们自己。绝大多数轻度吸烟者吸烟的量和频率，比他们自己承认的要高得多。我曾与很多所谓的“每天五支烟”型吸烟者接触过，单在我们谈话的时间里，他们一抽一的烟就超过了五支。在婚礼、晚会等社一交一 场合上，即使是轻度吸烟者也会连续吸烟。 &emsp;&emsp;所以你用不着羡慕他们。你也用不着吸烟。戒烟后的生活会幸福得多。 &emsp;&emsp;青少年戒烟通常更为困难，倒不是因为烟瘾更重，而是因为他们要么不相信自己染上了烟瘾，要么抱有幻想，认为自己某一天会自动停止吸烟。 &emsp;&emsp;我必须特别警告所有青少年的家长：不要以为你们的孩子自称讨厌烟味，就觉得他们不会染上烟瘾。所有孩子都会讨厌烟味，这是一切生物的自然反应，你自己当年也是这样的。不要被政一府的宣传蒙蔽，吸烟陷阱的本质并没有任何改变。孩子们都知道吸烟会致死，但也知道单单一支烟不会。或许他们会在同学、玩伴、朋友的影响下尝试吸烟，尽管烟味很糟糕，但他们反而会产生虚假的安全感，最终掉进烟瘾的陷阱难以自拔。 &emsp;&emsp;当今社会缺乏有效阻止青少年染上烟瘾和其他毒瘾的手段，这一点让我非常痛心。我曾对这一问题进行过深入研究，也写过一本题为《不要让你的孩子吸烟》的书，介绍预防你的孩子染上烟瘾，以及帮助染上烟瘾的孩子戒烟的方法。统计结果显示，绝大多数青少年吸毒者都是从吸烟开始的。如果能预防你的孩子染上烟瘾，他们染上其他毒瘾的几率就会大大降低。在这一问题上，我求你万万不可掉以轻心。如果你是孩子的家长，我强烈推荐你阅读《不要让你的孩子吸烟》。即使你怀疑孩子有可能已经染上了毒瘾，该书也提一供了帮孩子摆脱毒瘾的有效方法。 第26章 秘密吸烟者&emsp;&emsp;秘密吸烟者应该归为轻度吸烟者一类，但因为秘密吸烟的危害性十分严重，所以专门用一章来讨论。秘密吸烟有可能导致人际关系破裂，我自己就曾因此差点离婚。 &emsp;&emsp;当时我尝试戒烟已经三个星期，当然，那一次的尝试最终失败了。之所以要尝试，是因为妻子担心我的咳嗽和喷嚏。我告诉她，我一点都不担心自己的健康。她说：“我知道你不担心，但假如哪个你深爱的人一点点地摧毁他自己的健康，你会是什么心情?”她的话让我难以争辩，所以才决定戒烟。三个星期之后，我重新开始吸烟，那是在与一位多年老友吵了一架之后。直到多年后我才意识到，那次争吵完全是我的潜意识在作祟。我绝不相信那是巧合，因为我之前和之后都从未与那位老友争吵过。很明显，那次争吵是烟瘾的作用。无论如何，我终于有了借口。吵完之后，我觉得非吸支烟不可，于是就点上了一支。 &emsp;&emsp;“戒烟让我的生活质量提高了很多。奇怪的是，现在我根本记不得吸烟究竟是什么滋味。”——李·W &emsp;&emsp;我不愿让妻子失望，所以就没告诉她。最初我只在没人的地方吸烟。慢慢地，我开始跟朋友们一起吸烟，最后所有人都知道我戒烟失败了，除了我的妻子。我当时十分得意，心里想：“至少这样一来，我的吸烟量就减小了不少。”妻子慢慢发现，我有时故意跟她争论，然后冲出房子，有时在门口的商店买东西要花上两个小时，还有时原本应该跟她一起，我却编造理由故意一个人离开。她最终拆穿了我的伪装。 &emsp;&emsp;随着吸烟者与非吸烟者之间的隔阂不断加深，越来越多的吸烟者开始背着亲友秘密吸烟。秘密吸烟的最大危害在于，这样做会加深吸烟者脑海中的错误印象，让他们坚信吸烟是一种享受，而戒烟则是剥夺这种享受。与此同时，秘密吸烟还会导致吸烟者的自尊严重下降，因为他们不得不欺骗最亲密的人。 &emsp;&emsp;或许你也曾经历过，或者你正在经历这样的情况。 &emsp;&emsp;我曾经历过不止一次这样的情况。这就像是《神探可伦坡》系列电视剧，每一集都差不多：谋杀犯总是一个道貌岸然的有钱商人，相信案子做得天衣无缝，而且发现案子是由其貌不扬的可伦坡主办时，他的信心还会更上一层。可伦坡每次结束调查时，总会先关门离去，还没等凶手脸上的得意笑容消失，他又会推门回来：“先生，还有一件小事，希望你能解释……”凶手开始愤怒地跺脚，从那一刻起，我们就知道可伦坡又取得了胜利。 &emsp;&emsp;无论剧中的谋杀案情节有多严重，我总是同情谋杀犯，因为我也曾有过相似的经历——每次秘密吸烟时，我都知道自己迟早会被发现。每次终于熬过几个小时的折磨，好不容易找到机会溜进没人的车库里，一边吸烟一边冻得发抖时，我都会想，这究竟算是什么?每次我都担惊受怕：她会不会发现我藏起来的烟盒、打火机和烟头?会不会闻到我身上的烟味?明知道她迟早会发现，我还是一次又一次地犯禁。而最终她真正发现时，我虽然感到无地自容，却又暗自高兴，这下就用不着遮遮掩掩了。 &emsp;&emsp;这就是身为吸烟者遭受的折磨! 第27章 吸烟是一种社会风气？&emsp;&emsp;自1960年至今，单在英国就已有超过150万人成功戒烟，这是社会风气转变的缘故。健康和金钱的确是我们戒烟的主要考虑，但这两点考虑一直都存在。用不着吸烟致癌的宣传，我们也清楚吸烟有害健康。单凭身体对烟味的反应，我们就知道香烟是有毒的。 &emsp;&emsp;我们当初会染上烟瘾，完全是因为社会的影响。历史上，吸烟曾经是社会地位的象征——这可以说是吸烟唯一真正的“益处”。然而在今天，吸烟通常被认为是一种反社会的行为，即使吸烟者自己也是这么认为的。 &emsp;&emsp;过去人们认为，吸烟是男人气概的象征，不吸烟的男人都算不上真正的男人。那时所有人都努力“学习 ”吸烟，在酒吧和俱乐部里，到处都是烟民们在吞云吐雾，弄得房间里乌烟瘴气，连新装修的天花板都会很快熏黄。 &emsp;&emsp;现在，这一切彻底改变了。现在的男人用不着再靠吸烟表现气概。男人并不是靠尼古丁这种毒品 成为男人的。 &emsp;&emsp;随着社会风气的变化，所有曾经坚定的吸烟者都开始考虑戒烟。目前普遍的观点是，吸烟者大多数是意志薄弱的人。 &emsp;&emsp;自1987年本书第一版问世以来，吸烟者的社会地位一直在下降。吸烟越来越被认为是一种反社会的行为。人们把吸烟当成绅士淑女身份象征的日子早就一去不复返了。现在每个人都清楚，吸烟者之所以还在吸烟，只是因为缺乏戒烟的能力和信心。在醒目的“禁止吸烟”标语之下，吸烟者只能缩着脖子，战战兢兢地生活。我曾见过有的吸烟者把烟灰弹进手心里，甚至是口袋里——只因为他们不好意思索要烟灰缸。 &emsp;&emsp;几年前的一个深夜，我坐在一家饭店里。用餐时间已经结束，但是没有一个人吸烟。我忍不住沾沾自喜：“我的工作已经取得了这么大的成效吗?”我问侍者：“这家饭店禁止吸烟吗?”侍者回答说“不是”。我想：“真奇怪。我知道现在戒烟很流行，但是这里人这么多，肯定有吸烟者在里面。”最后，不知什么人在角落里点起了第一支烟，瞬间引发了连锁反应，整个大厅里一下子充满了烟味。原来这里并不是没有吸烟者，只不过他们都在想：“我不能成为这里唯一抽烟的人。” &emsp;&emsp;现在，大部分吸烟者不会在等待上菜时吸烟。实在忍不住时，他们不仅会对同桌的人道歉，而且还会打量四周，看附近有没有可能批评他们的入。越来越多的吸烟者选择了戒烟，即使暂时没有戒烟的，心里也都在打退堂鼓。 &emsp;&emsp;希望你不会成为最后一个吸烟者! 第28章 戒烟的时机&emsp;&emsp;戒烟的时机选择十分重要。人们通常认为吸烟是一种有害健康的不良 习惯，这是错误的。吸烟不是习惯，而是尼古丁毒瘾，是当今社会的头号杀手。对绝大多数吸烟者来说，一辈子最倒霉的事情就是染上了烟瘾。在吸烟导致不可逆转的后果之前，你必须及时戒烟。为了确保戒烟成功，必须选择合适的时机。 &emsp;&emsp;首先问问你自己，什么时候你对吸烟的依赖性最强?如果你是一位商务人士，相信吸烟能缓解压力，那就选择压力相对较小的时候戒烟，比如休年假的时候。如果你相信吸烟能排解无聊，或是有助于放松，那就在相反的时候选择戒烟。无论是哪一种情况，一旦决定戒烟，就要严肃起来，把戒烟作为生活的第一要务。 &emsp;&emsp;留出三个星期作为戒烟期，因为尼古丁毒瘾的消退需要这么长时间。尽可能预先安排好戒烟期的生活，以免因意外原因导致戒烟失败，如参加婚礼、逢年过节等。在彻底戒烟之前，不要减少吸烟的量，因为减量只会让你产生幻觉，误以为吸烟是一种享受。事实上，强迫你自己增加吸烟的量，对戒烟反而有好处。开始戒烟之前，好好品味你的最后一支烟，记住那难闻的味道和糟糕的感觉。当你戒烟之后，就可以永远摆脱这样的感觉。 &emsp;&emsp;“我尝试戒烟已经不知多少次了，但每次总是失败，因为我总以为吸烟意味着放弃很多东西。现在我的感觉很好。”——希拉·M &emsp;&emsp;绝对不要简简单单告诉自己“现在不行，以后再说”，然后就把吸烟的事抛在脑后。现在就制定详细的戒烟计划，按计划安排生活。记住，戒烟不需要放弃任何东西。相反，你会收获许多。 &emsp;&emsp;我对吸烟这件事情的理解，可能比任何人都要深入。吸烟问题的关键在于：尽管吸烟完全是为了缓解尼古丁毒瘾，但是构成烟瘾的并不仅仅是生理上的毒瘾，更重要的是心理上的洗脑作用。尽管聪明人也有可能上当受骗，但只有傻瓜才会两次上同一个当。幸运的是，绝大多数吸烟者都不是傻瓜，他们只是误以为自己是傻瓜而已。每个吸烟者接受的洗脑内容都不尽相同，所以吸烟者才有前文描述的那么多类型。 &emsp;&emsp;自本书第一版问世之后，我积累了多年的读者反馈，对吸烟的本质也有了更深层次的理解，然而我惊讶地发现，本书第一版的指导巴想，直到今天仍然是正确的。这么多年来我取得的经验，主要是如何让吸烟者理解和接受这一思想。我知道，所有的吸烟者都能轻松戒烟，让戒烟过程成为一种享受。但是如果我不能说服吸烟者接受这一点，那这样的知识就毫无意义。 &emsp;&emsp;许多人都这样告诫我：“你告诉吸烟者‘读完这本书之前务必先继续吸烟’，这样吸烟者要么会故意放慢阅读速度，要么根本就不会读完。所以你最好改一改这条指示。”这样的话听起来很有道理，但要是我把指示改成“立即停止吸烟”的话，很多吸烟者根本就不会读下去。 &emsp;&emsp;曾有一位吸烟者告诉我：“我真的不情愿向你求助。我知道我的意志力很强。我能控制生活的每个方面，除了吸烟。为什么别的吸烟者都能靠自己的意志力戒烟，我却不行?”他又说：“我觉得，假如我在戒烟时还能吸烟的话，我肯定能成功戒烟。” &emsp;&emsp;他的话听起来有些矛盾，但我知道他是什么意思。我们总是把戒烟当成一桩难事。遇上难事时，我们通常的反应是什么?点起一支烟。这样一来，戒烟就成了双重的打击：我们不仅面临难事需要解决，而且还不能在解决过程中吸烟。 &emsp;&emsp;直到那人离开之后我才意识到，要求吸烟者在读完全书之前继续吸烟，其实是这本书最大的优点之一。阅读过程其实也就是戒烟过程，而在这一过程中能够吸烟的话，戒烟就不会带来双重的打击。吸烟者首先破除所有的怀疑和恐惧，然后再真正开始戒烟过程，这样最后一支烟刚一熄灭，他就可以立即享受戒烟后的生活。 &emsp;&emsp;只有在构思本章的过程中，我才怀疑过当初的指示是否正确。如果你通常在压力较大的时候吸烟，那最好选择，心情放松的假期戒烟，反之亦然。事实上，这并不是最容易的戒烟法。最容易的办法是选择你认为最难戒烟的时机——压力较大或者心情放松时，需要集中注意力或者无聊时，随你怎么选择。一旦你证明即使在这些时候你都用不着吸烟，那其他时候不吸烟就轻而易举了。但如果我这样指示你的话，你还能下定决心吗? &emsp;&emsp;举一个类似的例子。尽管我经常和妻子一起去游泳池，但却很少同时游泳。她总是用脚趾试试水温 ，然后再缩回来，要适应半个小时才敢下水。我则无法忍受这样的磨蹭。我知道无论水有多冷，迟早我都得下水，所以，我会采取最容易的方式：直接跳进水里。假如我坚持说如果她不跳进去，就永远没法开始游泳，那她就真的永远不会开始游泳。这就是问题所在。 &emsp;&emsp;我从反馈信息中得知，不少吸烟者都拿选择时机作为借口，故意拖延戒烟的那一刻。修改这本书的时候，我也曾想过采用这样的写作方法：上一章用“时机的选择非常重要，下一章我会详细阐述”这样的句子作为结尾，然后下一章只有两个字：现在。 &emsp;&emsp;事实上，这的确是最好的建议，但是你能接受吗?这是戒烟最微妙的地方。压力较大时，我们觉得不是戒烟的时机；压力较轻时，我们又缺少戒烟的动力。 &emsp;&emsp;扪心自问： &emsp;&emsp;当你吸第一支烟时，你是否决定了要吸一辈子烟? &emsp;&emsp;当然没有! &emsp;&emsp;那你会不会吸一辈子烟? &emsp;&emsp;当然不会! &emsp;&emsp;那你打算什么时候戒烟呢?明天?明年?后年? &emsp;&emsp;自从意识到自己染上烟瘾以来，你是不是经常问自己这几个问题?你是否还在幻想某天早上醒来，意外发现烟瘾自动消失了?不要自欺欺人。我等了33年，也没等到那一天的到来。尼古丁是一种毒品 ，毒瘾只会加重，绝对不会自动消失。你觉得明天戒烟会更容易?那你还是在欺骗自己。如果连今天都做不到，那你有什么理由相信自己明天能做到?难道要等到因吸烟而患上不治之症的那一天吗?到那时再戒烟还有什么意义? &emsp;&emsp;明天戒烟，并不比今天戒烟容易。 &emsp;&emsp;我们觉得生活充满了压力。事实并不是这样的，真正的压力早已远离我们的生活。现在你离开家时，完全不必担心会被野兽袭击，也不必操心能否吃到下一顿饭，能否找到遮风避雨的地方睡觉。想象一下野生动物的生活。兔子每次从洞里钻出来，都是冒着生命危险，但是兔子能够应付这种危险。它能分泌肾上腺素等一系列应激激素，提高逃离危险的能力——我们也能。事实上，对于任何生物来说，幼年都是生存压力最大的时期。但是经过30亿年的自然选择，我们已经拥有了化解生存压力的能力。第二次世界大战爆发时我刚五岁，我们居住的城市遭到轰炸，我和父母分开长达两年之久。我被分配到一间集体宿舍，其他孩子对我并不好。那是我生命中的一段陰暗经历，但我还是撑了下来。那段经历并没有对我造成任何永久性的伤害，相反，我变得更加坚强了。回首过去，我唯—对付不了的，就是烟瘾的奴役。 &emsp;&emsp;戒烟成功之前，我觉得生活真是糟糕透顶。我的心态完全是自杀性的——并不是说我会故意跳楼之类，而是说我本知道吸烟会让我送命，却还是不肯戒烟。当时我认定吸烟能帮我缓解压力，如果吸烟时的生活尚且如此不堪，那戒烟后的生活就完全不值得过下去了。我没有意识到的是，生理和心理处于低谷时，任何事情都有可能让我丧失信心。现在我又恢复了年轻时的心态，原因只有一个：我摆脱了烟瘾的奴役。 &emsp;&emsp;健康意味着一切。这种说法的确非常老套，却是不折不扣的事实。过去我总认为狂热的运动爱好者脑筋有问题。我总说生活并不仅仅是健康那么简单，吸烟饮酒都是生活的一部分。现在我已经意识到，当年的我实在愚不可及。只有身心都保持健康状态，你才能享受生活的高潮，直面生活的低谷。我们总是混淆责任与压力。只有当你身心孱弱，无力承担责任时，责任才会转化成压力。英国著名演员理查德·伯顿原本身心健康，没有被生活、工作和步人老年的压力击垮，却转而寻求吸烟的“支撑”，最后患脑溢血而死。不幸的是，像伯顿这样的人还有成百上千万。 &emsp;&emsp;不妨换个方式思考。你已经决定了这辈子迟早要戒烟，无论过程有多么困难。总有一天，你会摆脱烟瘾重获自由 。吸烟不是习惯也不是享受，只是一种毒瘾，一种心理疾病。我们已经分析过，“明天再戒烟”非但不会更容易，反而会越来越难。对于一种不断恶化的疾病，最好的治疗时机就是现在——或者至少是越快越好。三个星期的时间转眼就会过去，然后你就可以全心全意享受生活，心中再不会有怀疑的陰影。只要你按我的指示去做，戒烟甚至用不了五天时间。熄灭最后一支烟，你会发现，生活其实比你想象的更美好!]]></content>
      <categories>
        <category>这书能让你戒烟</category>
      </categories>
      <tags>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这书能让你戒烟]]></title>
    <url>%2F2020%2F06%2F30%2F%E8%BF%99%E4%B9%A6%E8%83%BD%E8%AE%A9%E4%BD%A0%E6%88%92%E7%83%9F-15-21%2F</url>
    <content type="text"><![CDATA[第15章 自愿的奴役&emsp;&emsp;社会洗脑造成的效应之一，就是让吸烟者自愿接受烟瘾的奴役。&emsp;&emsp;全人类曾为消灭奴隶制度奋斗过好几个世纪，然而吸烟者终其一生，都生活在烟瘾的奴役中。他似乎意识不到，每当吸烟的时候，他都情愿自己从来没有染上烟瘾。我们不仅无法享受吸烟的感觉，而且大多数时候，我们甚至意识不到自己正在吸烟。只有在一段时间没有烟抽之后，我们才会误以为吸烟是一种享受，比如早上第一支烟、饭后第一支烟等。 &emsp;&emsp;只有当我们决心戒烟，或是弄不到香烟，或是身处禁止吸烟的地方（学校、医院、超市、剧院、教堂等）时，才会觉得吸烟很重要。 &emsp;&emsp;吸烟者必须意识到，禁止吸烟的地方会越来越多。总有一天，任何公共场合都不允许吸烟。 &emsp;&emsp;过去吸烟者迈进朋友或陌生人家里时，还可以问一句“你介意我吸烟吗”？现在，社会礼仪已经不允许他开口，他只能绝望地打量周围，希望看到一个留有烟痕的烟灰缸。如果看不到，他只能强忍烟瘾，直到实在忍不住，不得不征求主人的同意。主人的回答有可能是“实在忍不住就吸吧”，也有可能是“最好还是不要，烟味很长时间都散不掉”。 &emsp;&emsp;“过去我以为自己只有靠吸烟才能直面压力。现在我知道，我面对压力的表现更好了。” ——珍妮弗?O &emsp;&emsp;可怜的吸烟者，原本已经感觉十分糟糕了，现在更是无地自容。 &emsp;&emsp;我还记得，在我还是个烟鬼时，每次去教堂做礼拜都是一场折磨。即使是在我女儿的婚礼上，我满心想的也都是“再忍一忍吧，等出了教堂门就自由 了”。 &emsp;&emsp;在这种时候观察吸烟者，会发现他们通常聚在一起，掏出自己的烟盒递给别人。他们的对话通常是： &emsp;&emsp;“你抽烟吗？” &emsp;&emsp;“是的，不过还是抽我的吧。” &emsp;&emsp;“下次再说。” &emsp;&emsp;两人点起烟深吸一口，心里想：“我们不是很幸运吗？这样的享受，不吸烟的人可体会不到。” &emsp;&emsp;不吸烟的人也不需要这样的“享受”，不需要用烟气毒害自己的身体。吸烟者的可怜之处在于，即使是正在吸烟时，他们也无法体会跟非吸烟者一样的感觉——自信、安详以及心灵的宁静。不吸烟的人每时每刻都在享受生活，不会在禁烟场所心烦意乱、坐立不安。 &emsp;&emsp;过去冬天打室内保龄球时，我经常假装上厕所，然后偷偷点一支烟。这样的事原本只有14岁的男孩子会做，而我却是个40岁的会计师。真是可怜！就算回到球场上，我也无法享受打球的过程，只是在强忍着等球打完，好重获“自由 ”。保龄球原本是一种休闲，却因为吸烟成为一种负担。 &emsp;&emsp;对我来说，戒烟的最大快乐就是，我终于可以自由 享受生活，不必再忍受烟瘾的奴役。不必再花一半的时间盼望着吸烟，另一半时间则一边吸烟，一边希望自己当初没有染上烟瘾。 &emsp;&emsp;吸烟者应该时刻记住，当他们在非吸烟者家里或禁止吸烟的场所忍受折磨时，折磨他们的并不是非吸烟者，而是尼古丁这个恶魔。 第16章 你真的不在乎钱吗？&emsp;&emsp;我已经重复过不知多少次，社会的洗脑是导致戒烟困难的主要原因。我们把洗脑的内容分析得越清楚，真正开始戒烟时就会越容易。 &emsp;&emsp;我偶尔会与一些吸烟者发生争论，这些人被我称为“重度吸烟者”。我对重度吸烟者的定义是：不在乎买烟的钱，不相信吸烟有害健康，也不担心吸烟有损形象。今天，像这样的吸烟者已经很少了。 &emsp;&emsp;如果他是个年轻人，我会说：“我不相信你真的不在乎花在吸烟上的钱。” &emsp;&emsp;通常他会眼睛一亮。如果我说的是健康或者社会形象方面的事，他可能会觉得有些吃亏，但是关于钱——“哦，我付得起。一周只要大概若干数量的钱，而且我认为这钱花得值。吸烟是我仅有的爱好。” &emsp;&emsp;如果他属于那种每天20支烟的吸烟者，我会说：“我还是不相信你完全不在乎。按你吸烟的速度，一辈子至少要花掉10万块钱。你为什么要浪费这些钱？就算把钱扔进垃圾箱，或者点火烧掉，也比花钱毒害自己的身体、摧毁自己的信心和意志、忍受烟瘾的奴役来得好。你难道真的不担心吗？” &emsp;&emsp;“你让我重新体验到了世界的美丽，让我的身体充满活力——23岁的年轻人本来应有的活力。” ——佐兰?K &emsp;&emsp;很明显，绝大多数年轻的吸烟者从未考虑过一辈子吸烟的费用。大部分吸烟者只知道一包香烟需要花多少钱。偶尔我们也会计算一周花在吸烟上的钱数，然后一般会十分吃惊。在十分偶然的情况下（通常是考虑戒烟的时候），我们会计算一年花在吸烟上的钱数，这通常是一笔大数目，但是一辈子——没有人会想到去计算。 &emsp;&emsp;不过，为了赢得这场争论，重度吸烟者会告诉我：“我出得起这笔钱。平均到每周也不过若干数量的钱而已。”他实际上是在自己说服自己。 &emsp;&emsp;然后我会说：“那我现在提个条件，你一定无法拒绝。你现在付给我2500元，我会一辈子替你买烟。” &emsp;&emsp;如果我以2500元的价格出售价值10万元物品的抵押权，吸烟者肯定会立即签字画押，然而却从没有一个重度吸烟者接受过我提出的条件，尽管他们从来没想过戒烟。为什么？ &emsp;&emsp;通常在对话进行到这种程度时，吸烟者会告诉我：“你知道，我其实不太在乎钱的事。”如果你也是这么想，问问自己为什么不在乎。为什么在其他方面你都精打细算，唯独不在乎花大笔的金钱破坏你自己的生活？ &emsp;&emsp;原因是这样的：在生活的其他方面，你的决定通常是权衡利弊的结果。或许某些决定并不正确，但至少是经过理性思考的。然而，假如吸烟者就吸烟权衡利弊，唯一的结论只能是“赶快戒烟！你是个笨蛋”！由此可见，吸烟者之所以吸烟，绝不是理性思考之后的决定，而是因为他们觉得自己无法停下来。他们对自己进行了洗脑，像鸵鸟一样把头埋进了沙子里。 &emsp;&emsp;奇怪的是，吸烟者彼此之间还会打赌，比如“谁第一个戒烟，就付给对方50元”。买烟的钱是50元的成百上千倍，他们却毫不在意。这是因为他们是在以洗脑后的方式思考。 &emsp;&emsp;擦亮你的眼睛。吸烟是一种连锁反应，如果你不主动戒烟的话，它会终生纠缠着你。现在估计一下，你这辈子还会因吸烟花掉多少钱。不同人的估计不尽相同，为了方便，我们先假定是15000元。 &emsp;&emsp;这样，你很快就会开始戒烟（现在还不行——记住之前的指示）。只要你不再掉进烟瘾陷阱，就算是戒烟成功。所以，一旦决定戒烟，就不要点起那第一支烟。否则，那一支烟就会花掉你15000元。 &emsp;&emsp;如果你认为这样的思考方法不合情理，那你还是在欺骗你自己。只要算一算，自打开始吸烟，你已经花掉了多少钱。 &emsp;&emsp;如果你同意这样的思考方法，那就不妨想一想，假如15000元突然从天上掉下来，你会是什么感觉。你肯定会高兴得跳起来！那就跳吧！因为这笔钱很快就要掉下来了——等到你读完本书开始戒烟的时候。这是戒烟带来的好处之一。 &emsp;&emsp;戒断期间，你或许会想再抽一支烟。如果你记得提醒自己，这一支烟要花15000元，或许就能更好地抵抗诱惑 。 &emsp;&emsp;之前提到的那个2500元的条件，我已经在电视和广播上提了许多年，至今没有一个吸烟者答应。我参加的高尔夫球俱乐部里也有人吸烟，每次他们抱怨香烟涨价，我就拿那个条件挑逗他们。不过我不敢做得太过火，生怕他们中真的有人答应——要是那样的话，我的损失可就大了。 &emsp;&emsp;如果你周围都是“快乐”的吸烟者，都说自己很享受吸烟的感觉，那就告诉他们你认识一个傻瓜，只要别人预付他一年的烟钱，就会终生替那个人买烟。或许你能找到一个愿意接受我条件的人？ 第17章 为什么要往最坏处想？&emsp;&emsp;这是洗脑作用最为严重的领域。吸烟者自以为了解吸烟对健康的危害，其实则不然。我自己以前就是这样，即使在整天头痛欲裂、担心自己突然死亡的日子里，我仍然在自欺欺人。假如在那段时间，我从烟盒里抽出一支烟的时候，一个声音突然对我说：“亚伦，这就是最后一支烟了！最后的警告：直到现在为止你都安然无恙，但只要你再抽一支烟，你的头就会真的裂开。”你觉得我会把烟点着吗？ &emsp;&emsp;如果你不能确定，可以走到交 通繁忙的大街上，闭上眼睛，想象你只有两种选择：或者戒烟，或者闭着眼睛横穿整条街。 &emsp;&emsp;你几乎肯定会做出第二种选择。所有吸烟者的精神状态都是这样：闭上眼睛，把头埋进沙子里，不去正视事实，而是幻想着某一天早上醒来，突然就不想吸烟了。吸烟者无法思考吸烟对健康的危害，因为一旦他们开始认真思考，连吸烟这个“习惯”提供的“享受”都没有了。 &emsp;&emsp;“过去，生活经常让我感到恐惧，我以为只有吸烟才能缓解这种恐惧。现在我发现，生活其实十分美好，完全没有什么可恐惧的。真的十分感谢你为我做的一切。” ——佩蒂?D &emsp;&emsp;正因如此，大众媒体上的戒烟宣传才几乎毫无效果。只有非吸烟者才会认真去看这些宣传。吸烟者只会对吸烟的危害性视而不见，因为他们无法承受事情的严重性。 &emsp;&emsp;每个星期大约六次，我会与吸烟者发生这样的对话（通常以年轻吸烟者为多）。 &emsp;&emsp;我：你为什么打算戒烟？ &emsp;&emsp;吸烟者：买不起烟。 &emsp;&emsp;我：那你不担心吸烟会损害健康吗？ &emsp;&emsp;吸烟者：当然不担心。或许我明天就会被车撞了。 &emsp;&emsp;我：你会故意被车撞吗？ &emsp;&emsp;吸烟者：当然不会。 &emsp;&emsp;我：那你过街之前会左右看看，确定没有车撞过来吗？ &emsp;&emsp;吸烟者：当然会。 &emsp;&emsp;的确是这样。吸烟者会努力做好预防措施，避免自己被车撞上，而且发生车祸的几率其实非常低。然而尽管吸烟百分之百会摧毁他们的健康，他们却完全不做任何预防。这就是洗脑的力量。 &emsp;&emsp;我还记得英国一位著名高尔夫球选手，因为害怕飞机失事，他拒绝去美国参加巡回赛，然而他在球场上却会一支接一支地吸烟。很奇怪，飞机失事的几率只有几十万分之一，我们就如此担心，而吸烟的致死率高达25%，我们却毫不在乎。那么，我们又能从吸烟中得到什么呢？ &emsp;&emsp;什么都得不到！ &emsp;&emsp;吸烟者很少清楚咳嗽的意义。许多年轻吸烟者都告诉我，他们并不担心健康问题，因为他们很少咳嗽。事实上，咳嗽并不是一种疾病，而是一种症状，是肺部排斥异物的自然反应。吸烟者的咳嗽，其实是肺部正在排斥致癌性的焦油和毒素。如果他们不咳嗽，焦油和毒素就会留在肺部，导致癌症等严重疾病。吸烟者通常很少运动，而且呼吸浅而急，目的是防止咳嗽。我过去曾以为，吸烟引发的咳嗽会让我丧命。事实上，正是咳嗽减少了我肺内的有害物质积累，或许我就是因此捡回一命。 &emsp;&emsp;你可以这样想：如果你有一辆好车却从来不开，任由它慢慢生锈，这样的做法显然非常愚蠢，因为等到车子锈掉就没有任何用处了。不过，只要有钱，你总可以买辆新车。你的身体就是载着你驶过人生的车子。我们都说健康是最宝贵的资产，这句话无比正确，问问那些身染陈疾的亿万富翁就知道了。我们许多人在患上严重疾病时，都会祈祷上天让自己早日康复。吸烟会让你的“车子”生锈，最终彻底报废——而你这一辈子只有这一辆“车子”。 &emsp;&emsp;运用你的智慧。你用不着这么做，而且吸烟对你一点好处都没有。 &emsp;&emsp;不要把头埋进沙子里。问问你自己，假如你很确定下一支香烟就会让你癌症发作，你还会不会把它点燃。不要想癌症本身（因为很难想象），只要想象你必须住院治疗，必须忍受放疗和化疗的痛苦。你所考虑的只是你的死亡，还不包括你的生活。你的亲友爱人该怎么办呢？你的计划和梦想呢？ &emsp;&emsp;我经常接触因吸烟患上癌症的人。他们也没想到会是这样的结果，而且最糟糕的还不是癌症本身，而是他们清楚，癌症完全是他们自找的。他们吸烟的时候，总是会告诉自己：“我明天就会戒烟的。”直到情势已无可挽回，他们才追悔莫及。癌症让他们看透了洗脑的本质，他们终于意识到所谓的“习惯”其实是怎么回事。在所剩不多的余生中，他们唯一的念头就是：“我为什么要欺骗自己，觉得自己非吸烟不可？要是再给我一次机会……” &emsp;&emsp;不要欺骗你自己。你还有机会。吸烟是一种连锁反应，如果你点燃下一支烟，就会点燃再下一支，直到为时已晚。 &emsp;&emsp;无数统计结果都显示，吸烟确实能对健康造成巨大的危害。问题在于，吸烟者并不愿意了解这些统计结果，直到他们决定戒烟为止。政府和大众媒体的戒烟宣传对他们毫无效果，因为他们具有“选择性失明”的能力。如果他们偶尔看见这样的宣传，第一个反应就是先点上一支烟。 &emsp;&emsp;很多吸烟者以为吸烟对健康的损害是“全或无”式的概率事件，就像踩地雷一样。记住：这样想是错误的，吸烟对健康的损害是积累性的。每次你吸进一口烟，肺部积累的致癌性焦油都会增加一点，而且癌症还不是吸烟能导致的最严重疾病。吸烟还是心脏病、动脉硬化、肺气肿、心绞痛、脑血栓、慢性支气管炎、哮喘等疾病的重要诱因。 &emsp;&emsp;我自己还吸烟的时候，从来没听说过动脉硬化或肺气肿这些病名。我只知道咳嗽、打喷嚏、哮喘和支气管炎症状是吸烟的结果。尽管这些症状给我造成了不适，但都在我的忍受范围之内。 &emsp;&emsp;我也不是没有过对肺癌的担忧，但这样的想法实在太过可怕，以至于每次一出现就被我赶出脑海。尽管吸烟的健康危害能造成极大的恐惧，但却完全被戒烟带来的恐惧淹没了。并不是说戒烟的恐惧更大，而是更直接，而对肺癌的恐惧却似乎是件十分遥远的事情。我们会反复告诉自己：为什么要往最坏处想？或许坏事情并不会发生。或许早在癌症发作之前，我已经成功戒烟了。 &emsp;&emsp;我们经常把吸烟想象成一件矛盾的事情。一方面，吸烟有害健康，浪费金钱，受人歧视，而且让我们得不到自由 ；另一方面，我们又认为吸烟是一种享受，是我们的爱好和精神寄托。我们从来没有想过，这些感觉其实都是恐惧导致的。我们并不是享受吸烟的感觉，只是无法忍受不吸烟的滋味。 &emsp;&emsp;想象一下，海洛因上瘾者如果得不到海洛因，该有多么痛苦，而当他们终于得到海洛因注射时，痛苦就会缓解。你能把这种暂时的缓解称为享受吗？ &emsp;&emsp;非海洛因上瘾者绝不会有这样的“享受”，因为他们原本就没有痛苦。痛苦是由海洛因导致的。非吸烟者也不会因无法吸烟而痛苦，只有吸烟者才会。他们的痛苦是由尼古丁导致的。 &emsp;&emsp;对肺癌的恐惧并没有让我戒烟，因为我当时以为吸烟如同穿过地雷阵，并不一定会踩到地雷。如果万一踩上了——至少我事先知道有这样的风险，如果我愿意冒险的话，跟别人又有什么关系？ &emsp;&emsp;所以，如果哪个不吸烟的人对我强调吸烟的风险，我就会用吸烟者典型的方法争辩： &emsp;&emsp;“所有人最后都会死。” &emsp;&emsp;——的确是这样，但这能成为故意缩短你生命的理由吗？ &emsp;&emsp;“生活质量比长寿更重要。” &emsp;&emsp;——一点都没错，但是这就等于是说，酒鬼或者海洛因上瘾者的生活质量，比正常人还要高？你真的认为吸烟者的生活质量比非吸烟者高吗？吸烟者不仅寿命更短，生活质量也会不断下降。 &emsp;&emsp;“或许汽车尾气对我肺部的损害比吸烟更大。” &emsp;&emsp;——就算是这样，这是进一步损害肺部的理由吗？假如有人把嘴凑到汽车排气管上，故意把有毒的汽车尾气吸进肺部，你会怎么想？ &emsp;&emsp;事实上，吸烟者就是这么做的！下次你看到哪个吸烟者叼着烟卷，不妨想象一下他嘴里含着汽车排气管的样子。 &emsp;&emsp;现在我完全能够理解，吸烟引起的不适和对肺癌的恐惧，但为什么这并没有让我戒烟。前者我能够忍受，后者我则拒绝思考。我的戒烟法绝不是靠恐吓来达到让你戒烟的目的，而是正好相反——让你意识到戒烟之后，你的生活会变得多么美好。 &emsp;&emsp;不过我的确认为，如果当初知道我的身体正在发生什么，我一定会戒烟的。我并不提倡把吸烟者肺部的彩色透视 照片拿给他们看，或者类似的冲击疗法。事实上，我从自己焦黄的手指和牙齿就可以推断，我的肺部一定好不了多少。但只要肺部还能工作，就不会像手指和牙齿一样让我难堪——至少没人能看见我的肺部。 &emsp;&emsp;而当时在我的身体里，血管正在逐渐被废物堵塞，肌肉和器官正面临缺氧，同时受到一氧化碳等有害物质的荼毒。这些有害物质绝不仅仅是来自汽车尾气，更主要的来源是吸烟。 &emsp;&emsp;与绝大多数开车的人一样，我绝不会在邮箱里加入杂质很多的汽油，更不会让化油器堵塞。如果你买了一辆全新的罗尔斯?罗伊斯，会故意使用杂质很多的汽油，导致化油器堵塞吗？吸烟者对自己的身体就是这么做的。 &emsp;&emsp;随着医学研究的进展，许多疾病都被发现与吸烟有关，如糖尿病、宫颈癌、乳腺癌等。我对此并不感到惊讶。烟草生产商的一贯说法是，吸烟能直接导致肺癌的说法，并没有系统的科学证明。 &emsp;&emsp;然而有了足够多的统计数字，还需要系统的科学证明吗？从来没有人用严格的科学方法对我证明，假如我用锤子砸自己的大拇指，就会感到疼痛。不过，只要有一次教训，我就知道绝不能这么做。 &emsp;&emsp;我并不是一名医生，但我仍然很快意识到，正如大拇指痛是因为被锤子砸到一样，我的咳嗽、肺病、哮喘、支气管炎等症状都是吸烟的缘故。不过我相信，吸烟对身体的最大危害还不是这些，而是对免疫系统的损害。 &emsp;&emsp;地球上所有的动植物都时刻暴露在细菌、病毒和寄生虫的威胁之下，而免疫系统就是它们对抗这些威胁的武器。传染病、感染等都是外来病原体入侵的结果，如果免疫机能足够强大，就可以消除这些病原体的影响。如果你的身体长期缺氧，还遭到一氧化碳和各种化学毒素的危害，你的免疫系统怎么能正常工作？事实上，与其说吸烟直接引发了各种相关疾病，不如说这些疾病都是免疫力下降的结果。 &emsp;&emsp;吸烟对我的健康造成了许多影响，其中有些影响是我在戒烟多年后才感觉到的。 &emsp;&emsp;当鄙视那些宁愿失去双腿也不愿戒烟的人时，我还没有意识到自己其实已经因吸烟患上了动脉硬化。我总以为自己脸色偏灰是缺乏锻炼的结果，从没想过，这样的脸色其实是毛细血管栓塞导致的。我30岁时患上了静脉曲张，戒烟后症状就自然消失了。戒烟前的五年里，我的双腿每逢夜里就有一种奇怪的感觉，不是疼痛，但就是无法安生。当时我妻子每天晚上为我按摩腿部。直到戒烟快一年时我才意识到，戒烟后我再也用不着她按摩了。 &emsp;&emsp;戒烟前的最后两年，我的胸部偶尔会剧烈疼痛，当时我很担心那是肺癌发作的表征。现在我觉得那更可能是心绞痛。戒烟后，疼痛再也没出现过。 &emsp;&emsp;小时候，每当皮肤擦破时都会流很多血，这让我非常害怕。当时没人对我解释，流血其实是伤口的自然消毒过程，之后伤口就开始愈合。我当时以为自己患了白血病，担心总有一天会流血而死。吸烟一段时间之后，我发现即使伤口很深，我也不怎么流血，而且流出的血液呈棕红色。 &emsp;&emsp;这颜色让我觉得非常不对劲儿。我知道血应该是鲜红色的，觉得自己可能是患了某种血液疾病。不过我并不担心，因为流血的程度没有过去严重了。直到戒烟成功之后我才意识到，吸烟会让血液变得黏稠，而棕红色是血液缺氧的表现。现在回想起来我还十分后怕，吸烟曾对我的身体造成如此严重的影响。每当想到我的心脏曾经不堪重荷，努力把黏稠的血液送往全身血管，一秒钟都没有停歇，我都觉得当初我没有心脏病发作，简直是天大的奇迹。我们的身体真是神奇，承受了如此严重的损害，居然还能自然恢复过来！ &emsp;&emsp;40多岁时，我的双手开始出现黄褐斑，像年纪很老的人一样。我以为这是自己开始步入老年的征兆，也就不以为然。五年后，我开起了自己的戒烟诊所，一位来求诊的吸烟者告诉我，过去他尝试戒烟的时候，发现自己手上的黄褐斑消失了。他的话提醒了我，到那时我才注意到自己的黄褐斑也消失了。 &emsp;&emsp;过去每当我站起身时，如果动作太快，就会感到眼花缭乱。洗澡时这种感觉尤其严重，我会感到头晕目眩，仿佛就要昏迷了一样。我从来没有把这种反应同吸烟联系起来，以为这是人人都有的正常反应。直到10年前一位戒烟成功者告诉我，他过去也曾有过这种反应，戒烟后就消失了，我才意识到我也是一样。 &emsp;&emsp;吸烟的最大危害之一在于，尼古丁能消磨我们的意志，同时又给我们以提高意志力的假象。我父亲曾说，他根本不打算活到50岁，这让我十分震惊。当时我完全没想到，20年后，我自己也出现了同样的厌世态度。自然，这都是吸烟的结果。我小时候十分恐惧死亡，所以当时我想，是吸烟帮我战胜了这种恐惧。然而事实却是，吸烟让我开始恐惧生活！ &emsp;&emsp;现在我对死亡的恐惧又回来了，但我并不在乎，因为我知道我现在终于能享受生活了。我并不会被对死亡的恐惧压倒，一如小时候一样。我的全部精力都放在享受生活上。尽管我很可能活不到100岁，但我会尽力尝试。我要享受生命中的每一分钟！ &emsp;&emsp;吸烟时，我几乎每天夜里都要做噩梦，梦见自己正被什么东西追逐。现在我只能假定，这样的噩梦是空虚感的结果，是尼古丁戒断症状导致的。现在我只有极少数时候会梦见自己又开始吸烟了——这是我现在唯一的噩梦。对于戒烟者来说，这种情况十分常见。有些人担心，这说明他们的潜意识仍然渴望着吸烟。其实，用不着担心，既然这样的内容只能在噩梦中出现，就说明戒烟后的生活是健康幸福的。况且，醒来之后你会发现，让你害怕的不过是一场噩梦而已。 &emsp;&emsp;此外，戒烟在另外一个方面，也为我提供了意想不到的好处。在诊所里跟吸烟者讨论吸烟与注意力之间的关系时，我偶尔会问：“你身体的哪一个器官最需要血液供应？”某些男患者立即表现出一副心知肚明的样子，还带着满脸傻笑，明显完全误会了我的意思。不过，他们的误会也不是没有道理。作为一个传统的英国人，我觉得这样的话题有点难堪，也不愿详细讨论吸烟对性功能的影响。不过戒烟后不久，我的确发现自己在这方面的能力有了显著的提升，或者应该说恢复。 &emsp;&emsp;如果你看过表现大自然的纪录片，就会意识到自然界的生物第一天的性是生存，第二天的性则是物种的生存，亦即繁殖。由于自然选择的作用，只有身体健康、食物供应充足、伴侣合适的生物，才具备繁殖的能力。人类具有社会性，所以并不完全受这一规则限制，不过我的确知道，吸烟有可能导致不孕或不育。戒烟后，你不仅身体更强健，性能力也会大大提高。 &emsp;&emsp;吸烟者经常会认为吸烟的危害性被夸大了。实际情况恰恰相反。吸烟毫无疑问是现代社会的第一大杀手。尽管吸烟是许多人死亡的直接或间接原因，但因为统计方式的关系，他们的死亡往往不会与吸烟联系起来。 &emsp;&emsp;据估计，约有44%的家庭失火是吸烟导致的。没有人统计过，究竟有多少交 通事故是在司机点烟时发生的。 &emsp;&emsp;我开车通常很小心，但有一次差点出事，当时我一边开车一边卷烟卷。我经常在开车时把嘴里的烟卷咳掉——似乎烟头每次都会烫坏车座。我敢肯定，许多吸烟者都经历过一只手控制方向盘、一只手在车座间摸索烟头的感觉。 &emsp;&emsp;社会洗脑作用对吸烟者的影响，就好比一个人正从100层的高楼上掉下来，却在经过第50层的时候说：“到现在为止还不错！”我们以为自己一直都很幸运，再吸一支也没关系。 &emsp;&emsp;不妨换个角度思考：每一支烟都会导致你继续抽下一支烟，你一辈子吸的烟可以连接成一条导火索。问题在于，你不知道导火索到底有多长。每当你点起一支烟，导火索就烧掉了一点，你离最终的大爆炸又近了一步。你怎么能知道爆炸会在什么时候发生？ 第18章 精力旺盛的感觉真好！&emsp;&emsp;吸烟会对肺部造成损害，这是绝大多数吸烟者都清楚的。吸烟还会导致精力下降，对于这一点，许多人就没那么清楚了。 &emsp;&emsp;吸烟陷阱的可怕之处就在于，吸烟对身体和精神的影响都是积累性的，以至于我们根本意识不到这些影响，还以为我们仍然处在正常状态。 &emsp;&emsp;这与不良 饮食习惯的影响十分相似。由于体重增加的速度很缓慢，我们完全感觉不到警惕。看到挺着啤酒肚的大胖子，我们总会想，他们怎么会任由自己的身体变成这样？ &emsp;&emsp;但是假设这一切都是一夜 之间发生的。假设你上床 时体重65公斤，肌肉结实，没有一点多余的赘肉。起床 时，你的体重变成了85公斤，浑身都是肥肉，还挺着圆鼓鼓的大肚子。一夜 的睡眠并没有恢复你的精力，反倒让你感觉昏昏欲睡，几乎睁不开眼睛。如果是这样，你一定会非常惊惶，不知道自己身上究竟发生了什么。不过，如果这样的变化历经20年，或许你完全注意不到。 &emsp;&emsp;吸烟也是一样。如果我能让你瞬间体验到戒烟三个星期后的身心状态，那我就用不着进一步说服你戒烟了。你会想：“我真的会感觉这么好吗？”反过来就是：“我现在的情况这么糟糕吗？”戒烟后，你不仅会感觉更健康，精力更充沛，而且更自信，更放松，感觉也会变得更加敏锐。 &emsp;&emsp;“过去我从来没有想象过，我居然可以一整天不吸一支烟。现在……我难以想象的是，我过去居然吸了那么长时间的烟，并且对戒烟心怀恐惧。” ——贝弗利?J &emsp;&emsp;年轻时我曾经很喜欢运动，但在染上烟瘾后的30多年里，我几乎忘记了运动的感觉。我每天都生活在疲劳和困倦中。每天上午九点我才挣扎着起床 ，晚饭后看着电视，五分钟之内就会打瞌睡。我父亲当年的生活状态也是这样，所以我并没觉得这样有什么不妥。我以为精力旺盛是孩子和青年人的专利，因为我的精力是从20多岁时开始下降的。 &emsp;&emsp;戒烟后不久，我的肺病和咳嗽症状都消失了，哮喘和支气管炎也不再发作。与此同时，我还体验到了另一种神奇的变化：我每天早晨七点钟起床 ，感觉精力充沛，浑身充满了活力，甚至希望能出门跑跑步或是游游泳。48岁的时候，我连一步都跑不动，游泳更不用提，能称得上锻炼的活动只有保龄球和高尔夫，而且打高尔夫的时候还得坐在电动车上。69岁的时候，我每天运动半个小时，还不包括游泳的时间。精力旺盛的感觉非常好，让我的生活充实了很多。 &emsp;&emsp;问题在于当你戒烟之后，这些变化也不是一夜 间发生的，而是需要时间——虽然远远没有你吸烟的时间那么长。如果你使用的是意志力戒烟法，或许在健康或经济状况方面的好转，会完全被戒烟法导致的沮丧情绪抵消掉。 &emsp;&emsp;不幸的是，我无法瞬间让你体会到戒烟三个星期后的感觉。但是你可以！只要相信我的话，那么你要做的就只有：动用你的想象力！ 第19章 放松与自信&emsp;&emsp;认为吸烟能让你放松，提高你的自信心，或许是最严重的错误。对我来说，戒烟的最大好处就是，我终于摆脱了烟瘾的奴役，再也不用在担惊受怕中生活。 &emsp;&emsp;吸烟者晚上外出时，如果身上带的香烟很少，就会产生莫名的不安全感。他们不知道的是，这种不安全感正是吸烟导致的。不吸烟的人就不会有这种感觉。 &emsp;&emsp;直到戒烟成功后几个月，我通过跟其他吸烟者交 流，才意识到吸烟对心理的影响。 &emsp;&emsp;戒烟前的25年里，我从未做过体检。购买保险时，我坚持选择“不接受体检”，尽管那样会提高保险费。我不喜欢医院、医生，甚至牙医给我的感觉也不好。我无法面对衰老、养老保险这样的话题。 &emsp;&emsp;过去我以为，这与我吸烟的“习惯”并没有关系，但是戒烟成功之后，我仿佛大梦初醒一般。现在我热切期待着每一天的生活。当然，生活中仍然有不顺心的事情，也有各方面的压力，但我有足够的信心面对这一切。生活中原本美好的内容，戒烟后更是锦上添花。 第20章 驱散你内心的阴影&emsp;&emsp;戒烟还有一个好处，就是可以驱散我们原有的心理陰影。 &emsp;&emsp;所有吸烟者心底都清楚，吸烟其实是一种愚蠢的行为。他们下意识地点起一支又一支烟，拒绝考虑这样做的严重后果。不过，他们的潜意识里其实已经留下了陰影。 &emsp;&emsp;戒烟的好处多种多样，其中一些是我还在吸烟时就清楚的，如保护健康、省钱、恢复身心自由 ，等等。不过，我偏偏拒绝了这些好处，而是专注于为继续吸烟寻找借口。 &emsp;&emsp;奇怪的是，每次尝试用意志力强行戒烟的时候，我都能找到最合适的借口。我无法把关于健康和金钱的担忧赶出脑海，但却可以对其他很多东西“选择性失明”。我已经提到过烟瘾的奴役——花一半的时间盼望着吸烟，另一半时间则一边吸烟，一边希望自己当初没有染上烟瘾。我也描述了恢复旺盛的精力带给我的喜悦。不过最让我快乐的还是，戒烟让我彻底摆脱了所有心理陰影——我不再觉得被人鄙视，不再需要对非吸烟者道歉。我重新获得了自尊。 &emsp;&emsp;绝大多数吸烟者并不是意志薄弱的人。即使在烟瘾最严重的时候，我也能控制生活的每个方面，除了吸烟本身。尽管明明知道吸烟会毁掉我的生活，我仍然无法自拔，这让我对自己充满了憎恶。成功戒烟后，我再看到其他吸烟者时——无论他们年轻还是年老，吸烟程度轻还是重——不仅不会羡慕他们，还感到深深的遗憾，因为他们仍处在烟瘾的奴役之下。 &emsp;&emsp;以上几章介绍了戒烟的好处。为了平衡起见，下面一整章的内容都用来介绍吸烟的好处。 第21章 戒烟的好处&emsp;&emsp;奇怪，怎么是空白？！]]></content>
      <categories>
        <category>这书能让你戒烟</category>
      </categories>
      <tags>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这书能让你戒烟]]></title>
    <url>%2F2020%2F06%2F30%2F%E8%BF%99%E4%B9%A6%E8%83%BD%E8%AE%A9%E4%BD%A0%E6%88%92%E7%83%9F-8-14%2F</url>
    <content type="text"><![CDATA[第8章 什么是戒断反应？&emsp;&emsp;我已经解释过，吸烟者认为吸烟是一种享受，能帮他们放松，或是能起到别的什么正面作用。这是一种错觉，吸烟的真正作用是对尼古丁戒断症状的暂时缓解。&emsp;&emsp;过去，吸烟曾经是社会地位的标志。不过，那样的时代早已一去不复返。如今，我们的潜意识整天都在接受暗示：在恰当的时机点上一支烟是一种享受。 &emsp;&emsp;你的毒瘾越深，对尼古丁的需求就越大。你越是困在吸烟的陷阱中不能自拔，就越相信吸烟其实是件好事。这一切都是悄悄发生的，你完全意识不到。每一天，你的感觉似乎和前一天并无不同。绝大多数吸烟者根本意识不到尼古丁毒瘾的存在，直到尝试戒烟的那一刻为止。就算意识到了，许多人也不会承认。少数死硬分子则采取鸵鸟般的态度，把头埋在沙子里自欺欺人，努力让自己和别人相信吸烟其实是一种享受。&emsp;&emsp;我曾与上百名青少年进行过这样的对话： &emsp;&emsp;我：你知道尼古丁是一种毒品 ，你吸烟的唯一原因是没办法停下来。 &emsp;&emsp;青少年：才不是呢！我喜欢吸烟。要不然我会停下来的。 &emsp;&emsp;我：那么你先停一个星期，向我证明这一点，好不好？ &emsp;&emsp;青少年：没有必要。我很享受吸烟的感觉。只要我想停下来，随时都可以。 &emsp;&emsp;我：先停一个星期，向你自己证明这一点。 &emsp;&emsp;青少年：何必呢？我是真的喜欢吸烟。 &emsp;&emsp;我已经说过，在压力、无聊、集中注意、放松等情况下，吸烟者会特别倾向于缓解戒断反应。接下来的几章将会详细讨论这一点。 第9章吸烟能释放压力？&emsp;&emsp;在这里，“压力”一词主要指生活中琐碎小事造成的压力——社交 、接电话、抚育小孩，等等。 &emsp;&emsp;以接电话为例。对大多数人来说，接电话是一件有压力的事情，对于商界人士尤为如此。绝大多数电话并不是满意的客户打来的，更不是老板专门打来夸奖你。电话铃声通常意味着某些事情并不顺利，不是什么东西出了问题，就是什么人提出了更多的要求。每逢这种情况，吸烟者都会先点起一支烟，再拿起话筒。他自己并不清楚这样做的原因，但是压力程度似乎的确减轻了。 &emsp;&emsp;实际上究竟发生了什么？吸烟者之前已经承受了一定的压力（尼古丁戒断症状），虽然他自己并没有意识到。在电话铃声造成压力时，如果通过吸烟缓解戒断症状造成的压力，吸烟者承受的总体压力就会下降，这并不是幻觉，而是千真万确的事实。不过，即使在吸烟过程中，比起相同状态的非吸烟者，吸烟者仍然承受着更大的压力。 &emsp;&emsp;我已经说过，这本书的内容不涉及冲击疗法。以下的例子并不是故意对你造成惊吓，只是为了强调，吸烟会摧毁你的意志。 &emsp;&emsp;“如果所有吸烟者都能抱着开放的心态读完这本书，所有的烟草公司都会倒闭，无数人的生活都会变得快乐得多。” ——卡罗尔?安妮?F &emsp;&emsp;假设你的烟瘾已经非常严重，医生告诉你如果不戒烟的话，他不得不手术切除你的双腿。假设他说的是实话，想象一下没有了双腿，你的生活会变成什么样子。再假设有这样一个人，尽管接到了如此的警告，仍然继续吸烟，直到双腿被切除为止。 &emsp;&emsp;我还是个烟鬼时，就曾听过许多类似的说法，每次都不屑一顾。我倒是很希望能有个医生对我这样说，那样我就能成功戒烟了。不过事实上，当时我完全清楚，我每一天都有可能因吸烟引发的脑溢血而死亡，那样损失的就不仅仅是双腿，还有更宝贵的生命。我并不认为自己疯了，只是烟瘾很重而已。 &emsp;&emsp;方才的假设并不是空穴来风。事实上，尼古丁对你身体的损害，几乎比失去双腿更加严重。随着烟瘾逐渐加深，你的意志和勇气也在悄悄流失。越是这样，你就越认为吸烟有助于提高意志和勇气，从而在烟瘾中陷得更深。许多吸烟者夜间外出时都会神经紧张，因为他们担心口袋里的香烟抽完。非吸烟者绝对不会这样。紧张感是尼古丁造成的。吸烟不仅会摧毁你的意志，还会毒害你的身体，让你的健康每况愈下。随着吸烟者的烟瘾越来越重，最终威胁到生命，他的误解也越来越深，对“吸烟能提供勇气”的说法深信不疑。 &emsp;&emsp;要看清问题的本质：吸烟并不会帮你放松，只会逐渐摧毁你的意志。戒烟可以帮你恢复意志力和自信。 第10章吸烟是因为无聊吗？&emsp;&emsp;如果你现在正在吸烟的话，很可能你根本没意识到自己嘴里的烟卷，直到看见这句话。 &emsp;&emsp;关于吸烟的另一种错误观念是，吸烟能够缓解无聊。无聊是一种精神状态。当你吸烟时，你的头脑并不会反复强调“我正在吸烟，我正在吸烟。”只有当你长时间没有烟抽，或是尝试戒烟时，才会真正意识到吸烟这件事情的存在。 &emsp;&emsp;真实情况是这样的：当你已经染上尼古丁毒瘾，而又没有吸烟时，就会产生戒断反应。如果你的注意力被某种东西吸引，同时又没有承受外来的压力，你通常不会有任何感觉。不过，当你无聊时，注意力就会自然而然地集中在戒断症状的感觉上，于是你就开始吸烟。而如果你没有戒烟欲望 的话，点烟的过程几乎是下意识的，即使对于抽烟斗和自制烟卷的人也是如此。绝大多数吸烟者无论怎么回忆，也想不起一天中的每根烟究竟是何时抽的，最多只能回忆起一小部分——比如早晨或者饭后的第一支烟。 &emsp;&emsp;“尼古清公司的一位代表曾对我说，按亚伦?卡尔的方法戒烟的人很容易分辨，因为戒烟真的能让他们感到开心。” ——尤娜?M &emsp;&emsp;事实上，吸烟是无聊的间接原因之一，因为尼古丁会引发嗜睡感，让吸烟者倾向于远离需要付出精力的活动，维持无所事事的无聊状态。 &emsp;&emsp;所以，必须根除“吸烟能缓解无聊”的错误观念。因为我们从小接受洗脑，认为吸烟能缓解无聊，所以当吸烟者在无聊时开始吸烟时，我们并不会感觉到惊讶。洗脑还让我们认为口香糖有助于放松。事实上，磨牙是人们承受压力时的自然反应。口香糖唯一的作用，就是给你一个磨牙的正当理由。下次你看到有人嚼口香糖时，仔细观察他的精神状态，看他究竟是紧张还是放松。无聊的吸烟者即使点起一支烟，精神状态仍旧很无聊，因为吸烟完全没有缓解无聊的作用。 &emsp;&emsp;身为一个曾经的烟鬼，我可以向你担保，一根接一根点燃香烟，每天重复这样的过程，是全世界最无聊的事情。 第11章 吸烟与注意力问题&emsp;&emsp;“吸烟有助于集中注意力”的说法，只不过是又一种误会。 &emsp;&emsp;需要集中注意力时，你会自动忽略其他感觉，如周围温 度的高低等。当一个吸烟者需要集中注意力时，因为“吸烟有助于集中注意力”的说法，他会点起一支烟，然后立即忽略自己正在吸烟的事实。 &emsp;&emsp;吸烟并不能帮你集中注意力，只会适得其反，因为香烟一熄灭，尼古丁戒断症状就会迅速浮现，逼你不得不分心，再点上一支烟。 &emsp;&emsp;此外，吸烟还会以另一种方式导致注意力分散。香烟中的毒素会使血液携氧能力下降，从而导致大脑供氧不足，使你难以集中注意力。 &emsp;&emsp;我自己使用意志法戒烟时，就是因为相信吸烟有助于集中注意力，才导致了最终的失败。不适感我可以忍受，但每当需要集中注意力的时候，我都非点上一支烟不可。我还记得，当初参加会计师认证考试时，考场不允许吸烟的规定让我几近抓狂。当时我已经染上了严重的烟瘾，觉得一连三个小时不吸烟的话，根本不可能专心思考。然而真正到了考场上，我全神贯注于答题，完全无暇考虑吸烟的事。那次考试我的成绩相当不错。 &emsp;&emsp;吸烟者在戒烟期间，之所以会感觉注意力难以集中，并不是戒断症状的原因。吸烟者遇上难以解决的问题时，就会习惯性地点上一支烟，尽管这对解决问题并没有任何帮助。吸烟者不会把任何问题归罪于香烟。他们认为自己不是因吸烟伤肺而咳嗽，只是经常感冒而已。然而一旦他们决定戒烟，却会把生活中的所有不如意归罪于戒烟这件事情。如果他们碰上难以解决的问题，就会想：“要是我点支烟的话，问题一定会迎刃而解。”这样他们就会开始质疑戒烟的决定。 &emsp;&emsp;如果你相信吸烟有助于集中注意力，担心戒烟会影响注意力，那么影响你注意力的其实是担心本身。问题的根源在于心态，而不是生理层面的戒断症状。记住：只有吸烟者才会出现戒断症状。 &emsp;&emsp;我最终成功戒烟时，每天的吸烟量从100支瞬间下降到0，对注意力并没有任何影响。 第12章 吸烟可以让人放松？&emsp;&emsp;绝大多数吸烟者相信吸烟有助于放松。事实上，尼古丁具有兴奋作用，会导致心率上升。 &emsp;&emsp;许多吸烟者都喜欢饭后点上一支烟。饭后是休息的时间，没有工作压力，也没有饥饿的折磨，可以全心全意放松。不幸的是，吸烟者无法利用这段时间放松，因为他还有另一种“饥饿”需要满足。他以为“饭后一支烟，赛过活神仙”，殊不知：让他无法放松的原因正是吸烟。 &emsp;&emsp;尼古丁上瘾者永远无法彻底的放松，而且毒瘾越深，程度就越严重。 &emsp;&emsp;世界上最不容易放松的人，可能就是有严重烟瘾的企业高层人员。他们连续吸烟，永远都在咳嗽，血压很高，而且很容易受刺激。到了这种程度，吸烟已经无法完全缓解尼古丁戒断反应了。 &emsp;&emsp;我还记得，当我还是个烟鬼时，如果家里哪个孩子做错了什么事，哪怕是很轻微的小事，我也会大发雷霆。当时我以为这是自己性格的缺陷，但现在我明白了，这其实是尼古丁的作用。当时我觉得整个世界天昏地暗，但现在回忆起来，那时承受的压力其实并不大。我能够控制生活的每个方面，唯一不能控制的就是吸烟。正是吸烟造就了我的恶劣脾气。吸烟者为吸烟行为寻找借口时，总是会说“哦，香烟能让我镇静下来，帮我放松”。 &emsp;&emsp;几年前，英国的收养机构曾考虑是否应禁止吸烟者收养孤儿。他们接到了一个吸烟者的电话，那人说：“你们完全搞错了。小时候，每当我有什么问题需要我母亲解决，总是等她点上一支烟，因为那时她会完全放松下来。”那么，在他母亲不吸烟时，他为什么无法同她交 流？为什么吸烟者不抽烟就无法放松？仔细观察他们的表现，尤其是没办法吸烟的时候，你会发现，他们有的把手放在嘴上，有的大拇指扭在一起，有的玩弄头发，有的磨牙，有的双脚乱动，总之都无法保持安静。他们早就忘了真正放松的滋味。 &emsp;&emsp;人们吸烟的过程，可以比作苍蝇被困在捕蝇草中的过程。最初是苍蝇吮吸捕蝇草的汁液，然后不知不觉间，就变成捕蝇草消化苍蝇了。 &emsp;&emsp;你难道不该早点挣脱捕蝇草的束缚吗？ 第13章 什么是综合性吸烟？&emsp;&emsp;不要单按字面意思，把综合性吸烟理解为同时抽两支烟甚至更多。曾经有一次，我嘴里叼着烟的时候就试图开始抽另一支烟，结果烫伤了手背。事实上，如果有人真的同时抽两支烟，那他的动机并不是不可理解。随着烟瘾的加深，戒断症状越来越难以缓解，普通强度的尼古丁刺激根本无法解决问题。即使嘴里正叼着烟卷，吸烟者仍然会出现戒断症状，于是会下意识地点起第二支烟。这也是许多烟瘾严重者转向其他毒品 的原因。不过，本章的主题不在于此。 &emsp;&emsp;所谓“综合性吸烟”，是指由多于一种原因导致的吸烟行为，如在社交 场合、聚会、婚礼、饭店等地吸烟。这些都属于既有压力又放松的场合，这两点看似矛盾，其实不然。任何形式的社交 都会产生压力，即使交往对象是很亲密的朋友，同时你又会觉得十分享受，彻底放松下来。 &emsp;&emsp;某些情况下，吸烟的四种诱因甚至能够并存。开车时就是这样的情况。如果你正开车离开某个让你很紧张的地方，如医院或牙医诊所，你会感觉十分放松。开车本身是一件很有压力的事情，你需要保证自己的生命安全，同时也需要集中注意力。或许你意识不到这两点因素，但它们的确存在于潜意识中。最后，如果堵车，或者在漫长的高速公路上驾驶，你就会感觉十分无聊。 &emsp;&emsp;另一个例子是打牌时的情况。玩桥牌或扑克牌时，你必须集中注意力。如果牌局有可能输掉，就会产生压力。如果你很久抓不到好牌，就会觉得无聊。而这一切都是在放松状态下进行的——打牌本身属于休闲娱乐的范畴。在牌局上，无论尼古丁戒断症状有多轻微，都会让吸烟者立即点起烟来，即使是轻度吸烟者也不例外。烟灰缸很快就塞满了烟头，牌桌周围萦绕着经久不散的烟气。如果你拍拍某个吸烟者的肩，问他是否享受这种感觉，他肯定会回答“你不是在开玩笑吧”。事实上，很多时候就是在刚刚经历过这样一夜 ，在喉咙痛和咳嗽中醒来的时候，我们才会决定戒烟。 &emsp;&emsp;考虑戒烟时，我们想得最多的通常是综合性吸烟的情况，担心如果在这样的场合不能吸烟，我们的生活会变得毫无可取之处。事实上，整件事的原理仍然相同：香烟只不过是暂时缓解了戒断反应。 &emsp;&emsp;让你感觉非抽支烟不可的，并不是香烟本身，而是当时的具体情况。如果能成功戒烟，你在这些情况下会更开心，更能抵抗压力。下一章会详细解释这一问题。 第14章 我究竟要放弃什么？&emsp;&emsp;什么都不用放弃！是恐惧让我们有如下担心：戒烟意味着放弃一些东西，少了一些生活的乐趣；我们可能会无法面对压力。 &emsp;&emsp;我们之所以会相信，我们需要吸烟，一旦戒烟就会导致某些方面的空虚，完全是社会洗脑的结果。 &emsp;&emsp;记住，吸烟并不能填补空虚，吸烟才是造成空虚的罪魁祸首！ &emsp;&emsp;我们的身体是地球上最复杂的东西之一。让我们的身体成为今天这样的，无论是全能的上帝也好，是自然选择也好，其效率远远超过了人类创造东西的效率。人类甚至无法造出最简单的细胞，更别提视觉、生殖、循环、思维等生理机能了。如果上帝（抑或自然选择）让我们的身体成为今天这样，是为了让我们能够吸烟，他（它）就会给我们相应的生理机能，让我们免受香烟中的毒素影响。 &emsp;&emsp;这样的生理机能当然并不存在。事实上，我们的身体拥有另一套机能，那就是闻到烟味时的咳嗽、头晕、恶心等反应。此类反应原来是为了提醒我们远离香烟，我们却反其道而行之。 &emsp;&emsp;吸烟不会提高生活质量，只会毁了我们的生活。吸烟会导致味觉和嗅觉下降，让我们无法享受美食。在饭店里，吸烟者会利用上菜的间隙抽烟。他们等不到饭局结束，因为吃饭时不能吸烟。尽管他们知道不吸烟的人很讨厌他们的做法，却还是忍不住要这样做。吸烟者并非不通情理，只不过是对香烟形成了依赖。他们面临的两种选择都十分糟糕：要么因为不能吸烟而痛苦，要么因为吸烟影响其他人、产生负罪感而痛苦。 &emsp;&emsp;在禁止吸烟的场所，许多吸烟者会借口上厕所，偷偷在远离人群的地方点起一支烟。这种做法清楚地表明，吸烟的本质其实是毒瘾。吸烟者之所以吸烟，并不是因为享受吸烟的感觉，而是因为毒瘾发作，不吸烟的话就会十分痛苦。 &emsp;&emsp;我们中的许多人都是在年少害羞的时候，为了应付社交 场合而开始吸烟的，所以我们形成了这样的印象，不吸烟就无法享受社交 的乐趣。这完全是无稽之谈。吸烟会破坏你的自信心，让你感觉到没来由的恐惧。许多吸烟的女性在社交 场合上尽管衣冠楚楚，嘴里却散发着烟臭。她们不是不想让自己的气味好闻一些——她们其实很讨厌自己头发和衣服的气味——但是即使这样，她们仍然会继续吸烟。这就是恐惧作用的结果。 &emsp;&emsp;吸烟无法帮你享受社交 的乐趣，只会起到相反的效果。一手抽烟，一手拿着酒杯，一边小心翼翼地弹着烟灰，一边还要注意不把烟气喷到别人脸上，心里猜测着别人是否能闻到你身上的烟味，是否注意到了你牙齿上的焦痕——这样的情况下何谈享受？ &emsp;&emsp;戒烟不会让你放弃任何东西，只会给你带来许多好处。对于吸烟者来说，戒烟的主要动机在于健康、金钱和社会形象方面的考虑。这些的确很重要，但我认为戒烟最大的好处是心理方面的，包括： &emsp;&emsp;?自信和勇气的回归。 &emsp;&emsp;?摆脱烟瘾的奴役，重获自由 。 &emsp;&emsp;?可以安心生活，不必担心别人瞧不起你，也不必瞧不起你自己。 &emsp;&emsp;戒烟之后，你的生活质量会有相当大的提升。你不仅更健康，更富有，而且更快乐，更能享受生活的乐趣。 &emsp;&emsp;以下几章会详细讨论戒烟的益处。 &emsp;&emsp;假设你得了一种怪病，脸上又痛又痒。我正好有一种特效药。我对你说：“试试这种药吧。”你把药涂在脸上，症状立刻就消失了。一个星期之后，症状复发。你问我：“药还有吗？”我把药瓶递给你：“留着吧，或许以后还用得到。”你涂了药，症状又消失了，然而每次复发都更痛，程度更重，间隔时间也更短。最后症状完全覆盖了你的脸，痛得难以忍受，而且每半个小时就复发一次。你知道涂药能暂时缓解症状，但你也非常担心，如果症状扩张到全身怎么办？复发间隔会不会越来越短，以至于最后完全没有间隔？你去找医生，可是他也治不了你的病。你尝试了很多别的方法，但是都没有效果，除了那瓶所谓的特效药。 &emsp;&emsp;现在，你已经彻底离不开特效药了，每当外出都随身带着一瓶。如果需要出远门，你就随身带上好几瓶药。不过我已经对特效药开始收费，每瓶100块钱。除了乖乖掏钱，你没有别的办法。 &emsp;&emsp;突然有一天，你在报纸上读到，你并不是唯一患上这种怪病的人，许多人都面临同样的问题。事实上，医学专家已经发现，特效药并不能治愈这种病，只能让病灶暂时缩回皮肤底下。症状之所以越来越重，就是长期用药的缘故。要想让症状彻底消失，唯一的办法是停止用药，症状会随着时间自然好转。 &emsp;&emsp;你还会继续用药吗？ &emsp;&emsp;停止用药需要意志力吗？如果你不相信报纸上的话，或许会犹豫一段时间，但是当你停止用药，发现症状确实有所好转时，你肯定再也不会买这种所谓的特效药了。 &emsp;&emsp;你的生活质量会下降吗？当然不会。你原本面临一个看似无法解决的问题，现在突然有了办法。即使彻底康复需要一年时间，但每一天症状都会减轻一点，每一天你都会想：“太棒了！我再也不用担心了。” &emsp;&emsp;我熄灭这辈子最后一根香烟时，心中的想法就是这样。这个例子中的怪病绝不是指肺癌、动脉硬化、肺气肿、心绞痛、慢性哮喘、支气管炎、冠心病这些疾病，这些只是怪病的并发症状。当然，它也不是金钱的浪费，不是呼出的臭味和焦黄的牙齿，不是嗜睡，不是咳嗽和打喷嚏，不是被别人瞧不起，也不是你自己瞧不起自己，这些都只是怪病的后果。怪病就是吸烟本身，是“我需要吸烟”这样的感觉。不吸烟的人就没有这样的感觉。吸烟的最大害处是让我们恐惧，而戒烟带给我们的最大好处，就是永远消灭这种恐惧。 &emsp;&emsp;成功戒烟时，我有一种醍醐灌顶的感觉。我忽然清楚地意识到：我吸烟既不是因为自己意志薄弱，也不是因为真的需要香烟。我吸烟是因为第一支烟让我产生了烟瘾，而之后的每一支烟都在加重这种烟瘾。我还意识到：我并不是唯一做这场噩梦的人，所有的吸烟者都在做着同样的噩梦，只不过程度没有我重而已。他们也像我过去一样，努力寻找着各种借口，为自己的愚蠢找借口。 &emsp;&emsp;自由 的感觉真好！]]></content>
      <categories>
        <category>这书能让你戒烟</category>
      </categories>
      <tags>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这书能让你戒烟]]></title>
    <url>%2F2020%2F06%2F30%2F%E8%BF%99%E4%B9%A6%E8%83%BD%E8%AE%A9%E4%BD%A0%E6%88%92%E7%83%9F%2F</url>
    <content type="text"><![CDATA[这书能让你戒烟 亚伦·卡尔，是一位事业有成的会计师，也是一位重度上瘾的老烟枪。长达33年的烟龄，每天100只烟，日益恶化的健康状况，使他几乎陷于绝望。1983年，他终于发现了“轻松戒烟法”，告别了烟瘾。从此，他立誓为这个世界解决吸烟问题。25年来，他通过自己的书籍和戒烟诊所，让全球1000万人成功摆脱了烟瘾的控制！ 如侵权，删帖删文请联系我 第1章：你的烟瘾比我还大吗？&emsp;&emsp;或许我应该先解释一下，我究竟有什么资格写这本书。我既不是医生，也不是心理学家，不过我认为我比他们更有资格。我的吸烟史长达33年，到了后期，我每天多则抽100支烟，少则六七十支。 &emsp;&emsp;我曾十几次尝试过戒烟，有一次甚至强忍了六个月没有犯禁。但是我并没有摆脱烟瘾，仍然会在旁边有人吸烟时情不自禁地凑上前去，想尽量多吸入一点烟气。乘火车的时候，我总是购买吸烟车厢的车票。 &emsp;&emsp;绝大多数吸烟者都会告诉自己：“我会在被烟瘾害死之前戒烟的。”烟瘾最严重的时候，我明知道自己正在迈向死亡，却完全无能为力。由于经常咳嗽，我整天都在头疼，随时都能感觉到大脑中的血管正在跳动。我是真的相信，那些脆弱的血管随时都会破裂，然后我就会因为脑溢血而死亡。即使这样，我仍然无法戒烟。 &emsp;&emsp;我一度想彻底放弃戒烟的努力，并不是因为我真的喜欢吸烟，某些吸烟者会用这样的理由欺骗自己，但我从来不会。我一直都很讨厌烟味，但我相信吸烟能帮助我放松，给我勇气和自信。每次尝试戒烟时，我总是感到非常痛苦，无法想象没有香烟的生活会是什么样子。 &emsp;&emsp;最终，妻子说服我去接受催眠治疗。我得承认，当时我对催眠疗法嗤之以鼻，因为对疗法的实际过程完全不了解，一听到“催眠”二字，想到的就是一个眼神犀利、表情陰鸷的家伙，手里拿着一个钟摆。吸烟者通常会产生的错觉，我几乎全部具备，除了一项：我并不认为自己是个意志薄弱的人。我能把握生活的每一方面，除了吸烟这一项。当时我以为催眠就是意志力的较量，尽管我不会主动抗拒（像大多数吸烟者一样，我还是真心希望摆脱烟瘾的），但也并不相信任何人能诱使我改变看法。 &emsp;&emsp;接受催眠治疗的过程似乎完全是浪费时间。催眠师要我做一些普通的事情，像举起胳膊之类。一切都并不神秘，我没有失去知觉，没有进入出神状态，至少我觉得我没有。然而疗程结束之后，我不仅停止了吸烟，而且还感觉颇为受用，即使是在戒断期间。 &emsp;&emsp;在你急忙跑去找催眠师之前，我必须澄清一个概念：催眠疗法只是一种交 流方式。如果催眠师与你交 流的是错误的信息，就不会给你任何帮助。我并不愿意批评为我治疗的催眠师，因为如果当时不去找他，我绝对活不到今天。然而，他的治疗并不是让我戒烟的决定因素，只是一个反面的刺激。我也并不反对催眠疗法；事实上，我们的诊所也将催眠疗法作为治疗方式之一。催眠是一种强大的交 流和说服工具，可以达到良好的正面效果，也可以产生毁灭性的负面效应。不要轻易接受催眠治疗，除非催眠师是由你尊敬信任的人推荐的。 &emsp;&emsp;承受烟瘾折磨的日子里，我相信我的生活离不开香烟，宁可死也不愿彻底戒烟。直到今天，仍有人会问我，我是不是偶尔会莫名其妙感到痛苦。答案是“从来没有”——情况正好相反，我现在的生活非常幸福。如果我因吸烟而死的话，临死时我是不会抱怨的。不过由于意料之外的幸运，我居然摆脱了生命中最大的梦魇，永远不用再做烟瘾的奴隶，任由自己摧毁自己的健康和生命。 &emsp;&emsp;我不是个神秘主义者，不相信魔法、秘术那一套。我接受过严谨的科学训练，所以当这一切魔法般降临在我头上时，我感到完全无法理解。我开始阅读有关催眠和吸烟的书籍，然而一切似乎都无法解释发生在我身上的奇迹：为什么成功戒烟是如此容易，而我过去却从来没有成功过？ &emsp;&emsp;我花了很长时间才考虑清楚，因为思考的顺序正好颠倒了。我无法理解的是为什么自己戒烟如此容易，而我实际上应该思考的，却是为什么大多数人戒烟如此之难——也包括过去的我在内。吸烟者对戒断期的痛苦谈之色变，但当我回忆最终戒烟的过程时，却发现自己完全没有经历过痛苦。事实上，戒断期的痛苦并不是生理层面的疼痛，而是精神层面的自我折磨。 &emsp;&emsp;如今，我把全部精力都投入帮人们戒烟的事业中，取得了不错的成绩。我曾亲自帮数千名吸烟者摆脱烟瘾。在此我必须强调：任何人的烟瘾都可以根除。我还没遇到过烟瘾比我还大的人。恐惧是让我们不断吸烟的根本原因：害怕一旦失去香烟，生活会变得缺少意义。事实与我们的恐惧恰好相反。戒烟不仅不会导致生活质量下降，还能让我们的身体更加健康，精力更加充沛，生活更加充实、更有情趣。 &emsp;&emsp;一切吸烟者都可以轻松摆脱烟瘾——包括你！你所需要做的，只不过是抱着开放的心态读完这本书。你越能理解书中的内容，戒烟的过程就越容易。即使你一句话都不理解，只要照着书中的指示去做，也可以轻松戒烟。最重要的是，你再也不会感觉到对香烟的需求了。到那时，你唯一不能理解的，就是你为什么吸了这么久的烟。 &emsp;&emsp;我必须首先提出警告，能导致轻松戒烟法失效的只有两种可能： 1.没有严格遵照指示。 &emsp;&emsp;本书中的许多指示非常绝对化，或许这会让你觉得很不舒服。比如，我会告诉你绝对不要采用减量法戒烟，或是糖果、口香糖等替代法（尤其是尼古丁替代法）。之所以这么绝对化，是因为我对这些方法十分了解。我并不否认，的确有不少人用这些方法达到了戒烟的目的，但他们成功的原因并不是方法本身。某些人甚至能在吊床 上做愛，但那绝对不是最容易的方式。这本书中的每一句话都是为了唯一的目的：让你的戒烟过程尽可能轻松，从而确保成功。 2.没有理解指示内容。 &emsp;&emsp;不要想当然。对这本书中的一切，以及你自己的观点和别人的态度，都要进行辩证思考。比如，如果你认为吸烟不过是一种习惯的话，不妨想想为什么别的习惯大多很容易改掉，然而吸烟虽然感觉并不好，代价高昂，还能引发疾病甚至死亡，却总是难以停止。 &emsp;&emsp;如果你觉得自己真的很喜欢香烟的气味，请扪心自问，生活中到底有多少东西是你更喜欢的，为什么你唯独离不开香烟，一想到戒烟就会心慌意乱？ 第2章 轻松戒烟法&emsp;&emsp;这本书的目的在于帮你进入合适的精神状态，让你的戒烟之旅变得不像攀登珠穆朗玛峰一样艰难，而是宛如乡间漫步一般轻松。戒烟之后，你不会羡慕身边的吸烟者，而是会感觉兴高采烈，仿佛大病初愈一般。在以后的生活中，每当你看到香烟都会纳闷，自己当初怎么会跟它们打那么久的交 道。看见吸烟者时，你心中只有同情，绝不会有一丝羡慕。 &emsp;&emsp;如果你是个吸烟者，并且尚未成功戒烟，那么在读完这本书之前务必保持原先的吸烟习惯。这条指示听起来似乎与主题矛盾，不过一定要严格照办。后文中我会详细解释，香烟其实对你并没有任何作用。事实上，吸烟的矛盾之一就在于，当我们点起一根香烟的时候，心里其实并不知道我们为什么要这样做。不过，让我们首先假设，无论你是否愿意，你相信自己已经染上了烟瘾。只要你相信这一点，就永远无法彻底放松或是完全集中注意力，直到点起一根烟为止。所以，在读完全书之前，不要过早尝试戒烟。在阅读的过程中，你的烟瘾会自然消退，太过着急可能会导致非常严重的后果。记住，一定要严格遵照本书中的指示。 &emsp;&emsp;“现在我知道，再没有什么东西能让我重新开始吸烟了。我永远不会再成为烟瘾的奴隶。自由 的感觉真好。” ——克莉丝?J &emsp;&emsp;20多年来的反馈信息表明，本书的读者们对这条指示意见颇大。我自己最初戒烟的时候，许多亲友也都跟风戒了烟，因为他们觉得，“要是这家伙都能行，那我也一定能。”后来，通过劝说和诱导，我逐渐让那些还没有戒烟的亲友们意识到，摆脱烟瘾是一件无比美好的事情。这本书最初出版时，我自己买下了许多本，送给那些仍然坚持吸烟的亲友。我相信，虽然书写得并不好，但是他们仍然会读，因为写书的是他们认识的人。几个月之后，我发现他们并没有读完，不禁很惊讶也很痛苦。我甚至发现，有一位和我关系最好的朋友不但没有读，还把我送他的书转手送给别人了。这让我感觉很受伤，但我那时尚未意识到，他们仍然对戒烟心存恐惧。恐惧的力量比友谊更大。我甚至差点因戒烟闹过离婚。我母亲有一次问我妻子：“你为什么不拿离婚威胁他戒烟？”妻子的回答则是：“如果我那样做，他真的会离婚的。”我不得不承认，她说的是实话：这就是恐惧的力量。现在我很清楚，许多吸烟者读不完这本书，是因为他们害怕读完之后就会远离香烟。某些人故意每天只读一行，以推迟那一刻的到来。我也清楚，许多吸烟者都是迫于亲友的压力才翻开这本书的。不妨换个角度思考：你究竟有什么可损失的？如果读完这本书之后你选择继续吸烟，那你的情况同过去并不会有什么区别。你不仅没什么可损失的，而且还有可能收获许多东西！ &emsp;&emsp;“我从来没有幻想过，我居然会主动想要放弃吸烟——而且在读完这本书之前，还必须故意压抑这种想法！” ——瑞切尔?C &emsp;&emsp;一个例外是，如果你已经一段时间没有抽烟了，并且不知道自己究竟算是个吸烟者，戒烟成功者还是非吸烟者，那么在阅读过程中请不要吸烟。事实上，如果你已经成功戒烟的话，这本书的任务就非常简单了：把你从一个普通的非吸烟者变成一个快乐的非吸烟者。 &emsp;&emsp;我的方法与普通的戒烟法原理正好相反。普通的方法是把戒烟的所有坏处列出来，然后告诉自己：“如果我能忍受足够长的时间，烟瘾就会最终消退。然后我就可以重新享受生活，不再做烟瘾的奴隶。” &emsp;&emsp;这的确是通常的逻辑，许多吸烟者每天都在用类似的方法尝试戒烟。不过，这样的方法很难成功，原因如下： &emsp;&emsp;1.停止吸烟并不是最重要的。每次你熄灭一支烟的时候，都算是停止了吸烟。或许你某一天会有充足的理由告诉自己“我不想再吸烟了”——所有吸烟者都曾这样告诉过自己，而且很多人的理由都比你更充足。问题在于第二天，第十天，第一万天，当你的理由不是那么充足时，如果手边碰巧有一支烟，你就会突然恢复之前的状态。 &emsp;&emsp;2.有关健康的担忧并无益处。我们的理性思维会说：“不要再这样下去了。你是个笨蛋。”但是事实上，担忧并不会帮我们戒烟，反而会使戒烟变得更难。很多人吸烟的原因是心情紧张。对吸烟者解释吸烟的危害，会让他们心情紧张，结果更加加重他们的烟瘾。伦敦皇家马斯登医院是全英国最先进的癌症治疗中心，院门前的烟头比任何一家别的英国医院都多。 &emsp;&emsp;3.除此之外，强调因吸烟的危害而戒烟，还有两重负面效应。首先，这样会制造一种感觉，戒烟似乎成了一种牺牲。你会觉得，只是为了摆脱这些危害，你才不得不牺牲吸烟的权利。其次，这样还会制造一种障碍，让我们无法理解停止吸烟的真正原因。最恰当的问题应该是：“我们为什么想要吸烟，或者需要吸烟？” &emsp;&emsp;轻松戒烟法的过程可以简单概括为：首先忘记原本的戒烟理由，然后再这样问自己： &emsp;&emsp;1.吸烟究竟有什么用？ &emsp;&emsp;2.我真的在享受吗？ &emsp;&emsp;3.我真的必须为了把烟卷叼在嘴里、让自己窒息而付钱吗？ &emsp;&emsp;事实真相是，吸烟一点用也没有。这句话绝不是说，吸烟的负面效应比正面效应要大；所有吸烟者都明白这一点。我的意思是，吸烟根本就没有正面效应。过去，吸烟还可算是高人一等的地位象征，而在今天，就连吸烟者自己也承认，吸烟是一种反社会的行为。 &emsp;&emsp;绝大多数吸烟者在吸烟时都会进行理性思考，但他们所谓的理性其实是错觉和幻想的结合。 &emsp;&emsp;我们必须消灭这些错觉和幻想。你会意识到，你其实并不需要放弃什么，因为根本没有什么可放弃的。戒烟不仅没有任何负面效应，而且有多方面的正面效应，健康只不过是其中之一。当所有的恐惧和错觉悄然消失时，当你意识到生活不会因缺少了香烟而变得更糟糕时，当你不再有任何失落感时，再回过头来考虑健康问题——以及其他传统的戒烟理由。只有这样，这些理由才会成为你的动力，推动你去追求真心想要的东西——自由 快乐的生活。 第3章 为什么戒烟如此之难？&emsp;&emsp;我已经解释过，之所以我会对戒烟发生兴趣，是因为我自己就曾是个烟鬼。我最终戒烟成功的时候，感觉相当神奇。之前我每次尝试戒烟，总是会导致长时间的抑郁，就算偶尔心情能轻松一下，第二天又会消沉下去。那种感觉就像是掉进了一个四壁光滑的坑，拼命想爬出来，却总是在看见陽光的那一刻滑回坑底。最终你会选择投降，点起一支烟卷，尽管你不知道为什么要这样。 &emsp;&emsp;在诊所时，我每次都会问来求助的吸烟者：“你愿意戒烟吗？”这似乎是个愚蠢的问题。所有吸烟者都愿意戒烟。如果你问一个烟瘾严重的人：“假如你可以回到染上烟瘾之前的时候，你还会开始吸烟吗？”他的回答必然是：“绝对不会！” &emsp;&emsp;问一个烟瘾十分严重，不相信吸烟会损害健康，不在乎其社会影响，而且完全买得起烟的人——这样的人并不多——“你鼓励你的孩子吸烟吗？”回答同样是：“绝对不会！” &emsp;&emsp;所有吸烟者都知道，吸烟并不是一件好事。最初我们的想法总是“我迟早会戒烟的，不过不是今天，等到明天再说。”最终，我们会在失望中怀疑自己的意志力，或是相信我们的生活离不开香烟。 &emsp;&emsp;我已经说过，问题不在于解释戒烟为什么很容易，而在于解释戒烟的困难。事实上，真正的问题在于解释人们为什么要吸烟，为什么在英国，最多时居然有60%的人口吸烟。 &emsp;&emsp;“我一直以为，一旦戒烟的话，我就不会像原来一样快乐和自信。你的书让我发现，戒烟之后，我会变得更快乐，更自信！” ——珍妮弗?O &emsp;&emsp;吸烟这件事情本身就是一个谜。我们之所以吸烟，是因为别人也在做同样的事情，但是所有这些吸烟者中，没人不认为吸烟是时间和金钱的浪费，没人不希望自己摆脱烟瘾。我们自己还是青少年的时候，总觉得吸烟是成年人才能享受的乐趣，所以才努力追求这种乐趣；而当我们自己成年之后，却又追悔莫及，总希望我们的孩子不要重蹈覆辙。 &emsp;&emsp;吸烟的成本相当高昂。每天吸20支烟的人，一辈子花在香烟上的钱多达10万元以上。而我们花这些钱做了什么？（要是点火把这些钱烧掉，可能还好一些。）我们花钱往自己的肺部填充致癌性的焦油，导致血液中毒，血管堵塞。我们花钱让肌肉和脏器得不到足够的氧气，令自己昏昏欲睡，提不起精神。我们花钱把自己变得肮脏不堪，满口烟臭，牙齿焦黄，浑身散发着令人讨厌的气息。我们花钱折磨自己。在不允许吸烟的场所（医院、学校、剧院、教堂、火车车厢等），我们总是痛苦不堪。而当我们离开这些场所，点起烟卷开始狂吸时，又会产生深深的负罪感。烟瘾就是这样，当我们吸烟时会觉得吸烟不对，不吸烟时又忍不住想吸。别人会认为我们低人一等，而我们自己也瞧不起自己。每当全国无烟日到来，每当接触到报纸和电视上的戒烟宣传，每当与不吸烟的人在一起，吸烟者总是会自惭形秽。承受了这么多痛苦和压力，我们又能从吸烟中得到什么？什么都没有！ &emsp;&emsp;快乐？享受？放松？激情？这些都是错觉，除非你认为故意穿上挤脚的小鞋，再把它们脱下来就算是享受！ &emsp;&emsp;我已经说过，真正的问题在于解释清楚，为什么人们要吸烟，为什么他们觉得戒烟如此之难。 &emsp;&emsp;或许你会说：“这些我都知道，但一旦染上了烟瘾，再想摆脱就难了。”但是为什么？许多吸烟者终其一生都在寻找答案，但却总是不得要领。 &emsp;&emsp;有人说，戒烟的难处在于戒断症状。其实，尼古丁的戒断症状非常轻（参见第6章），绝大多数吸烟者一辈子都意识不到自己尼古丁上瘾的事实。 &emsp;&emsp;有人说吸烟是一种享受，他们错了。吸烟者自己并不喜欢烟味。随便找个吸烟者问问，假如手边只有他不喜欢的牌子的香烟，他会不会拿来抽。如果别无他法，吸烟者甚至会把旧绳子点燃来抽。吸烟完全跟享受无关。我很享受龙虾的味道，但我绝对不会随身带着20只龙虾，就像在烟盒里塞上20支香烟一样。很多东西都能提供享受，但在我们无法享受这些东西时，却不会感觉到空虚。 &emsp;&emsp;有人试图寻找潜意识层面的原因，所谓的“弗洛伊德综合征”“复归于婴儿”之类，实际情况正好相反。绝大多数青少年开始吸烟，是为了假装成年人。如果真的在潜意识上“复归于婴儿”，我们就应该找个奶嘴来吮。 &emsp;&emsp;有人认为吞云吐雾能让鼻孔里产生火辣辣的感觉，这种感觉非常刺激，这样的理由同样站不住脚。如果火辣辣的感觉就能产生刺激，为什么不把燃烧的香烟塞进耳朵里？如果说这样做很荒唐，那把致癌性的焦油吸进肺部岂不是更荒唐？ &emsp;&emsp;有人说：“这样我手上才有事情做！”那为什么要把烟卷点燃？ &emsp;&emsp;“嘴里叼着烟的感觉很好。”为什么要把烟卷点燃？ &emsp;&emsp;“烟气进入肺部的感觉很好。”一点都不好——这种感觉又称为窒息。 &emsp;&emsp;许多人认为吸烟可以缓解无聊，这也是一种错觉。“无聊”是一种精神状态，香烟可没有任何有趣之处。 &emsp;&emsp;身为烟民的33年中，我的理由一直是，吸烟能让我放松，给我信心和勇气。我很清楚吸烟有害健康，而且成本高昂。我为什么不去医生那里，让他给我开点别的什么药物，帮我增加信心和勇气？因为我知道，他只会开出别的什么药物，绝不会让我继续吸烟。这只不过是个借口，绝谈不上理由。 &emsp;&emsp;有人说，他们吸烟是因为他们的朋友也吸。他们真的这么愚蠢吗？要是这样，他们最好现在就开始祈祷，他们的朋友不要把自己的头剁掉！ &emsp;&emsp;最终，大多数吸烟者会得出这样的结论：吸烟只不过是一种习惯。这并不算是解释，但当一切解释都无法成立的时候，这是唯一的借口。不幸的是，这种借口同样缺乏逻辑。我们的生活习惯总是在不断改变，唯独吸烟一成不变。相信吸烟是一种习惯，而习惯总是很难改，这是最大的误解。习惯真的很难改吗？在英国，我们习惯了靠左侧通行，但一旦去欧洲大陆 或者美国，我们立即就能适应过来。习惯并不难改。事实上，我们生活中的每一天都在改变旧的习惯，养成新的习惯。 &emsp;&emsp;如果说吸烟是一种习惯，那么这种感觉糟糕透顶、有害健康、浪费钱财、遭人恶心。我们全心全意想改掉的习惯，为什么偏偏改不掉？答案很简单，吸烟并不是一种习惯，而是尼古丁上瘾！ &emsp;&emsp;绝大多数吸烟者不了解毒品 上瘾的机制，所以才会觉得戒烟无比困难。他们的主要理由是，吸烟能给他们带来享受或寄托，放弃吸烟是一种牺牲。 &emsp;&emsp;而事实真相却是，一旦你理解了尼古丁上瘾的机制，以及你吸烟的真正原因，你就会停止吸烟——就这么简单——三个星期之后，你就会开始扪心自问，当初你为什么吸了那么久的烟，为什么你不能说服其他吸烟者：不吸烟的感觉多么好啊！ 第4章 险恶的陷阱&emsp;&emsp;吸烟是世上最为险恶的陷阱，是由人类和大自然共同制造的。我们为什么会在青少年时代掉进陷阱？因为有无数的成年人已经掉了进去。他们不是没有警告过我们，吸烟是一种恶心的习惯，不仅浪费金钱，最后还会要了我们的命；然而我们却把这样的警告当成耳边风，认为他们一定是把吸烟当成一种享受。吸烟的荒谬处之一就在于，要“学会”吸烟、染上烟瘾，其实并不是一件容易的事。 &emsp;&emsp;这个陷阱里并没有任何诱饵，我们并不是因为吸烟感觉良好才掉进去的，事实上第一支烟的感觉必然十分糟糕。如果第一支烟感觉良好，或许我们头脑里就会响起警钟，我们会意识到陷阱的存在。然而正因为第一支烟的感觉无比糟糕，我们才会以为自己绝不会染上烟瘾，在不知不觉中一步步走进陷阱。 &emsp;&emsp;一切毒品 都可以让人产生快感，香烟中的尼古丁是唯一的例外。男孩子开始吸烟的原因，通常是想表现出男子气概，就像屏幕上的电影 明星一样。然而当你点起第一支烟时，立刻就会忘掉所有的男子气概。你不敢吸气，一旦时间稍长，就会感到头晕目眩，然后是一阵恶心。你唯一的愿望就是离开伙伴们，把手中的香烟丢得远远的，但你却尽力克制这样的愿望。 &emsp;&emsp;女孩子开始吸烟的原因，则通常是想表现得成熟一点。我们都见过未成年的女孩子小口小口吸着香烟，一副煞有介事的样子。等到男孩子真的培养起男子气概、女孩子真正成熟的时候，他们就会后悔当初的愚蠢。我不知道，究竟是吸烟真能让女性显得成熟，还是这只是烟草公司宣传出来的效果。据我所见，从初学吸烟者到吸烟方面的“专家”，中间似乎没有任何过渡。 &emsp;&emsp;在我们的余生中，我们努力警告自己的孩子，不要重蹈我们当年的覆辙。偶尔我们也会努力尝试，想从烟瘾的陷阱中挣脱出来。 &emsp;&emsp;然而，只有当我们感觉到压力时，才会想到尝试挣脱，无论这压力是来自健康问题，家庭经济问题，还是别人的看法和态度。 &emsp;&emsp;我们一旦停止吸烟，压力不但不会减小，反倒还会进一步增加（因为尼古丁上瘾的戒断症状），而我们只习惯一种缓解压力的手段，那就是吸烟。 &emsp;&emsp;忍受了几天的痛苦折磨之后，我们开始觉得时机不对，不应该在这时候戒烟，而应该等到没有压力的那一天再进行尝试。一旦产生这样的想法，戒烟的动力就会完全消失。自然，那一天永远不会到来，因为我们总是认为，我们生活中的压力会随着时间增加。离开家长的保护之后，我们会按照常规建立自己的家庭，抵押买房，生养儿女，追求事业的发展，等等。事实上，这是一种错觉。人类一生中压力最大的时期，实际上是童年和青少年时期。“责任”与“压力”很容易混淆。事实上，吸烟者的生活压力之所以会逐渐增加，是因为吸烟并不能真的帮你放松，更不能缓解压力。情况正好相反：吸烟会让你神经紧张，增加你承受的压力。 &emsp;&emsp;吸烟者即使停止吸烟（许多人都这样做过，有的只有一次，有的有许多次），过上正常的生活，也有可能突然重新染上烟瘾。 &emsp;&emsp;吸烟这件事情仿佛是一座巨大的迷宫，我们一进入迷宫内，头脑就会变得糊里糊涂，尽管努力寻找，却总也找不到迷宫的出口。有些人幸运地找到了出口，却莫名其妙地再次误入。 &emsp;&emsp;寻找出口的过程花了我整整33年。与其他吸烟者一样，我当时并不明白个中机制。不过，由于种种幸运与巧合，我碰巧发现了真正的出口。我想知道为什么戒烟如此之难，而当我找到答案的时候，蓦然发现，其实戒烟是一件非常简单的事情。 &emsp;&emsp;成功戒烟之后，我开始努力研究烟瘾陷阱的本质。我发现，这个问题极其错综复杂，仿佛顺序被打乱的魔方一般。不过，我最终拼出了魔方的图案，答案其实十分简单！我找到了轻松戒烟的有效方法。我会手把手领你走出迷宫，让你永远不会再次误入。你需要做的事情很简单：严格遵照本书中的指示。哪怕一个小小的失误，也会导致很严重的后果。 &emsp;&emsp;任何人都可以轻松戒烟，但是首先必须知道一些事实。我并不是指吸烟的危害性。我知道你对吸烟的危害性很清楚，因为相关的宣传已经太多太多了。如果那些宣传能帮你戒烟的话，你早就戒烟成功了。我的意思是，我们为什么会认为戒烟是一件难事？要回答这个问题，我们必须首先弄清楚，我们究竟为什么要吸烟。 第5章 我们为什么要吸烟？&emsp;&emsp;我们开始吸烟的理由多种多样，然而一旦开始，我们就会一直吸下去。 &emsp;&emsp;为什么？ &emsp;&emsp;我们为什么要吸烟？ &emsp;&emsp;没有一个吸烟者知道自己吸烟的真实原因。如果他们知道，就不会再吸烟了。在我们的诊所里，我曾对数千名吸烟者问过这个问题，他们的答案千奇百怪，但都与事实相去甚远。 &emsp;&emsp;所有吸烟者内心深处其实都清楚，他们犯了一个愚蠢的错误：在染上烟瘾之前，他们原本没有任何吸烟的必要。他们几乎都能记得，第一支烟的味道无比糟糕，他们是经过痛苦的努力才“学会”吸烟的。最让他们伤心的是，不吸烟的人什么都没有缺少，并且还嘲笑他们。 &emsp;&emsp;不过，吸烟者同样是有智力、能进行理性思考的人类。他们很清楚，吸烟不仅对他们的健康造成了巨大的危害，而且也严重浪费了他们的钱财。他们需要一个合理的解释。 &emsp;&emsp;事实上，导致我们吸烟的因素只有两种，我会在接下来的两章中分别讨论。两种因素分别是： &emsp;&emsp;1.尼古丁上瘾； &emsp;&emsp;2.洗脑。 第6章 尼古丁上瘾&emsp;&emsp;尼古丁是一种无色油状物质，是导致烟瘾的元凶，也是上瘾速度最快的毒品 。许多人只须抽一根烟，就会引起尼古丁上瘾。 &emsp;&emsp;你每次吸一口烟，都会有少量的尼古丁通过肺部进入大脑，其传导和作用速度比静脉注射海洛因更快。 &emsp;&emsp;如果一支烟用了20口才吸完，那么你的大脑就会受到20次尼古丁刺激。 &emsp;&emsp;尼古丁是一种代谢奇快的毒品 。吸烟后半个小时，血液中的尼古丁含量就会下降50%，再过半个小时就会下降到25%。这就是大部分吸烟者每天吸20支烟的原因。 &emsp;&emsp;每当吸烟者抽完一支烟，血液中的尼古丁含量就会迅速下降，很快就会引发戒断症状。 &emsp;&emsp;在这里，我有必要解释清楚戒断症状的概念。吸烟者经常认为，戒烟时出现的痛苦感觉就是戒断症状。事实上，这种痛苦主要是精神上的，是吸烟者心理作用的结果。关于这一问题，下文还会详细讨论。 &emsp;&emsp;“感谢你的远见卓识和幽默感，你几乎把一切都预料到了。读这本书的时候，我有好几次都笑出声来。” ——J?桑德斯夫人 &emsp;&emsp;尼古丁本身的戒断症状十分轻微，绝大多数吸烟者一直到死都不会意识到，他们自己与吸毒者其实没有区别。我们听到“尼古丁上瘾”这个说法时，总以为我们不过是“养成了吸烟的习惯”而已。绝大多数吸烟者对毒品 都充满恐惧，却不知道尼古丁正是一种毒品 。幸运的是，尼古丁比其他毒品 更容易戒掉，不过你得首先接受自己养成毒瘾的事实。 &emsp;&emsp;尼古丁戒断并不会导致生理上的疼痛，唯一的症状是心理上的空虚感，似乎有什么东西不见了，所以许多吸烟者才认为，吸烟是为了“让手上有点事情做”——也就是排解这种空虚感。如果这种感觉长期持续，就会导致吸烟者神经紧张，没有安全感，容易激动，自信心和自制力下降。这种感觉其实是身体对尼古丁的饥渴。 &emsp;&emsp;点着香烟后七秒钟之内，吸烟者就会得到新的尼古丁供应，于是空虚感消失。吸烟者会产生放松和自信的感觉，因为这两种感觉正是他们先前所缺失的。 &emsp;&emsp;我们最初开始吸烟时，戒断症状非常轻微，几乎无法察觉。当我们开始养成经常吸烟的习惯时，由于不了解戒断症状的机制，我们会误以为自己真的喜欢上了吸烟，或是养成了“习惯”。事实真相是，我们的尼古丁毒瘾越来越重，越来越需要经常满足。 &emsp;&emsp;所有吸烟者都是因为某个愚蠢的理由才开始吸烟的。吸烟并不是一种需要。吸烟者们之所以要经常吸烟，是为了满足尼古丁毒瘾。 &emsp;&emsp;“与上一次戒烟的情况不同，我并没有做噩梦，没有失眠，也没有情绪低落。事实正好相反——我感觉仿佛重获了新生。” ——玛莎?F &emsp;&emsp;所有吸烟者内心深处都清楚，他们犯了一个愚蠢的错误，掉进了烟瘾的陷阱。最可悲的地方在于，他们误以为吸烟能给他们放松和自信的感觉，殊不知这些感觉正是被尼古丁戒断症状所剥夺的，吸烟只是暂时满足毒瘾、缓解戒断症状而已。 &emsp;&emsp;你曾经一定有过这样的感觉：如果邻居家的防盗警铃响了一整天，然后突然被关掉了，整个世界都会瞬间变得无比安宁。事实上，这并不是安宁，只不过是烦心事的终结。 &emsp;&emsp;我们的身体原本是完整的。开始吸烟之后，我们放任尼古丁进入身体，一旦烟卷吸完，体内的尼古丁含量就会迅速下降。戒断症状——不是生理上的疼痛，而是心理上的空虚感——让我们的身体不再完整，让我们渴求尼古丁的作用。我们的理性无法解释这种渴望，也完全没有必要。我们只知道自己想要再吸一支烟，一旦点燃烟卷，渴望就会自行消失。我们会恢复正常的状态，就像没有染上烟瘾前一样。不过，这种状态只是暂时的，一旦烟卷熄灭，整个周期就会重新开始，周而复始，永远没有穷尽——除非被我们主动打破。 &emsp;&emsp;我曾做过这样的比喻，吸烟就如同故意穿上挤脚的小鞋，再把它们脱下来，享受片刻的安慰。吸烟者之所以意识不到这一点，主要有三点原因： &emsp;&emsp;1.自打生下来开始，我们一直在接受别人和社会的洗脑，我们误以为吸烟者真的享受吸烟的过程，而且离不开香烟。我们为什么要怀疑这一点？如果不是这样，吸烟者为什么要冒那么大的风险、花那么多钱吸烟？ &emsp;&emsp;2.尼古丁戒断症状不会产生生理上的疼痛，只会引发心理上的空虚感，与饥饿或压力的感觉类似。所以当我们点起香烟的时候，并不会觉得有什么不妥。 &emsp;&emsp;3.吸烟者之所以意识不到吸烟的本质，最重要的原因是，戒断症状只有在不吸烟的时候才会发作。由于症状并不重，在烟瘾形成的早期尤为轻微，我们总是将之误认为正常的反应，无法把症状与之前的吸烟行为联系起来。吸烟越频繁，戒断症状就越不容易发作，我们神经紧张和信心下降的程度有所缓解，却把这种作用归结为香烟的功效。 &emsp;&emsp;一切毒品 都很难戒掉，正是因为这第三点原因。如果一个海洛因上瘾者得不到海洛因，必然会痛苦不堪。一旦他给自己注射一针海洛因，这种痛苦就会立即消除。他能从注射的过程中得到快乐吗？对于没有海洛因毒瘾的人，海洛因就不具备消除痛苦的作用，反而会引发痛苦。同样，对于不吸烟的人来说，吸烟并不能缓解尼古丁戒断症状，所以他们也无法理解，吸烟者究竟能从香烟中得到什么快乐，而吸烟者自己同样无法理解。 &emsp;&emsp;我们经常说，吸烟能帮助我们放松，让我们感到满足。但是如果没有不满足，又何来满足？如果没有紧张，又何来放松？为什么不吸烟的人就不需要这样的放松和满足？为什么吃完一顿饭之后，不吸烟的人可以直接放松下来，而吸烟者却需要点起一支烟才能让自己“放松”？ &emsp;&emsp;尽管这句话我已经说过很多次，但还是要再重复一遍：吸烟者之所以感觉戒烟很难，是因为他们以为戒烟意味着放弃很多东西。你必须明白，其实你并不需要放弃任何东西。 &emsp;&emsp;要理解尼古丁上瘾的本质，可以把吸烟与吃饭进行对比。如果我们养成按时就餐的习惯，在非用餐时间就难以察觉到饥饿。如果某一顿饭没有按时吃，我们就会感到饥饿。即使如此，我们也不会有生理上的疼痛，只有一种心理上的空虚感：“我需要吃饭。”于是，吃饭的过程就成了一种享受。 &emsp;&emsp;吸烟的原理也是这样。尼古丁戒断产生的空虚感，同饥饿的感觉几乎完全一样：同样没有生理上的疼痛，同样难以察觉——只要我们像按时就餐一样“按时”吸烟。只有当我们想吸烟却没得吸时，才会意识到空虚感的存在。只要点起一支烟，空虚感就会消失，于是吸烟的过程也仿佛成了一种享受。 &emsp;&emsp;正因为吸烟与吃饭如此相似，吸烟者们才会产生错觉，以为吸烟能带给他们真正的享受。许多吸烟者初次听到吸烟没有任何正面效应的说法时，都会觉得难以接受。有人会说：“吸烟怎么会没有正面效应？当我点起一支烟时，感觉就不会那么紧张，这还是你告诉我的。” &emsp;&emsp;尽管吸烟与吃饭有许多相似之处，但其本质则完全相反： &emsp;&emsp;1.我们吃饭是为了生存，而吸烟则会减少我们的寿命。 &emsp;&emsp;2.食物通常味道不错，吃饭的确是一种享受，而烟卷的气味非常恶心，并且吸入肺部会导致窒息。 &emsp;&emsp;3.吃饭不会导致饥饿，只会缓解饥饿。吸烟会导致身体对尼古丁产生需求，然后再为身体提供尼古丁，暂时缓解这种需求。 &emsp;&emsp;接下来，我们要讨论另一种常见的错误观念——吸烟是一种习惯。吃饭是习惯吗？如果你认为是，那么改掉这个习惯如何？把吃饭定义为习惯，如同把呼吸定义为习惯一样荒唐。二者都是生存所必需的。的确，不同人的用餐习惯和食谱不尽相同，但是每个人都需要吃饭。吃饭本身并不是习惯。吸烟也不是。吸烟者点燃香烟的目的是缓解尼古丁戒断症状，而这症状正是由吸烟导致的。的确，不同吸烟者的吸烟方式和嗜好品牌不尽相同，但是吸烟本身并不是习惯。 &emsp;&emsp;人们总是把吸烟称为习惯，在这本书里为了方便，我有时也会使用“吸烟习惯”这种说法。不过，你一定要随时意识到，吸烟绝对不是习惯，而是毒瘾的一种！ &emsp;&emsp;我们最开始尝试吸烟的时候，必须下很大努力才能“学会”。然而突然之间，我们不仅开始养成吸烟的习惯，而且离了香烟就会心烦意乱。随着时间的流逝，我们对香烟的依赖也与日俱增。 &emsp;&emsp;这是因为身体会对尼古丁产生耐受性，从而增大对尼古丁的需求。上一支烟熄灭后没多久，尼古丁戒断症状就会渐渐浮现，逼你再点起一支烟。你的感觉的确比方才要好，但相比正常状态仍然糟糕得多。吸烟比穿小鞋更为荒谬，因为即使你远离香烟，仍然会遭到戒断症状的折磨——而小鞋一脱下来就不再痛苦了。 &emsp;&emsp;之前我已经解释过，血液中尼古丁水平的下降速度非常快。正是由于这个原因，在压力较大的时候，许多吸烟者才会连续吸烟。 &emsp;&emsp;吸烟并不是一种习惯。人们吸烟的真正原因是尼古丁上瘾，必须经常接受尼古丁的刺激。在四种情况下，吸烟者最倾向于寻求尼古丁刺激，这四种情况分别是： &emsp;&emsp;无聊/集中注意——二者正好相反！ &emsp;&emsp;压力/放松——二者正好相反！ &emsp;&emsp;什么样的毒品 才能在同一个人身上起到两种相反的效果？除了这四种情况，以及睡眠状态之外，我们的生活还能处于什么状态？事实上，吸烟既不能缓解无聊或压力，也无法帮你放松，让你集中注意力。这一切都是幻觉。 &emsp;&emsp;尼古丁不仅是一种毒品 ，还是一种强力毒素，是杀虫剂的成分之一（查查辞典就知道了）。如果进行静脉注射，一支烟含有的尼古丁就足以杀死你。除尼古丁之外，吸烟还会产生多种毒素，包括一氧化碳。烟草与剧毒的颠茄是同一个属。 &emsp;&emsp;这本书虽然常提到“香烟”，但其内容涵盖了烟草的所有使用方式，如烟斗、雪茄、嚼烟等，以及尼古丁的所有摄入方式，如口香糖、贴膏、喷雾剂等。 &emsp;&emsp;人是地球上最复杂的生物体之一，但即使最简单的生物体，比如单细胞生物，也不可能在混淆食物与毒素的情况下生存。 &emsp;&emsp;经过千百万年来的自然选择，我们的头脑和身体已经形成了一整套机制，可以有效分辨食物与毒素，确保万无一失。 &emsp;&emsp;任何人都讨厌烟味，直到染上烟瘾为止。如果把烟气喷到婴儿或者动物的脸上，他/它就会剧烈咳嗽。 &emsp;&emsp;我们自己吸进第一口烟的时候，也必然会导致咳嗽，如果第一次吸得太多，还会出现头晕、恶心等反应。这就是我们的身体在表达“你把毒素当成食物了！快停下来！”的意思。对这种反应的态度，通常会决定我们是否染上烟瘾。认为只有意志薄弱的人才会染上烟瘾，这其实是错误的。意志薄弱的人其实通常是幸运的，因为他们无法忍受第一支烟的感觉；他们的肺部无法承受烟气引起的窒息感，所以他们一辈子都不会吸烟。或者，他们心理上无法接受吸烟造成的痛苦，所以也不会再次尝试。 &emsp;&emsp;对我来说，需要下很大努力才能“学会”吸烟的事实，是最大的悲剧之一。正是因为这一点，青少年的吸烟行为才难以阻止。他们仍处于“学习 ”阶段，仍然感到烟味无法忍受，所以才会以为他们随时都可以停下来。他们为什么不吸取我们的教训？而我们又为什么不吸取上一代人的教训？ &emsp;&emsp;许多吸烟者认为自己的确喜欢烟味，这其实是一种幻觉。我们“学习 ”吸烟时，其实是在强迫身体适应糟糕的烟味。海洛因上瘾者也认为自己的确喜欢注射海洛因的感觉，然而事实却是，海洛因的戒断症状更为痛苦，他们喜欢的是缓解痛苦的感觉。 &emsp;&emsp;如果哪个吸烟者相信，他只是因为喜欢烟味才吸烟，你可以这样问他：“假如手边没有你平时抽的香烟牌子，只有你不喜欢的牌子，你会不会拿来抽？”他当然会的。如果别无选择，他甚至会把旧绳子点燃来抽，更别说薄荷烟卷、雪茄和烟斗了。无论是感冒、流感、喉咙痛、气管炎还是肺气肿，都无法阻止吸烟者点上一支烟。 &emsp;&emsp;这一切完全与享受无关。如果追求享受的话，任何人吸过第一支烟之后都不会再次尝试。不少所谓的戒烟者甚至会对尼古丁口香糖上瘾。 &emsp;&emsp;许多吸烟者意识到吸烟其实是一种毒瘾时，都觉得问题更严重了，戒烟会变得更加困难。事实上，知道这一点绝不是坏事，原因有两条： &emsp;&emsp;1.绝大多数人吸烟的原因是，尽管知道吸烟弊大于利，但他们相信吸烟是一种享受。他们认为戒烟是放弃这种享受的过程，会给他们的生活造成损失。这是一种错觉。吸烟无法提供任何享受，只能先制造痛苦，然后再部分缓解痛苦，造成享受的假象。后文中，我会详细解释这一机制。 &emsp;&emsp;2.尽管尼古丁是上瘾速度最快的毒品 ，但是上瘾程度并不会很严重。由于尼古丁的作用速度很快，只消三个星期不吸烟，你体内99%以上的尼古丁就会排出体外，而且实质性的戒断症状非常轻微，绝大多数吸烟者甚至终生意识不到。 &emsp;&emsp;你自然会问，为什么许多人即使强制戒烟几个月，仍然会感觉到对香烟的渴望？原因就是下一章的主题——社会对人们的洗脑。单是生化层面的上瘾症状，其实很容易对付。 &emsp;&emsp;绝大多数吸烟者睡觉时都不会吸烟，而戒断症状甚至不会把他们弄醒。 &emsp;&emsp;许多吸烟者起床 后并不会立即点燃香烟，而是会先吃早饭，甚至先上班工作。睡眠时，他们可以轻松忍受10个小时的戒断症状，但在白天，10个小时不吸烟却会让他们抓狂。 &emsp;&emsp;许多吸烟者买了新车之后，都会忍住不在车里吸烟。他们会花几个小时看电影 、逛超市、乘坐地铁，尽管这些地方禁止吸烟，对他们也没什么影响。事实上，偶尔有这样的机会可以不用吸烟，他们甚至会非常高兴——只要不是永远禁止吸烟就好。 &emsp;&emsp;今天，绝大多数吸烟者在非吸烟者的家中或聚集场所都不会吸烟，而且不会感到任何不便。事实上，绝大多数吸烟者都有过较长时间远离香烟，却没有任何不适的经历。我自己当年还是个烟鬼时，从来不在晚上吸烟。烟瘾最严重的那几年，我甚至常常期待着晚上到来，这样我就可以不用让自己窒息（真是个荒谬的“习惯”）。 &emsp;&emsp;总之，生化层面的尼古丁上瘾症状很容易对付。许多吸烟者一辈子都只是偶尔抽支烟。他们的上瘾程度并不比地道的烟鬼轻多少。许多吸烟者在戒掉香烟之后，偶尔会来上一支雪茄，这样会维持他们的尼古丁上瘾症状，然而他们的烟瘾却并不一定会复发。 &emsp;&emsp;单纯的尼古丁上瘾绝不是主要的问题，只会起到催化剂的作用，让我们意识不到问题的真正所在：社会的洗脑作用。 &emsp;&emsp;即使是吸烟程度十分严重的烟鬼，戒烟的难度也不比轻度吸烟者更高。事实上，他们戒烟的难度甚至更低。染上烟瘾的时间越久，戒烟带来的收获就越大。 &emsp;&emsp;或许你会很高兴知道，那些一度流传甚广的谣言（例如，“吸烟残留在身体里的毒素要七年才能完全排出体外”，或者“每一支烟会导致生命减少五分钟”）其实并不是真的。 &emsp;&emsp;当然，吸烟的危害性绝不是夸大，甚至还经常被低估。“每支烟导致生命减少五分钟”的说法，用于形容因吸烟患上不治之症的人，可以说是恰如其分。 &emsp;&emsp;吸烟残留在身体里的毒素，永远无法完全排出体外。即使不吸的人也会沾染少量的毒素，因为但凡有人类生活的地方，空气都已经被吸烟者污染了。不过，我们的身体具有强大的恢复能力，只要没有患上不治之症，吸烟对健康的损害都是可逆的。如果你现在戒烟的话，只消几个星期，吸烟对你健康的影响就会彻底消失。 &emsp;&emsp;记住，任何时候戒烟都不会为时过晚。通过我的帮助摆脱烟瘾的人中，有许多已经年届花甲，甚至超过了古稀之年。一位91岁的老妪曾带着她66岁的儿子，前来拜访我们的诊所。我问她为什么要戒烟，她的回答是：“为了给我儿子做个榜样。”六个月后她联系我时，说她感觉仿佛回到了年轻时代。 &emsp;&emsp;吸烟对你的危害越大，戒烟的效果就越明显。我最终戒烟成功时，每天抽掉的香烟数目从100支瞬间下降到0，而且没有任何严重反应。事实上，戒烟过程是一种享受，就连三个星期的戒断期也是一样。 &emsp;&emsp;但是还有洗脑的问题需要处理。 第7章 吸烟的陷阱：洗脑&emsp;&emsp;我们最初是怎么开始吸烟的，原因又是什么？为了彻底理解这一点，你必须了解潜意识的重要性。 &emsp;&emsp;我们都自认为是有智力、有主观能动性的人，能够决定自己的生活方向。事实上，我们的决定99%都会受到各种各样因素的影响。我们是周围环境影响的产物——我们身上的服装样式、居住的住宅、基本生活规律，更不用提政见、文化观念等，这些都是社会影响的结果。 &emsp;&emsp;不说这些理念和习惯，即使是我们对事实的认知，也无法保证一定正确。哥伦布抵达美洲之前，大多数人都认为大地和海洋是平的。今天我们知道地球是个球体，就算我写下十几本书，努力说服你地球是平的，你也不会相信。然而，我们中有多少人真正去过太空，从远处观察过地球？就算你曾进行过环球旅行，你又怎么知道旅行轨迹不是平面上的一个圆？ &emsp;&emsp;广告商们非常清楚心理暗示对潜意识的影响力。你是否认为杂志广告完全是金钱的浪费？认为广告并不是你购买香烟的原因？那你就错了！试试看，下次在冷天跟朋友一起去酒吧的时候，如果他问你想喝什么，不要简单回答“白兰地”，而是告诉他：“你知道我今天最想享受什么吗？白兰地奇妙的温 暖滋味！”你会发现，即使不喜欢喝酒的人也会跟你一样点杯白兰地。 &emsp;&emsp;“你建议我读这本书的时候维持吸烟的习惯，这实在是一出妙招。读书的过程中，我发现我对抽掉的每一根烟都耿耿于怀。” ——科尔斯蒂?L &emsp;&emsp;自打我们懂事时起，潜意识无时无刻不遭到各种信息的狂轰滥炸，其中许多信息都告诉我们：香烟是世界上最好的东西，能让我们放松，给我们信心和勇气。你觉得我是在夸大？看电影 、话剧或动画片时，如果一个角色即将被处以死刑，他的最后遗愿通常是什么？没错，吸一支烟。这样的情节并不会对我们的意识造成任何影响，但是我们的潜意识却会吸收其中的隐含信息，也就是：“香烟是世界上最好的东西，所以我才会把它作为临终选择。”在绝大多数战争片中，受伤的人都会得到一支香烟。 &emsp;&emsp;年复一年，这样的信息轰炸并没有改变。今天青少年的潜意识，仍然要承受各种信息的狂轰滥炸。尽管电视香烟广告已遭禁止，但在播放电视剧的黄金时间，屏幕上的明星们却都在吞云吐雾。体育运动也是一样。许多参加一级方程式大赛的赛车都以香烟品牌命名——或者是反过来，香烟品牌是以赛车命名？我曾看到过这样的插播广告：一对裸体的夫妇在做愛之后，躺在床 上共吸一支香烟。广告的暗示意味再明显不过了。尽管我无法赞同广告商的动机，但却不得不佩服他们的宣传手段。经常会有这样的宣传片：一个人正面临危急关头——他的热气球即将起火坠落 ，或者摩托车侧厢即将栽进峡谷，或者他是哥伦布，他的船马上就要从海洋的尽头掉进深渊之中。轻音乐响起，没有任何话语说明，那个人点起一支烟，脸上洋溢着幸福的表情。我们的主观意识或许会直接忽略这样的场面，但是潜意识却难免受其影响。 &emsp;&emsp;的确，反对吸烟的宣传也不是不存在——强调吸烟有害健康，提倡大众戒烟的宣传——但是单纯强调吸烟的危害，并不能为吸烟者提供戒烟的动力，更无法阻止青少年尝试吸烟。我自己还是个烟鬼的时候一直以为，当年我如果知晓吸烟与肺癌之间的关系，绝对不会开始吸烟。事实是，就算那样也不会有任何区别。吸烟的陷阱在今天，跟在文艺复兴时代没有任何区别。反对吸烟的宣传不仅于事无补，反而会把事情弄糟。所有的烟盒上都印有“吸烟有害健康”的字样，然而有人会去看吗？ &emsp;&emsp;我相信，关于吸烟有害健康的宣传，甚至会增加香烟的销量。吸烟者看到这样的宣传，无疑会心情紧张，于是抽掉更多的烟。 &emsp;&emsp;讽刺的是，最强大的洗脑力量来源于吸烟者自己。吸烟者绝不是意志薄弱或身体虚弱的人，相反，只有身体强健才能抵抗香烟中的毒素。 &emsp;&emsp;极少数人尽管一辈子吸烟，却能活到80多岁高龄，而且身体硬朗。吸烟者就拿这样的个别例子作为借口，不去理会吸烟损害健康的事实。这是他们坚持吸烟的原因之一。 &emsp;&emsp;如果你在朋友和同事中间做个小小的统计，你会发现，绝大多数吸烟者都是意志坚强的人，包括自由 经营者、企业高层、医生、律师、警察、教师、推销商、护士 、秘书、带孩子的家庭主妇等——换句话说，就是生活压力较大的那些人。许多人误以为吸烟能缓解压力，所以责任和压力重大的人更倾向于吸烟，而我们通常会仰慕这样的人，所以也跟着吸烟。另一类吸烟者则是那些工作性质单调重复的人，因为他们误以为吸烟能够缓解无聊。不过当然，这也只是一种错觉。 &emsp;&emsp;周围环境的洗脑效果累积起来，作用相当惊人。现代社会对绝大多数吸毒行为都极端排斥。在英国，每年因吸胶毒而死的人数不到一百，因海洛因而死的人数也只有几百，与吸烟致死的人数相比简直是沧海一粟。 &emsp;&emsp;然而尼古丁这种毒品 ，让超过60%的英国人染上了毒瘾，大多数人终其一生都无法摆脱。他们把无数财富浪费在吸烟上，每年都有数十万人死于吸烟引发的疾病。吸烟已成为现代社会的第一大杀手。 &emsp;&emsp;我们为什么对其他吸毒行为深恶痛绝，唯独对吸烟网开一面，甚至直到前不久，都将吸烟当作一种可以接受的社会行为？近年来，尽管人们开始认识到吸烟有害健康，但是烟草制品的销售不仅没有被禁止，而且还更上一层楼。最大的受益者是政府。由于众多吸烟者的存在，英国政府每年从烟草销售中抽取80亿英镑的利税，而各大烟草公司每年的宣传经费就超过一亿英镑。 &emsp;&emsp;你必须主动抗拒周围环境的洗脑作用。正如购买二手车时一样，你可以听车贩子吹得天花乱坠，并且微笑点头，但是内心绝对不能相信他半句。 &emsp;&emsp;五彩缤纷的香烟包装之下，掩藏的是肮脏和毒害，你一定要看清楚这一点。不要被精美的烟灰缸、镀金的打火机，以及千百万人吸烟的事实给迷惑了。扪心自问： &emsp;&emsp;为什么我要吸烟？ &emsp;&emsp;我真的需要吗？ &emsp;&emsp;不，你当然不需要。 &emsp;&emsp;洗脑作用的原理非常不容易解释。为什么吸烟者在其他方面智力正常，唯独在尼古丁毒瘾方面表现得像个白痴？尽管很痛苦，但我不得不承认，在我的帮助下摆脱烟瘾的数千人中，我自己正是最大的那个白痴。 &emsp;&emsp;不仅我自己每天抽100支烟，我父亲也是个烟鬼。他本是个健壮的人，却因为吸烟英年早逝。还记得童年时，父亲每天早上总要剧烈地咳嗽。我能看出他很痛苦，当时的我以为，他一定是中了什么邪。我曾对母亲说：“永远不要让我吸烟。” &emsp;&emsp;15岁的时候，我成了个运动狂，充满了自信和勇气。如果那时有人告诉我，我将来会成为一个每天吸100支烟的烟鬼，那我一定会拿一辈子赚的钱跟他打赌，赌这样的事永远不会发生。 &emsp;&emsp;到了40岁，我被香烟折磨得形神俱损，无论打算干什么，事先必须要点支烟。大多数吸烟者都是在感觉到压力时才会吸烟，比如接电话时、跟人交 谈时等。而我如果不来一支烟，就没有动力换个电灯泡，甚至切换电视频道。 &emsp;&emsp;我知道自己这样下去，最终会因吸烟而死。我不可能欺骗自己。但我无法理解，为什么当时我居然没有意识到，吸烟对我的精神也造成了重大影响。大多数吸烟者认为吸烟是一种享受，然而我从来没有产生过这样的错觉。我吸烟是因为我觉得，吸烟可以帮我集中注意力，缓解神经的紧张。现在我很难相信，我居然经历过那样一段黑暗的日子。那段时光仿佛是一场噩梦，梦醒之后一切都无所谓了。尼古丁是一种毒品 ，毒瘾会扭曲你的感觉，尤其是味觉和嗅觉。吸烟最可怕的地方不在于对健康的损害，而在于对精神的影响：你会搜寻任何说得过去的理由，只为了能继续吸烟。 &emsp;&emsp;我还记得，有一次戒烟失败之后，我决定由抽香烟改抽烟斗。当时我觉得，烟斗的危害性比香烟要小，而且我的烟草消耗量也会下降。烟斗用的烟草十分糟糕，或许闻上去气味还能忍受，但是抽起来让人痛不欲生。一连三个月，我的舌尖布满了水疱。烟斗底部逐渐积满了黏稠的焦油。偶尔我会不小心抬起烟斗，让里面的焦油流进嘴里。每当这样的时候，我就会立即呕吐，无论身边有什么人在场。 &emsp;&emsp;我花了三个月时间练习 使用烟斗，而在那三个月中间，我没有一次停下来问自己，我为什么要承受这样的折磨。 &emsp;&emsp;当然，适应了烟斗之后，吸烟者可能会自我感觉相当良好，因为他们终于有了借口：吸烟是因为喜欢烟斗的感觉。但是他们当初为什么要费力练习 使用烟斗呢？ &emsp;&emsp;原因是，一旦你染上尼古丁毒瘾，社会的洗脑作用就会加重。在潜意识里，你知道毒瘾必须用更多的尼古丁来压制，这个念头占据了你的整个思想。我已经说过，人们吸烟的真正原因是恐惧，对尼古丁戒断症状的恐惧。尽管你意识不到这一点，却不表明恐惧不存在。你并不理解这种恐惧，正如一只猫不会理解地板下的暖气管道一样。它只知道如果它趴在某一个地方，就会感觉到暖和。 &emsp;&emsp;洗脑是导致戒烟困难的最主要因素——社会对我们的洗脑，再加上我们对自己的洗脑，以及身边亲友和同事们的洗脑。 &emsp;&emsp;你是否注意到，在前文中，我经常使用“放弃吸烟”这种说法？事实上，这就是洗脑的典型例子。看多了这样的说法，你就会觉得戒烟的确是一种放弃，尽管事实上你完全没有什么可放弃的。相反，通过戒烟，你不仅可以远离毒瘾，还能达到神奇的正面效应。从现在开始，让我们改变这种说法。我不会再用“放弃”这个字眼，而是“停止”“杜绝”，或者最准确的表达：从吸烟的陷阱中逃脱！ &emsp;&emsp;我们开始吸烟是因为无数人都在这样做，我们觉得只有跟着做才算合群。我们拼命努力“学习 ”吸烟，从来没人想过深层次的后果。每当我们遇见另一个吸烟者，他总是让我们相信，吸烟的确有其意义所在。就算他已经戒了烟，当看到别人点起一支烟的时候，仍然会有强烈的失落感。他也想来一支烟，仅仅一支，他觉得这样很安全。结果就是，之前戒烟的努力完全失败。 &emsp;&emsp;这一洗脑作用非常强势，你必须十分小心。在英国，绝大多数老烟槍都听过神探保罗?坦普的系列广播故事。其中一集讲的是大麻上瘾的事。坏人把大麻添加到香烟里出售，而吸烟者却并不知情。大麻并没有产生负面作用，不过但凡吸过含大麻香烟的人，都只能继续购买这种香烟（我亲自帮助的戒烟者中，有几百人承认自己曾吸食过大麻，但是他们都没有上瘾）。第一次听到这个故事时我只有七岁，那是我对毒品 和毒瘾的最初概念。一旦形成毒瘾就难以摆脱，这让我感到非常害怕。即使在今天，尽管我知道大麻不会上瘾，也决不敢抽一口大麻。讽刺的是，我却成了全世界头号毒品 的瘾君子。要是保罗?坦普当年警告过我吸烟的害处就好了。更讽刺的是，60多年后的今天，人类把数以百亿计的钱投入癌症研究，同时又把10倍的钱用于广告宣传，让健康的青少年沾染上烟瘾。 &emsp;&emsp;我们必须消除洗脑作用的影响。否则，吸烟者终其一生，都无法好好享受： &emsp;&emsp;?良好的健康 &emsp;&emsp;?充沛的精力 &emsp;&emsp;?心灵的安宁 &emsp;&emsp;?财富 &emsp;&emsp;?自信 &emsp;&emsp;?勇气 &emsp;&emsp;?自尊 &emsp;&emsp;?幸福 &emsp;&emsp;?自由 &emsp;&emsp;牺牲了这么多，吸烟者得到的又有什么？ &emsp;&emsp;什么都没有——除了幻想。幻想恢复正常的生活状态，摆脱烟瘾的困扰，而这是每个非吸烟者每天都在享受的。]]></content>
      <categories>
        <category>这书能让你戒烟</category>
      </categories>
      <tags>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Love essays]]></title>
    <url>%2F2019%2F09%2F20%2FLoves-essay%2F</url>
    <content type="text"><![CDATA[开篇： 为了自己欣赏自己喜欢的文章 不做多少评论 提升自身文学修养 北平的秋—老舍 ＜四世同堂＞节选&emsp;&emsp;中秋前后是北平最美丽的时候。天气正好不冷不热，昼夜的长短也划分得平匀。没有冬季从蒙古吹来的黄风，也没有伏天里挟着冰雹的暴雨。天是那么高，那么蓝，那么亮，好象是含着笑告诉北平的人们：在这些天里，大自然是不会给你们什么威胁与损害的。西山北山的蓝色都加深了一些，每天傍晚还披上各色的霞帔。 &emsp;&emsp;在太平年月，街上的高摊与地摊，和果店里，都陈列出只有北平人才能一一叫出名字来的水果。各种各样的葡萄，各种各样的梨，各种各样的苹果，已经叫人够看够闻够吃的了，偏偏又加上那些又好看好闻好吃的北平特有的葫芦形的大枣，清香甜脆的小白梨，象花红那样大的白海棠，还有只供闻香儿的海棠木瓜，与通体有金星的香槟子，再配上为拜月用的，贴着金纸条的枕形西瓜，与黄的红的鸡冠花，可就使人顾不得只去享口福，而是已经辨不清哪一种香味更好闻，哪一种颜色更好看，微微的有些醉意了！ &emsp;&emsp;那些水果，无论是在店里或摊子上，又都摆列的那么好看，果皮上的白霜一点也没蹭掉，而都被摆成放着香气的立体的图案画，使人感到那些果贩都是些艺术家，他们会使美的东西更美一些。况且，他们还会唱呢！他们精心的把摊子摆好，而后用清脆的嗓音唱出有腔调的”果赞”：”唉——一毛钱儿来耶，你就挑一堆我的小白梨儿，皮儿又嫩，水儿又甜，没有一个虫眼儿，我的小嫩白梨儿耶！”歌声在香气中颤动，给苹果葡萄的静丽配上音乐，使人们的脚步放慢，听着看着嗅着北平之秋的美丽。 &emsp;&emsp;同时，良乡的肥大的栗子，裹着细沙与糖蜜在路旁唰啦唰啦的炒着，连锅下的柴烟也是香的。”大酒缸”门外，雪白的葱白正拌炒着肥嫩的羊肉；一碗酒，四两肉，有两三毛钱就可以混个醉饱。高粱红的河蟹，用席篓装着，沿街叫卖，而会享受的人们会到正阳楼去用小小的木锤，轻轻敲裂那毛茸茸的蟹脚。 &emsp;&emsp;同时，在街上的”香艳的”果摊中间，还有多少个兔儿爷摊子，一层层的摆起粉面彩身，身后插着旗伞的兔儿爷——有大有小，都一样的漂亮工细，有的骑着老虎，有的坐着莲花，有的肩着剃头挑儿，有的背着鲜红的小木柜；这雕塑的小品给千千万万的儿童心中种下美的种子。 &emsp;&emsp;同时，以花为粮的丰台开始一挑一挑的往城里运送叶齐苞大的秋菊，而公园中的花匠，与爱美的艺菊家也准备给他们费了半年多的苦心与劳力所养成的奇葩异种开”菊展”。北平的菊种之多，式样之奇，足以甲天下。 &emsp;&emsp;同时，象春花一般骄傲与俊美的青年学生，从清华园，从出产莲花白酒的海甸，从东南西北城，到北海去划船；荷花久已残败，可是荷叶还给小船上的男女身上染上一些清香。 &emsp;&emsp;同时，那文化过熟的北平人，从一入八月就准备给亲友们送节礼了。街上的铺店用各式的酒瓶，各种馅子的月饼，把自己打扮得象鲜艳的新娘子；就是那不卖礼品的铺户也要凑个热闹，挂起秋节大减价的绸条，迎接北平之秋。 &emsp;&emsp;北平之秋就是人间的天堂，也许比天堂更繁荣一点呢！ 本文节选自《四世同堂》人民文学出版社2012年版 陋室铭山不在高，有仙则名。水不在深，有龙则灵。斯是陋室，惟吾德馨。苔痕上阶绿，草色入帘青。谈笑有鸿儒，往来无白丁。可以调素琴，阅金经。无丝竹之乱耳，无案牍之劳形。南阳诸葛庐，西蜀子云亭。孔子云：何陋之有？ 本文选自《陋室铭》【作者】刘禹锡 【朝代】唐]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>短篇</tag>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔日志]]></title>
    <url>%2F2019%2F09%2F19%2F%E9%9A%8F%E7%AC%94%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[开篇 任性，就是想随便写点 有感而发，想到哪是哪 没有规划可言，随心所欲 2019-09-19 将近两周了，上上周定下来需求，从上周开始搞，算下时间，上周由于中秋节上了4天班，放假了三天，今天周四，算下来是八天时间.几乎每天搞到九点半，说实话很累，没办法，上班做程序员就是这么辛苦。 需求下来-&gt;周一晚上提测开始想着这挺简单的，应该能提前完成任务，但是没想到啊… 上周一研究需求，开始搞，贴图商城+聊天贴纸发送，之前的界面有所能复用，第一次接触这个项目&lt;语玩&gt;的webApi和c++API，所以研究了一番。接下来开始画界面，这个简单，大部分能复用，然后开始搞数据，一直在做重复工作，搞数据-&gt;等接口-&gt;画UI，周五吧基本的商城界面搞完，下载贴纸写完，但是留下的坑不少，给自己的话：下周在搞吧。 这周开始搞了，周一问下进度，肯定搞不完，提测别想了，于是在放一天，接着同事帮我搞了一些东西，安卓做的快，因为他来的时间比较长，代码模块什么都比我熟悉，算是周一下来基本东西搞完了，bug和坑还不算少，周二周三都干啥了，是开发是改bug，我这都忘了，今天是改了一天bug算是完成了。提前回家7点多下去吃点饭，上来提交一下回家家。 2019-09-29昨天睡得太晚了，也不是不想睡，就是睡不着，心里面也不知道想的啥，乱七八糟，估计睡着至少是到夜里1点半，结果可闲而知，早上起来眼睛睁不开，困，脑袋感觉重重的。7点半起床，洗漱完成上班去。由于这也临近十一假期，好多同事都回贵阳办公去了，公司人不多，零零细细，而且上周项目上架完成后基本上没有紧急任务，所以比较不忙，嘿嘿~ 浏览苹果官方网站，看到管理层入口，点击进去看看，浏览管理层简介，CEO Tim Cook, Katherine Adams … 吧啦吧啦一堆，突然想到国外的先进的公司管理方式和运营模式，改革开放完成后，吸引外资技术才有40年的发展，现在就想思考一下公司团队管理，是真的很牛逼。中国式最原始的管理方式就是东家与雇员的形式一直存在。而下面我想了解下先进的管理方式。 什么是美国式管理美国式管理是指对美国公司管理方式的称谓。美国式管理是以“法”为重心的管理，强调个人价值，强调沿革的制度，理性决策技术和追求最大限度的利润等。 美国式管理的特点美国式管理的特点是鼓励个人英雄主义及以能力为主要考核特征的模式，它在管理上的主要表现就是规范管理、制度管理和条例管理，以法制为主体的科学化管理。 美国式管理与中国式管理“中国式管理最大的价值在于对人的尊重。”曾教授说，他认为管理就是做人做事的道理，而做人要排在更重要的位置。美国式管理是“我要-我成”，订立目标，拿出成果；日本式管理则是“同生-共荣”，合力追求团体的荣誉，不计较个人的荣辱；而中国式管理却是“修己-安人”。美国式管理的特征核心是制度，说是以制度治理企业的典范。中国式管理，核心特征是人情，是人情治理企业的样板。 美国式管理的问题美国式管理管理方式出了问题。很多企业高管已经与企业脱节，不再了解真实的运转情况。长此以往，在美国公司内部，只有一个高高在上的CEO，他们对基层事务很少问津，却对股票价格紧张透顶。真正好的领导者应该是关注公司的每个层面，并且确实能把握一线生意进展的真实状况。美国式管理出现的主要问题在于，没有一个CEO能够有效衡量对于公司长期发展所产生的影响。 2019-09-30干移动端的工作，其实就像个厨师，产品调研 用户点个菜，UI给食材，后端队友给炒锅颠勺，经过层层规划，做这道菜的流程规划好。终于开始炒菜。要想做出来色香味俱全的菜，首先食材质量是不能次的，然后锅得耐用好使，火可大可小，最主要看这个厨师的功底怎么样了，各种花式的炒，也许好的厨师就算烂的食材和工具也能做出来的一道美味的菜肴。但是好的食材配合好的厨师才能做出来最好的菜肴。测试人员先品尝菜品味道有没有什么问题，接下来看服务员运营端菜上盘的功夫好不好了。乱说八道哈哈哈~ 2019-10-19转眼间19号了 2019-10-31今天都31号了，好久没来这里逛逛我的小窝了， 2020-06-30吸烟并不会使我快乐，不吸烟不会使我恐惧，所以吸烟并没有什么意义。绝大多数人吸烟的原因是，尽管知道吸烟弊大于利，但他们相信吸烟是一种享受。他们认为戒烟是放弃这种享受的过程，会给他们的生活造成损失。这是一种错觉。吸烟无法提供任何享受，只能先制造痛苦，然后再部分缓解痛苦，造成享受的假象。后文中，我会详细解释这一机制。 吸烟对你的危害越大，戒烟的效果就越明显。我最终戒烟成功时，每天抽掉的香烟数目从100支瞬间下降到0，而且没有任何严重反应。事实上，戒烟过程是一种享受，就连三个星期的戒断期也是一样。]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Study English]]></title>
    <url>%2F2019%2F09%2F07%2F%E5%AD%A6%E4%B9%A0%E8%8B%B1%E6%96%87%2F</url>
    <content type="text"><![CDATA[编程和英文息息相关，不会英文对开发过程中造成的影响还是不小的。尤其在读一些文档方面，熟悉每个单词的中文意思对读懂整个文档帮助很大。我的英文水平在高中后退化就很大了，大学英语基本上也没学过，词汇量不大，对我的工作生活影响也很大，虽然听力不行，但是增大词汇量对读一些国外文章就不成问题。平时的开发经常查一些单词，捡起来一些东西了，以后还是把自己所查的东西给记录下来吧。便于自己以后看看。 每天记录一些自己不认识或者不熟悉的单词 单词 释意 读音 Diamond 金刚石;钻石;菱形;(纸牌的)方块 美 [ˈdaɪəmənd] Permission 准许;许可;批准;许可证;书面许可 美 [pərˈmɪʃn] External 外部的;外面的;外界的;外来的;在外的;来自(学校或机构)以外的 美 [ɪkˈstɜːrnl] Incompatible 不可兼容的;不相容;不相容的;不兼容的;不相容性 美 [ˌɪnkəmˈpætəbl] percent 百分之… 美 [pərˈsɛnt] Reorder 调整顺序;重新排序;重排序;重排;顺序调整 美 [ˌriːˈɔːrdər] Essay 文章，短文;(用来刊登的)论说文;小品文 美 [ˈeseɪ , eˈseɪ] platforms 站台;月台;讲台;舞台;平台 美 [ˈplætˌfɔrmz] contribution 捐款;捐资;贡献;促成作用 美 [ˌkɑːntrɪˈbjuːʃn] 记录一些自己喜欢的英文语句]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ipa 打包shell脚本]]></title>
    <url>%2F2019%2F09%2F05%2Fipa-%E6%89%93%E5%8C%85shell%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[问题描述当我们想打包一个IPA，为自己内部测试使用，或者IPA部署自己服务器，这时候我们使用shell脚本就方便点了。 Xcode scheme run set release， device set generic iOS device，  run done product 文件夹下就有我们想要的东西了 编写好shell脚本，自动化快速为我们打包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#!/bin/shecho '\033[32m xcodebuild----------------------------start-------------------------- \033[0m'#打包基础配置userName='ysc'appName='Vostic'svnVersion='1.1.1'serverConfig='BeiJing'#serverConfig='ShuBei'#debugMode='Debug'debugMode='Release'sandbox='eynjaojbmfxqukcbinxdlfasvkpi'savePath=/Users/$&#123;userName&#125;/Desktop/xcodebuildsvnCheckPath=/Users/$&#123;userName&#125;/Desktop/iOS/VosticsvnLocalPath=$&#123;svnCheckPath&#125;/$&#123;svnVersion&#125;svnRemotePath=svn://yeshichang@10.1.6.1/dev/issue/iOS/Vostic/2019/$&#123;svnVersion&#125;#检出svnecho "checkout svn $svnVersion"if [ ! -d "$svnLocalPath" ]; thencd $&#123;svnCheckPath&#125;svn checkout $&#123;svnRemotePath&#125;fiecho '\033[32m xcodebuild---------------------------build--------------------------- \033[0m'#输入版本号read -p "Build version:" buildVersion#检查测试包是否已存在if [ -d "$svnLocalPath/$buildVersion" ]; thenecho "check $buildVersion is exists!"exit 0fi#输入Git版本号read -p "Git version:" gitVersion#开始时间戳startTime=$(date +%s)#创建存放目录if [ ! -d "$savePath" ]; thenmkdir "$savePath"fi#判断目录存在if [ ! -d "$savePath" ]; thenecho "check $savePath is no exists!"exit 0fi#打开存放目录cd $&#123;savePath&#125;#移除目录文件rm -rf *#创建版本目录mkdir "$savePath/$buildVersion"#拷贝xxx.app到存放目录cp -rf /Users/$&#123;userName&#125;/Library/Developer/Xcode/DerivedData/$&#123;appName&#125;-$&#123;sandbox&#125;/Build/Products/$&#123;debugMode&#125;-iphoneos/$&#123;appName&#125;.app $&#123;savePath&#125;#拷贝xxx.app到存放目录cp -rf /Users/$&#123;userName&#125;/Library/Developer/Xcode/DerivedData/$&#123;appName&#125;-$&#123;sandbox&#125;/Build/Products/$&#123;debugMode&#125;-iphoneos/$&#123;appName&#125;.app.dSYM $&#123;savePath&#125;/$&#123;buildVersion&#125;echo '\033[32m xcodebuild----------------------------ipa-------------------------- \033[0m'#利用itues将xxx.app生成ipamkdir Payloadcp -rf $&#123;appName&#125;.app Payload/$&#123;appName&#125;.appcp Icon.png $&#123;appName&#125;/iTunesArtworkzip -r $&#123;appName&#125;.ipa Payload iTunesArtwork#移除临时文件rm -rf Payloadrm -rf $&#123;appName&#125;.app#移动xxx.ipa到版本目录packageName=iOS_$&#123;buildVersion&#125;_$(date "+%Y%m%d")_$&#123;serverConfig&#125;_$&#123;gitVersion:0:10&#125;mv $&#123;appName&#125;.ipa $&#123;packageName&#125;.ipamv $&#123;packageName&#125;.ipa ./$&#123;buildVersion&#125;echo '\033[32m xcodebuild----------------------------zip-------------------------- \033[0m'#打开版本目录cd $&#123;savePath&#125;/$&#123;buildVersion&#125;#压缩xxx.ipa、xxx.app.dSYMzip -r -m $&#123;buildVersion&#125;.zip ./#回到存放目录cd ..#拷贝测试包到svn目录if [ ! -d "$svnLocalPath/$buildVersion" ]; thenmv $&#123;buildVersion&#125; $&#123;svnLocalPath&#125;fiecho '\033[32m xcodebuild----------------------------svn-------------------------- \033[0m'#打开svn目录cd $&#123;svnLocalPath&#125;#提交测试包svn cleanupsvn add $&#123;buildVersion&#125;svn commit -m "提交iOS测试包$buildVersion" $&#123;buildVersion&#125;#结束时间戳endTime=$(date +%s)time=$(($endTime - $startTime))minute=$(($time/60))second=$(($time%60))echo "\033[44;37m 总用时：$&#123;minute&#125;分$&#123;second&#125;秒 \033[0m"echo '\033[32m xcodebuild----------------------------end-------------------------- \033[0m'exit 0]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS13 自定义返回键位置问题]]></title>
    <url>%2F2019%2F09%2F02%2FiOS13-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%94%E5%9B%9E%E9%94%AE%E4%BD%8D%E7%BD%AE%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[iOS13 beta7已经出来了，为了提前适配应用，测试机升级看看应用是否有问题，幸好坑不算多，主要问题就是用系统导航栏的位置返回按钮向右偏移过多。主要与原有项目中的一些自定义导航返回键不统一。之前项目已经对iOS11后导航栏的变化做过处理 iOS11以下通过UIBarButtonSystemItemFixedSpace进行处理，可以参考论坛的一篇文章，但是iOS13系统处理不了。 所以寻找新方法解决这个问题，让我们先删除原来项目代码，大刀阔斧的干，要有豁出去的精神。 因为是使用系统导航栏，况且项目很大，不容易去修改整个结构，遂就对系统导航进行修改网上参考，在寻找一些解决方案。觉得这篇最合适 iOS11 导航栏按钮位置问题的解决——新，简洁流畅无冗余，结合自己项目做一些修改。最主要同时解决iOS13导航栏返回键偏移的问题。使用layoutMargins这个属性遍历图层大致可以看到时这样的结构 1&lt;_UINavigationBarContentView: 0x7fc141607250; frame = (0 0; 414 44); layer = &lt;CALayer: 0x608000038cc0&gt;&gt; 这个UINavigationBarContentView平铺在导航栏中作为iOS11的各个按钮的父视图,该视图的所有的子视图都会有一个layoutMargins被占用,也就是系统调整的占位,我们只要把这个置空就行了.那样的话该视图下的所有的子视图的空间就会变成我们想要的那样,当然为了保险起见,该视图的父视图也就是bar的layoutMargins也置空,这样 整个bar就会跟一个普通视图一样了 左右的占位约束就不存在了 可以过代码处理 12345678910111213141516171819202122@implementation UINavigationBar (FixSpace)+(void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; [self swizzleInstanceMethodWithOriginSel:@selector(layoutSubviews) swizzledSel:@selector(vst_layoutSubviews)]; &#125;);&#125;-(void)vst_layoutSubviews&#123; [self vst_layoutSubviews]; if (deviceVersion &gt;= 11) &#123; self.layoutMargins = UIEdgeInsetsZero; for (UIView *subview in self.subviews) &#123; if ([NSStringFromClass(subview.class) containsString:@"ContentView"]) &#123; subview.layoutMargins = UIEdgeInsetsZero;//可修正iOS11之后的偏移 &#125; &#125; &#125;&#125;@end 最终代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215#import &lt;UIKit/UIKit.h&gt;@interface UINavigationConfig : NSObject@property (nonatomic, assign) CGFloat vst_defaultFixSpace; // item距离两端的间距,默认为0@property (nonatomic, assign) BOOL vst_disableFixSpace; // 是否禁止使用修正,默认为NO+ (instancetype)shared;- (instancetype)init NS_UNAVAILABLE;+ (instancetype)new NS_UNAVAILABLE;- (CGFloat)vst_systemSpace;@end@interface UINavigationItem (VSTFixSpace)@end@interface NSObject (VSTFixSpace)@end#import "UINavigationVSTFixSpace.h"#import &lt;objc/runtime.h&gt;void vst_swizzle(Class oldClass, NSString *oldSelector, Class newClass) &#123; NSString *newSelector = [NSString stringWithFormat:@"vst_%@", oldSelector]; Method old = class_getInstanceMethod(oldClass, NSSelectorFromString(oldSelector)); Method new = class_getInstanceMethod(newClass, NSSelectorFromString(newSelector)); method_exchangeImplementations(old, new);&#125;@implementation UINavigationConfig+ (instancetype)shared &#123; static UINavigationConfig *config; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; config = [[self alloc] init]; &#125;); return config;&#125;-(instancetype)init &#123; if (self = [super init]) &#123; self.vst_defaultFixSpace = 0; self.vst_disableFixSpace = NO; &#125; return self;&#125;- (CGFloat)vst_systemSpace &#123; return MIN([UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height) &gt; 375 ? 20 : 16;&#125;@end@implementation UINavigationItem (VSTFixSpace)+(void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; if (@available(iOS 11.0, *)) &#123;&#125; else &#123; NSArray &lt;NSString *&gt;*oriSels = @[@"setLeftBarButtonItem:", @"setLeftBarButtonItem:animated:", @"setLeftBarButtonItems:", @"setLeftBarButtonItems:animated:", @"setRightBarButtonItem:", @"setRightBarButtonItem:animated:", @"setRightBarButtonItems:", @"setRightBarButtonItems:animated:"]; [oriSels enumerateObjectsUsingBlock:^(NSString * _Nonnull oriSel, NSUInteger idx, BOOL * _Nonnull stop) &#123; vst_swizzle(self, oriSel, self); &#125;]; &#125; &#125;);&#125;-(void)vst_setLeftBarButtonItem:(UIBarButtonItem *)leftBarButtonItem &#123; [self setLeftBarButtonItem:leftBarButtonItem animated:NO];&#125;-(void)vst_setLeftBarButtonItem:(UIBarButtonItem *)leftBarButtonItem animated:(BOOL)animated &#123; if (!UINavigationConfig.shared.vst_disableFixSpace &amp;&amp; leftBarButtonItem) &#123;// 存在按钮且需要调节 [self setLeftBarButtonItems:@[leftBarButtonItem] animated:animated]; &#125; else &#123;// 不存在按钮,或者不需要调节 [self vst_setLeftBarButtonItem:leftBarButtonItem animated:animated]; &#125;&#125;-(void)vst_setLeftBarButtonItems:(NSArray&lt;UIBarButtonItem *&gt; *)leftBarButtonItems &#123; [self setLeftBarButtonItems:leftBarButtonItems animated:NO];&#125;-(void)vst_setLeftBarButtonItems:(NSArray&lt;UIBarButtonItem *&gt; *)leftBarButtonItems animated:(BOOL)animated &#123; if (!UINavigationConfig.shared.vst_disableFixSpace &amp;&amp; leftBarButtonItems.count) &#123;// 存在按钮且需要调节 UIBarButtonItem *firstItem = leftBarButtonItems.firstObject; CGFloat width = UINavigationConfig.shared.vst_defaultFixSpace - UINavigationConfig.shared.vst_systemSpace; if (firstItem.width == width) &#123;// 已经存在space [self vst_setLeftBarButtonItems:leftBarButtonItems animated:animated]; &#125; else &#123; NSMutableArray *items = [NSMutableArray arrayWithArray:leftBarButtonItems]; [items insertObject:[self fixedSpaceWithWidth:width] atIndex:0]; [self vst_setLeftBarButtonItems:items animated:animated]; &#125; &#125; else &#123;// 不存在按钮,或者不需要调节 [self vst_setLeftBarButtonItems:leftBarButtonItems animated:animated]; &#125;&#125;-(void)vst_setRightBarButtonItem:(UIBarButtonItem *)rightBarButtonItem&#123; [self setRightBarButtonItem:rightBarButtonItem animated:NO];&#125;- (void)vst_setRightBarButtonItem:(UIBarButtonItem *)rightBarButtonItem animated:(BOOL)animated &#123; if (![UINavigationConfig shared].vst_disableFixSpace &amp;&amp; rightBarButtonItem) &#123;// 存在按钮且需要调节 [self setRightBarButtonItems:@[rightBarButtonItem] animated:animated]; &#125; else &#123;// 不存在按钮,或者不需要调节 [self vst_setRightBarButtonItem:rightBarButtonItem animated:animated]; &#125;&#125;- (void)vst_setRightBarButtonItems:(NSArray&lt;UIBarButtonItem *&gt; *)rightBarButtonItems&#123; [self setRightBarButtonItems:rightBarButtonItems animated:NO];&#125;- (void)vst_setRightBarButtonItems:(NSArray&lt;UIBarButtonItem *&gt; *)rightBarButtonItems animated:(BOOL)animated &#123; if (!UINavigationConfig.shared.vst_disableFixSpace &amp;&amp; rightBarButtonItems.count) &#123;// 存在按钮且需要调节 UIBarButtonItem *firstItem = rightBarButtonItems.firstObject; CGFloat width = UINavigationConfig.shared.vst_defaultFixSpace - UINavigationConfig.shared.vst_systemSpace; if (firstItem.width == width) &#123;// 已经存在space [self vst_setRightBarButtonItems:rightBarButtonItems animated:animated]; &#125; else &#123; NSMutableArray *items = [NSMutableArray arrayWithArray:rightBarButtonItems]; [items insertObject:[self fixedSpaceWithWidth:width] atIndex:0]; [self vst_setRightBarButtonItems:items animated:animated]; &#125; &#125; else &#123;// 不存在按钮,或者不需要调节 [self vst_setRightBarButtonItems:rightBarButtonItems animated:animated]; &#125;&#125;- (UIBarButtonItem *)fixedSpaceWithWidth:(CGFloat)width &#123; UIBarButtonItem *fixedSpace = [[UIBarButtonItem alloc]initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil]; fixedSpace.width = width; return fixedSpace;&#125;@end@implementation NSObject (VSTFixSpace)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; if (@available(iOS 13.0, *)) &#123; NSDictionary &lt;NSString *, NSString *&gt;*oriSels = @&#123;@"_UINavigationBarContentView": @"layoutSubviews", @"_UINavigationBarContentViewLayout": @"_updateMarginConstraints"&#125;; [oriSels enumerateKeysAndObjectsUsingBlock:^(NSString * _Nonnull cls, NSString * _Nonnull oriSel, BOOL * _Nonnull stop) &#123; vst_swizzle(NSClassFromString(cls), oriSel, NSObject.class); &#125;]; &#125; &#125;);&#125;- (void)vst_layoutSubviews &#123; [self vst_layoutSubviews]; if (UINavigationConfig.shared.vst_disableFixSpace) return; if (![self isMemberOfClass:NSClassFromString(@"_UINavigationBarContentView")]) return; id layout = [self valueForKey:@"_layout"]; if (!layout) return; SEL selector = NSSelectorFromString(@"_updateMarginConstraints"); IMP imp = [layout methodForSelector:selector]; void (*func)(id, SEL) = (void *)imp; func(layout, selector);&#125;- (void)vst__updateMarginConstraints &#123; [self vst__updateMarginConstraints]; if (UINavigationConfig.shared.vst_disableFixSpace) return; if (![self isMemberOfClass:NSClassFromString(@"_UINavigationBarContentViewLayout")]) return; [self vst_adjustLeadingBarConstraints]; [self vst_adjustTrailingBarConstraints];&#125;- (void)vst_adjustLeadingBarConstraints &#123; if (UINavigationConfig.shared.vst_disableFixSpace) return; NSArray&lt;NSLayoutConstraint *&gt; *leadingBarConstraints = [self valueForKey:@"_leadingBarConstraints"]; if (!leadingBarConstraints) return; CGFloat constant = UINavigationConfig.shared.vst_defaultFixSpace - UINavigationConfig.shared.vst_systemSpace; for (NSLayoutConstraint *constraint in leadingBarConstraints) &#123; if (constraint.firstAttribute == NSLayoutAttributeLeading &amp;&amp; constraint.secondAttribute == NSLayoutAttributeLeading) &#123; constraint.constant = constant; &#125; &#125;&#125;- (void)vst_adjustTrailingBarConstraints &#123; if (UINavigationConfig.shared.vst_disableFixSpace) return; NSArray&lt;NSLayoutConstraint *&gt; *trailingBarConstraints = [self valueForKey:@"_trailingBarConstraints"]; if (!trailingBarConstraints) return; CGFloat constant = UINavigationConfig.shared.vst_systemSpace - UINavigationConfig.shared.vst_defaultFixSpace; for (NSLayoutConstraint *constraint in trailingBarConstraints) &#123; if (constraint.firstAttribute == NSLayoutAttributeTrailing &amp;&amp; constraint.secondAttribute == NSLayoutAttributeTrailing) &#123; constraint.constant = constant; &#125; &#125;&#125;@end 原文demo地址]]></content>
      <categories>
        <category>Coding日常problem</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[My life]]></title>
    <url>%2F2019%2F08%2F31%2FMy-life%2F</url>
    <content type="text"><![CDATA[购物清单 一次性水杯 西瓜 豆浆 可口可乐 小茗同学 吸烟并不会使我快乐，不吸烟不会使我恐惧，所以吸烟并没有什么意义。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iPhone A12芯片录制编码解码失败问题]]></title>
    <url>%2F2019%2F08%2F31%2FiPhone-A12%E8%8A%AF%E7%89%87%E5%BD%95%E5%88%B6%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[语玩项目中发布动态，有个录制视频功能，录制视频用的是公司底层库C++编写的代码，现在遇到个问题。 问题描述 用A12以下处理器来录制视频，没问题，可以再任何苹果设备和安卓设备上播放 用A12处理器设备录制视频，在A12以下处理器的设备可以播放，在安卓设备也可以播放，但是在用A12处理器设备播放不了视频 特点是黑屏 验证我用手机iPhone XR录制视频，确实在本设备上不能够播放，在Safari浏览器上也不能播放，在本地相册中也不能播放。在其他设备可播放， iPhone XS iPhone XS Max 不可播放。 解决 底层库开发人员修改代码，使用软编码录制，确实可解决问题，但是视频质量不佳 不使用原生AVPlayer，使用其他第三方播放器如&lt;KSYMediaPlayer&gt;可播放，自己实现解码可播放。 经查明，是苹果系统的问题，从iOS12开始，这个bug一直未修复，听说是在iOS13 beta7版本中修复了此bug，但是苦于没有设备，别人的设备也不能够给人家升级beta版，无法做验证。]]></content>
      <categories>
        <category>Coding日常problem</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构 & 算法 in Swift （二）：算法概述和排序算法]]></title>
    <url>%2F2019%2F08%2F30%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%26%20%E7%AE%97%E6%B3%95%20in%20Swift%20%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0%E5%92%8C%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本篇是《数据结构 &amp; 算法 in Swift》系列连载的第二篇，内容分为如下两个部分： 算法基础：简单介绍算法的概念，时间复杂度与空间复杂度，递归，作为本文第二部分的背景知识。 排序算法：结合Swift的代码实现来讲解冒泡排序，选择排序，插入排序，归并排序，快速排序。 算法基础 该部分是给那些对算法以及相关知识不了解的读者准备的，如果已经对算法的相关知识有所了解，可以略过该部分，直接看本文的第二部分：排序算法。 关于该部分的讨论不属于本文介绍的重点，因此没有过多非常专业的论述，只是让那些对算法不了解的读者可以对算法先有一个基本的认识，为阅读和理解本文的第二部分做好准备。 算法的概念算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。 摘自《大话数据结构》 简单说来，算法就是“一个问题的解法”。对于相同一个问题，可能会有多种不同的解法。这些解法虽然可以得到相同的结果，但是每个算法的执行所需要的时间和空间资源却可以是千差万别的。 以消耗的时间的角度为出发点，我们看一下对于同一个问题，两种不同的解法的效率会相差多大： 现在让我们解决这个问题：计算从1到100数字的总和。 把比较容易想到的下面两种方法作为比较： 1到100循环遍历逐步相加 等差数列求和 用Swift函数来分别实现一下： 12345678910111213141516171819func sumOpration1(_ n:Int) -&gt; Int&#123; var sum = 0 for i in 1 ... n &#123; sum += i &#125; return sum&#125;sumOpration1(100)//5050func sumOpration2(_ n:Int) -&gt; Int&#123; return (1 + n) * n/2&#125;sumOpration2(100)//5050 上面的代码中，sumOpration1使用的是循环遍历的方式；sumOpration2使用的是等差数列求和的公式。 虽然两个函数都能得到正确的结果，但是不难看出两个函数实现的效率是有区别的: 遍历求和所需要的时间是依赖于传入函数的n的大小的，而等差数列求和的方法所需要的时间对传入的n的大小是完全不依赖的。 在遍历求和中，如果传入的n值是100，则需要遍历100次并相加才能得到结果，那么如果传入的n值是一百万呢？ 而在等差数列求和的函数中，无论n值有多大，只需要一个公式就可以解决。 我们对此可以以小见大：世上千千万万种问题（算法题）可能也有类似的情况：相同的问题，相同的结果，但是执行效率缺差之千里。那么有没有什么方法可以度量某种算法的执行效率以方便人们去选择或是衡量算法之间的差异呢？ 答案是肯定的。 下面笔者就向大家介绍算法所消耗资源的两个维度：时间复杂度和空间复杂度。 时间复杂度与空间复杂度时间复杂度算法的时间复杂度是指算法需要消耗的时间资源。一般来说，计算机算法是问题规模!n的函数f(n)，算法的时间复杂度也因此记做： $$ T(n)=o(f(n)) $$ 常见的时间复杂度有：常数阶O(1)，对数阶O(log n），线性阶 O(n)，线性对数阶O(nlog n)，平方阶O(n^{2})，立方阶O(n^{3})，!k次方阶O(n^{k})，指数阶 O(2^{n})}。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。 拿其中几个复杂度做对比： 从上图中我们可以看到，平方阶O(n^{2})随着n值的增大，其复杂度近乎直线飙升；而线性阶 O(n)随着n的增大，复杂度是线性增长的；我们还可以看到常数阶 O(1)随着n增大，其复杂度是不变的。 参考上一节的求和问题，我们可以看出来遍历求和的算法复杂度是线性阶O(n)：随着求和的最大数值的大小而线性增长；而等差数列求和算法的复杂度为常数阶 O(1)其算法复杂度与输入n值的大小无关。 读者可以试着想一个算法的复杂度与输入值n的平方成正比的算法。 在这里笔者举一个例子：求一个数组中某两个元素和为某个值的元素index的算法。数组为[0,2,1,3,6]，和为8： 1234567891011121314151617181920212223242526func findTwoSum(_ array: [Int], target: Int) -&gt; (Int, Int)? &#123; guard array.count &gt; 1 else &#123; return nil &#125; for i in 0..&lt;array.count &#123; let left = array[i] for j in (i + 1)..&lt;array.count &#123; let right = array[j] if left + right == target &#123; return (i, j) &#125; &#125; &#125; return nil&#125;let array = [0,2,1,3,6]if let indexes = findTwoSum(array, target: 8) &#123; print(indexes) //1， 4&#125; else &#123; print("No pairs are found")&#125; 上面的算法准确地计算出了两个元素的index为1和4。因为使用了两层的遍历，所以这里算法的复杂度是平方阶O(n^{2}。关于算法复杂度的详细推倒方法，可以参考网上和算法相关书籍的资料。 而其实，不需要遍历两层，只需要遍历一层即可：在遍历的时候，我么知道当前元素的值a，那么只要其余元素里面有值等于（target - a）的值即可。所以这次算法的复杂度就是线性阶O(n)了。 同样地，上面两种算法虽然可以达到相同的效果，但是当n非常大的时候，二者的计算效率就会相差更大：n = 1000的时候，二者得到结果所需要的时间可能会差好几百倍。可以说平方阶O(n^{2})复杂度的算法在数据量很大的时候是无法让人接受的。 空间复杂度算法的空间复杂度是指算法需要消耗的空间资源。其计算和表示方法与时间复杂度类似，一般都用复杂度的渐近性来表示。同时间复杂度相比，空间复杂度的分析要简单得多。而且控件复杂度不属于本文讨论的重点，因此在这里不展开介绍了。 递归在算法的实现中，遍历与递归是经常出现的两种操作。 对于遍历，无非就是使用一个for循环来遍历集合里的元素，相信大家已经非常熟悉了。但是对于递归操作就可能比较陌生。而且由于本文第二部分讲解算法的是时候有两个算法（也是比较重要）的算法使用了递归操作，所以为了能帮助大家理解这两个算法，笔者觉得有必要将递归单独拿出来讲解。 先看一下递归的概念。 递归的概念递归的概念是：在数学与计算机科学中，是指在函数的定义中使用函数自身的方法摘自维基百科 摘自维基百科 通过使用递归，可以把一个大型复杂的问题逐层转化为一个与原问题相似的规模较小的问题来求解。因此如果使用递归，可以达到使用少量的代码就可描述出解题过程所需的多次重复计算的目的，减少了程序的代码量 。 下面用一个例子来具体感受一下递归操作： 大家应该都比较熟悉阶乘的算法：3！= 3 2 1 ； 4！= 4 3 2 * 1 不难看出，在这里反复执行了一个逐渐-1和相乘的操作，如果可以使用某段代码达到重复调用的效果就很方便了，在这里就可以使用递归： 12345func factorial(_ n:Int) -&gt; Int&#123; return n &lt; 2 ? 1: n * factorial(n-1)&#125;factorial(3) //6 在上面的代码里，factorial函数调用了它自己，并且在n&lt;2的时候返回了1；否则继续调用自己。 从代码本身其实不难理解函数调用的方式，但是这个6究竟是怎么算出来的呢？这就涉及到递归的实现原理了。 递归的实现原理递归的调用实际上是通过调用栈（callback stack）来实现的，笔者用一张图从factorial(3)开始调用到最后得出6这个顺序之间发生的事情画了出来： 由上图可以看出，整个递归的过程和栈的入栈出栈的操作非常类似：橘黄色背景的圆角矩形代表了栈顶元素，也就是正在执行的操作，而灰色背景的圆角矩形则代表了其余的元素，它们的顺序就是当初被调用的顺序，而且在内容上保持了当时被调用时执行的代码。 现在笔者按照时间顺序从左到右来说明一下整个调用的过程： 最开始传入3之后，3满足了n&gt;=2的条件，继续调用自己：3 * factorial(2) ，入栈。 传入2之后，2满足了n&gt;=2的条件，继续调用自己：2 * factorial(1) ，入栈。 传入1之后，1满足了n&lt;2的条件，停止调用自己，返回了1，出栈。 此时的栈顶元素为2 factorial(1) ，而刚刚factorial(1)返回了1，所以现在这里变成了2 1 = 2，出栈。 同样地，此时栈顶元素为3 factorial(2)里的 factorial(2)返回了2，所以现在这里变成了3 2 = 6，出栈。 最后，factorial(3)返回了6，出栈，递归结束。 按照笔者个人的理解：整个递归的过程可以大致理解为：在使递归继续的条件为false之前，持续递归调用，以栈的形式保存调用上下文（临时变量，函数等）。一旦这个条件变为true，则立即按照出栈的顺序（入栈顺序的逆序）来返回值，逐个传递，最终传递到最开始调用的那一层返回最终结果。 再简单点，递归中的“递”就是入栈，传递调用信息；“归”就是出栈，输出返回值。 而这个分界线就是递归的终止条件。很显然，这个终止条件在整个递归过程中起着举足轻重的作用。试想一下，如果这个条件永远不会改变，那么就会一直入栈，就会发生栈溢出的情况。 使用递归时需要注意的问题基于上面递归的例子，我们将递归终止条件去掉： 12345func factorialInfinite(_ n:Int) -&gt; Int&#123; return n * factorialInfinite(n-1)&#125;factorialInfinite(3) 这段代码如果放在playground里，经过一小段时间（几秒钟或更多）后，会报一个运行时错误。也可以在return语句上面写一个print函数打印一些字符串，接着就会看到不停的打印，直到运行时错误，栈溢出。 所以说在今后写关于递归的代码的时候，一定要注意递归的终止条件是否合理，因为即使条件存在也不一定就是合理的条件。我们看一下下面这个例子： 12345678func sumOperation( _ n:Int) -&gt; Int &#123; if n == 0 &#123; return 0 &#125; return n + sumOperation(n - 1)&#125;sumOperation(2) //3 上面的代码跟阶乘类似，也是和小于当前参数的值相加，如果传入2，那么知道 n=0时就开始出栈， 2 + 1 + 0 = 3。看似没什么问题，但是如果一开始传入 - 1 呢？结果就是不停的入栈，直到栈溢出。因为 n == 0 这个条件在传入 - 1 的时候是无法终止入栈的，因为 - 1 之后的 -1 操作都是非0的。 所以说这个条件就不是合理的，一个比较合理的条件是 n &lt; = 0。 12345678func sumOperation( _ n:Int) -&gt; Int &#123; if n &lt;= 0 &#123; return 0 &#125; return n + sumOperation(n - 1)&#125;sumOperation(-1) //0 相信到这里，读者应该对递归的使用，调用过程以及注意事项有个基本的认识了。 那么到这里，关于算法的基本介绍已经讲完了，下面正式开始讲解排序算法。 排序算法讲解算法之前，我们先来看一下几个常见的排序算法的对比： 排序算法 平均情况下 最好情况 最坏情况 稳定性 空间复杂度 冒泡 O(n^2) O(n） O(n^2) 稳定 1 选择排序 O(n^2) O(n^2) O(n^2) 不稳定 1 插入排序 O(n^2) O(n） O(n^2) 稳定 1 希尔排序 O(nlogn) 依赖步长 依赖步长 稳定 1 堆排序 O(nlogn) O(nlogn) O(nlogn) 稳定 1 归并排序 O(nlogn) O(nlogn) O(nlogn) 稳定 O(n） 快速排序 O(nlogn) O(nlogn) O(n^2) 不稳定 O(logn) 最好情况和最坏情况以及稳定性的概念不在本文的讨论范围之内，有兴趣的读者可以查阅相关资料。 现在只看平均情况下的性能： 冒泡排序，选择排序，插入排序的时间复杂度为平方阶O(n^{2}) 希尔排序，堆排序，归并排序，快速排序的时间复杂度为线性对数阶O(nlog n) 本篇要给大家介绍的是冒泡排序，选择排序，插入排序，归并排序和快速排序。 希尔排序是基于插入排序，理解了插入排序以后，理解希尔排序会很容易，故在本文不做介绍。堆排序涉及到一个全新的数据结构：堆，所以笔者将堆这个数据结构和堆排序放在下一篇来做介绍。 排序初探在讲排序算法之前，我们先看一种最简单的排序算法（也是性能最低的，也是最好理解的），在这里先称之为“交换排序”。 注意，这个名称是笔者自己起的，在互联网和相关技术书籍上面没有对该算法起名。 算法讲解用两个循环来嵌套遍历： 外层遍历数组从0到末尾的元素，索引为i. 里层遍历数组从i+1至数组末尾的元素，索引为j。 当i上的元素比j上的元素大的时候，交换i和j的元素，目的是保持index为i的元素是最小的。 我们用一个例子看一下是怎么做交换的： 给定一个初始数组：array = [4, 1, 2, 5, 0] i = 0 时： array[0] &gt; array[1] : 交换4和1：[1, 4, 2, 5, 0]，内层的j继续遍历，j++。 array[0] &gt; array[4] : 交换0和1：[0, 4, 2, 5, 1]，i = 0的外层循环结束，i++。 i = 1时： array[1] &gt; array[2] : 交换2和4：[0, 2, 4, 5, 1]，内层的j继续遍历，j++。 array[1] &gt; array[4] : 交换1和2：[0, 1, 4, 5, 2]，i = 1的外层循环结束，i++。 i = 2 时： array[2] &gt; array[4] : 交换2和4：[0, 1, 2, 5, 4]，i = 2的外层循环结束，i++。 i = 3 时： array[3] &gt; array[4] : 交换5和4：[0, 1, 2, 4, 5]，i = 3的外层循环结束，i++。 i = 4 时：不符合内循环的边界条件，不进行内循环，排序结束。 那么用代码如何实现呢？ 代码实现1234567891011121314151617func switchSort(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; for i in 0 ..&lt; array.count &#123; for j in i + 1 ..&lt; array.count &#123; if array[i] &gt; array[j] &#123; array.swapAt(i, j) print("\(array)") &#125; &#125; &#125; return array &#125; 这里面swapAt函数是使用了Swift内置的数组内部交换两个index的函数，在后面会经常用到。 为了用代码验证上面所讲解的交换过程，可以在swapAt函数下面将交换元素后的数组打印出来： 1234567891011121314151617181920212223var originalArray = [4,1,2,5,0]print("original array:\n\(originalArray)\n")func switchSort(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; for i in 0 ..&lt; array.count &#123; for j in i + 1 ..&lt; array.count &#123; if array[i] &gt; array[j] &#123; array.swapAt(i, j) print("\(array)") &#125; &#125; &#125; return array &#125;switchSort(&amp;originalArray) 打印结果： 1234567891011original array:[4, 1, 2, 5, 0]switch sort...[1, 4, 2, 5, 0][0, 4, 2, 5, 1][0, 2, 4, 5, 1][0, 1, 4, 5, 2][0, 1, 2, 5, 4][0, 1, 2, 4, 5] 验证后我们可以看到，结果和上面分析的结果是一样的。 各位读者也可以自己设置原数组，然后在运行代码之前按照自己的理解，把每一次交换的结果写出来，接着和运行算法之后进行对比。该方法对算法的理解很有帮助，推荐大家使用~ 请务必理解好上面的逻辑，可以通过动笔写结果的方式来帮助理解和巩固，有助于对下面讲解的排序算法的理解。 大家看上面的交换过程（排序过程）有没有什么问题？相信细致的读者已经看出来了：在原数组中，1和2都是比较靠前的位置，但是经过中间的排序以后，被放在了数组后方，然后再次又交换回来。这显然是比较低效的，给人的感觉像是做了无用功。 那么有没有什么方法可以优化一下交换的过程，让交换后的结果与元素最终在数组的位置基本保持一致呢？ 答案是肯定的，这就引出了笔者要第一个正式介绍的排序算法冒泡排序： 冒泡排序算法讲解与上面讲的交换排序类似的是，冒泡排序也是用两层的循环来实现的；但与其不同的是： 循环的边界条件：冒泡排序的外层是[0,array.count-1);内层是[0,array.count-1-i)。可以看到内层的范围是不断缩小的，而且范围的前端不变，后端在向前移。 交换排序比较的是内外层索引的元素（array[i] 和 array[j]）,但是冒泡排序比较的是两个相邻的内层索引的元素：array[j]和array[j+1]。 笔者用和上面交换排序使用的同一个数组来演示下元素是如何交换的： 初始数组：array = [4, 1, 2, 5, 0] i = 0 时： array[0] &gt; array[1] : 交换4和1：[1, 4, 2, 5, 0]，内层的j继续遍历，j++。 array[1] &gt; array[2] : 交换4和2：[1, 2, 4, 5, 0]，内层的j继续遍历，j++。 array[2] &lt; array[3] : 不交换，内层的j继续遍历，j++。 array[3] &gt; array[4] : 交换5和0：[1, 2, 4, 0, 5]，i = 0的外层循环结束，i++。 i = 1时： array[2] &gt; array[3] : 交换2和4：[1, 2, 0, 4, 5]，内层的j继续遍历，j++。 array[3] &lt; array[4] : 不交换，i = 1的外层循环结束，i++。 i = 2 时： array[1] &gt; array[2] : 交换2和0：[1, 0, 2, 4, 5]，内层的j继续遍历，j++，直到退出i=2的外层循环，i++。 i = 3 时： array[0] &gt; array[1] : 交换1和0：[0, 1, 2, 4, 5]，内层的j继续遍历，j++，直到退出i=3的外层循环，i++。 i = 4 时：不符合外层循环的边界条件，不进行外层循环，排序结束。 代码实现我们来看一下冒泡排序的代码： 123456789101112131415func bubbleSort(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; for i in 0 ..&lt; array.count - 1 &#123; for j in 0 ..&lt; array.count - 1 - i &#123; if array[j] &gt; array[j+1] &#123; array.swapAt(j, j+1) &#125; &#125; &#125; return array&#125; 从上面的代码我们可以清楚地看到循环遍历的边界条件和交换时机。同样地，我们添加上log，将冒泡排序每次交换后的数组打印出来（为了进行对比，笔者将交换排序的log也打印了出来）： 123456789101112131415161718original array:[4, 1, 2, 5, 0]switch sort...[1, 4, 2, 5, 0][0, 4, 2, 5, 1][0, 2, 4, 5, 1][0, 1, 4, 5, 2][0, 1, 2, 5, 4][0, 1, 2, 4, 5]bubble sort...[1, 4, 2, 5, 0][1, 2, 4, 5, 0][1, 2, 4, 0, 5][1, 2, 0, 4, 5][1, 0, 2, 4, 5][0, 1, 2, 4, 5] 从上面两组打印可以看出，冒泡排序算法解决了交换排序算法的不足： 原来就处于靠前位置的1，2两个元素，在排序的过程中一直是靠前的。 原来处于末尾的0元素，在冒泡排序的过程中一点一点地向前移动，最终到了应该处于的位置。 现在我们知道冒泡排序是好于交换排序的，而且它的做法是相邻元素的两两比较：如果是逆序（左大右小）的话就做交换。 那么如果在排序过程中，数组已经变成有序的了，那么再进行两两比较就很不划算了。 为了证实上面这个排序算法的局限性，我们用新的测试用例来看一下： 1var originalArray = [2,1,3,4,5] 而且这次我们不仅仅在交换以后打log，也记录一下作比较的次数： 123456789101112131415161718192021func bubbleSort(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; var compareCount = 0 for i in 0 ..&lt; array.count - 1 &#123; for j in 0 ..&lt; array.count - 1 - i &#123; compareCount += 1 print("No.\(compareCount) compare \(array[j]) and \(array[j+1])") if array[j] &gt; array[j+1] &#123; array.swapAt(j, j+1) //keeping index of j is the smaller one print("after swap: \(array)") &#125; &#125; &#125; return array&#125; 打印结果： 12345678910111213141516original array:[2, 1, 3, 4, 5]bubble sort...No.1 compare 2 and 1after swap: [1, 2, 3, 4, 5] //already sorted, but keep comparingNo.2 compare 2 and 3No.3 compare 3 and 4No.4 compare 4 and 5No.5 compare 1 and 2No.6 compare 2 and 3No.7 compare 3 and 4No.8 compare 1 and 2No.9 compare 2 and 3No.10 compare 1 and 2` 从打印的结果可以看出，其实在第一次交换过之后，数组已经是有序的了，但是该算法还是继续在比较，做了很多无用功，能不能有个办法可以让这种两两比较在已知有序的情况下提前结束呢？答案是肯定的。 提前结束这个操作很容易，我们只需要跳出最外层的循环就好了。关键是这个时机：我们需要让算法自己知道什么时候数组已经是有序的了。 是否已经想到了呢？就是在一次内循环过后，如果没有发生元素交换，就说明数组已经是有序的，不需要再次缩小内循环的范围继续比较了。所以我们需要在外部设置一个布尔值的变量来标记“该数组是否有序”： 我们将这个算法称为：advanced bubble sort 12345678910111213141516171819202122232425func bubbleSortAdvanced(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; for i in 0 ..&lt; array.count - 1 &#123; //bool switch var swapped = false for j in 0 ..&lt; array.count - i - 1 &#123; if array[j] &gt; array [j+1] &#123; array.swapAt(j, j+1) swapped = true; &#125; &#125; //if there is no swapping in inner loop, it means the the part looped is already sorted, //so it's time to break if (swapped == false)&#123; break &#125; &#125; return array &#125; 从上面的代码可以看出，在第一个冒泡排序的算法之内，只添加了一个swapped这个布尔值，默认为false： 如果在当前内循环里面没有发生过元素交换，则说明当前内循环范围的元素都是有序的；那么就说明后续的内循环范围的元素也是有序的（因为内循环每次迭代后都会缩小），就可以跳出循环了。 反之，如果在当前内循环里发生过元素交换，则说明当前内循环很可能是无序的（也可能是有序的，但是有序性需要在下一个内循环中验证，所以还是不能提前退出，还需要进行一次内循环）。 为了验证上面这个改进冒泡排序是否能解决最初给出的冒泡排序的问题，我们添加上对比次数的log： 123456789101112131415161718192021222324252627original array:[2, 1, 3, 4, 5]bubble sort...No.1 compare 2 and 1after swap: [1, 2, 3, 4, 5]No.2 compare 2 and 3No.3 compare 3 and 4No.4 compare 4 and 5No.5 compare 1 and 2No.6 compare 2 and 3No.7 compare 3 and 4No.8 compare 1 and 2No.9 compare 2 and 3No.10 compare 1 and 2bubble sort time duration : 1.96msadvanced bubble sort...No.1 compare 2 and 1after swap: [1, 2, 3, 4, 5]No.2 compare 2 and 3No.3 compare 3 and 4No.4 compare 4 and 5No.5 compare 1 and 2No.6 compare 2 and 3No.7 compare 3 and 4 我们可以看到，在使用改进的冒泡排序后，对比的次数少了3次。之所以没有立即返回，是因为即使在交换完变成有序数组以后，也无法在当前内循环判断出是有序的。需要在下次内循环才能验证出来。 因为数组的元素数量比较小，所以可能对这个改进所达到的效果体会得不是很明显。现在我们增加一下数组元素的个数，并用记录比较总和的方式来看一下二者的区别： 123456789original array:[2, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]bubble sort...total compare count： 91advanced bubble sort...total compare count： 25 从比较结果可以看出，这两种算法在该测试样本下的差距是比较大的，而且随着元素个数的增多这个差距会越来越大（因为做了更多没有意义的比较）。 虽然这种测试样本比较极端，但是在某种意义上还是优化了最初的冒泡排序算法。一般在网上的冒泡排序算法应该都能看到这个优化版的。 现在我们知道这个优化版的冒泡排序算法可以在知道当前数组已经有序的时候提前结束，但是毕竟不断的交换还是比较耗费性能的，有没有什么方法可以只移动一次就能做好当前元素的排序呢？答案又是肯定的，这就引出了笔者即将介绍的选择排序算法。 选择排序算法讲解选择排序也是两层循环： 外层循环的边界是[0,array.count-1)，index为i。 内层循环的边界是[i+1,array.count)，index为j。可以看到内层的范围也是不断缩小的，而且范围的前端一直后移，后端保持不变。 具体做法是： 在外层循环的开始，将i作为最小值index（很可能不是该数组的最小值）。 在内层循环里面找到当前内层循环范围内的最小值，并与已经记录的最小值作比较： 如果与当前记录的最小值index不同，则替换 如果与当前记录的最小值index相同，则不替换 我们还是用手写迭代的方式看一下选择排序的机制，使用的数组和上面交换排序和冒泡排序（非优化版）的数组一致：[4, 1, 2, 5, 0] i = 0 时： 记录当前的最小值的index为0，当前最小值为4。 内层循环开始，找到[1,5)之间的最小值为0，0的index为4，与当前最小值的index0不同，所以二者要做交换。交换后的数组：[0, 1, 2, 5, 4]。当前内层循环结束，i++。 i = 1 时： 记录当前的最小值的index为1，当前最小值为1。 内层循环开始，找到[2,5)之间的最小值为1，与当前记录的最小值index相同。也就是说后面没有比1还要小的了，不做交换。当前内层循环结束，i++。 i = 2 时： 记录当前的最小值的index为2，当前最小值为2。 内层循环开始，找到[3,5)之间的最小值为2，与当前记录的最小值index相同。也就是说后面没有比1还要小的了，不做交换。当前内层循环结束，i++。 i = 3 时： 记录当前的最小值的index为3，当前最小值为2。 内层循环开始，找到[4,5)之间的最小值为4，4的index为4，与当前记录的最小值index3不同，所以二者要做交换。交换后的数组：[0, 1, 2, 4, 5]。当前内层循环结束，i++。 i = 4 时：不符合外层循环的边界条件，不进行外层循环，排序结束。 我们可以看到，同样的初始序列，使用选择排序只进行了2次交换，因为它知道需要替换的最小值是什么，做了很少没意义的交换。 代码实现我们用代码来实现一下上面选择排序的算法： 1234567891011121314151617181920212223func selectionSort(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; for i in 0 ..&lt; array.count - 1&#123; var min = i for j in i + 1 ..&lt; array.count &#123; if array[j] &lt; array[min] &#123; min = j &#125; &#125; //if min has changed, it means there is value smaller than array[min] //if min has not changed, it means there is no value smallter than array[min] if i != min &#123; array.swapAt(i, min) &#125; &#125; return array&#125; 从上面的代码可以看到，在这里使用了min这个变量记录了当前外层循环所需要被比较的index值，如果当前外层循环的内层循环内部找到了比这个最小值还小的值，就替换他们。 下面我们使用log来看一下此时选择排序作替换的次数： 1234567891011121314original array:[4, 1, 2, 5, 0]advanced bubble sort...after swap: [1, 4, 2, 5, 0]after swap: [1, 2, 4, 5, 0]after swap: [1, 2, 4, 0, 5]after swap: [1, 2, 0, 4, 5]after swap: [1, 0, 2, 4, 5]after swap: [0, 1, 2, 4, 5]selection sort...after swap: [0, 1, 2, 5, 4]after swap: [0, 1, 2, 4, 5] 从上面的log可以看出二者的对比应该比较明显了。 为了进一步验证选择排序的性能，笔者在网上找到了两个工具： 计算程序运行时间的类：executionTimeInterval.swift 生成各种类型随机数的Array的分类：Array+Extension.swift 首先看executionTimeInterval.swift的实现： 1234567891011121314151617181920//time intervalpublic func executionTimeInterval(block: () -&gt; ()) -&gt; CFTimeInterval &#123; let start = CACurrentMediaTime() block(); let end = CACurrentMediaTime() return end - start&#125;//formatted timepublic extension CFTimeInterval &#123; public var formattedTime: String &#123; return self &gt;= 1000 ? String(Int(self)) + "s" : self &gt;= 1 ? String(format: "%.3gs", self) : self &gt;= 1e-3 ? String(format: "%.3gms", self * 1e3) : self &gt;= 1e-6 ? String(format: "%.3gµs", self * 1e6) : self &lt; 1e-9 ? "0s" : String(format: "%.3gns", self * 1e9) &#125;&#125; 第一个函数以block的形式传入需要测试运行时间的函数，返回了函数运行的时间。 第二个函数是CFTimeInterval的分类，将秒数添加了单位：毫秒级的以毫秒显示，微秒级的以微秒显示，大于1秒的以秒单位显示。 使用方法是：将两个swift文件拖进playground里面的Sources文件夹里，并点击二者后，进入playground内部： 123456var selectionSortedArray = [Int]()var time4 = executionTimeInterval&#123; selectionSortedArray = selectionSort(&amp;originalArray4) //要测试的函数&#125;print("selection sort time duration : \(time4.formattedTime)") //打印出时间 再来看一下Array+Extension.swift类： 先介绍其中的一个方法，生成随机数组： 1234567891011121314import Foundationextension Array &#123; static public func randomArray(size: Int, maxValue: UInt) -&gt; [Int] &#123; var result = [Int](repeating: 0, count:size) for i in 0 ..&lt; size &#123; result[i] = Int(arc4random_uniform(UInt32(maxValue))) &#125; return result &#125;&#125; 这个方法只需要传入数组的大小以及最大值就可以生成一个不超过这个最大值的随机数组。 比如我们要生成一个数组长度为10，最大值为100的数组： 12var originalArray = Array&lt;Int&gt;.randomArray(size: inputSize, maxValue:100)//originalArray:[87, 56, 54, 20, 86, 33, 41, 9, 88, 55] 那么现在有了上面两个工具，我们就可以按照我们自己的意愿来生成测试用例数组，并且打印出所用算法的执行时间。我们现在生成一个数组长度为10，最大值为100的数组，然后分别用优化的冒泡排序和选择排序来看一下二者的性能： 12345678original array:[1, 4, 80, 83, 92, 63, 83, 23, 9, 85]advanced bubble sort...advanced bubble sort result: [1, 4, 9, 23, 63, 80, 83, 83, 85, 92] time duration : 8.53msselection sort...selection sort result: [1, 4, 9, 23, 63, 80, 83, 83, 85, 92] time duration : 3.4ms 我们现在让数组长度更长一点:一个长度为100，最大值为200： 12345advanced bubble sort...advanced bubble sort sorted elemets: 100 time duration : 6.27sselection sort...selection sort sorted elemets: 100 time duration : 414ms 可以看到，二者的差别大概在12倍左右。这个差别已经很大了，如果说用选择排序需要1天的话，冒泡排序需要12天。 现在我们学习了选择排序，知道了它是通过减少交换次数来提高排序算法的性能的。 但是关于排序，除了交换操作以外，对比操作也是需要时间的：选择排序通过内层循环的不断对比才得到了当前内层循环的最小值，然后进行后续的判断和操作。 那么有什么办法可以减少对比的次数呢？猜对了，答案又是肯定的。这就引出了笔者下面要说的算法：插入排序算法。 插入排序算法讲解插入排序的基本思想是：从数组中拿出一个元素（通常就是第一个元素）以后，再从数组中按顺序拿出其他元素。如果拿出来的这个元素比这个元素小，就放在这个元素左侧；反之，则放在右侧。整体上看来有点和玩儿扑克牌的时候将刚拿好的牌来做排序差不多。 选择排序也是两层循环： 外层循环的边界是[1,array.count)，index为i。 内层循环开始的时候初始index j = i，然后使用一个while循环，循环条件是j&gt;0 &amp;&amp; array[j] &lt; array[j - 1],循环内侧是交换j-1和j的元素，并使得j-1。可以简单理解为如果当前的元素比前一个元素小，则调换位置；反之进行下一个外层循环。 下面我们还是用手写迭代的方式看一下插入排序的机制，使用的数组和上面选择排序的数组一致：[4, 1, 2, 5, 0] i = 1 时： j = 1：array[1] &lt; array[0]， 交换4和1：[1, 4, 2, 5, 0]，j-1之后不符合内层循环条件，退出内层循环，i+1。 i = 2 时： j = 2，array[3] &lt; array[2]，交换4和2：[1, 2, 4, 5, 0]，j向左移动，array[2] &gt; array[1]，不符合内层循环条件，退出内层循环，i+1。 i = 3 时： j = 3，array[3] &gt; array[2]，不符合内层循环条件，退出内层循环，i+1。 i = 4 时： j = 4，array[4] &lt; array[3]，交换5和0：[1, 2, 4, 0, 5]，j -1。 j = 3，array[3] &lt; array[2]，交换4和0：[1, 2, 0, 4, 5]，j -1。 j = 2，array[2] &lt; array[1]，交换4和0：[1, 0, 2, 4, 5]，j -1。 j = 1，array[1] &lt; array[0]，交换1和0：[0, 1, 2, 4, 5]，j -1 = 0，不符合内层循环条件，退出内层循环，i+1 = 5，不符合外层循环条件，排序终止。 从上面的描述可以看出，和选择排序相比，插入排序的内层循环是可以提前推出的，其条件就是array[j] &gt;= array[j - 1],也就是说，当前index为j的元素只要比前面的元素大，那么该内层循环就立即退出，不需要再排序了，因为该算法从一开始就是小的放前面，大的放后面。 代码实现下面我们通过代码来看一下如何实现插入排序算法: 1234567891011121314func insertionSort(_ array: inout [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; for i in 1..&lt;array.count &#123; var j = i while j &gt; 0 &amp;&amp; array[j] &lt; array[j - 1] &#123; array.swapAt(j - 1, j) j -= 1 &#125; &#125; return array&#125; 从上面的代码可以看出插入排序内层循环的条件：j &gt; 0 &amp;&amp; array[j] &lt; array[j - 1]。只要当前元素比前面的元素小，就会一直交换下去；反之，当大于等于前面的元素，就会立即跳出循环。 之前笔者有提到相对于选择排序，说插入排序可以减少元素之间对比的次数，下面我们通过打印对比次数来对比一下两种算法： 使用元素个数为50，最大值为50的随机数组： 1234567selection sort...compare times:1225selection sort time duration : 178msinsertion sort...compare times:519insertion sort time duration : 676ms 我们可以看到，使用选择排序的比较次数比插入排序的比较次数多了2倍。但是遗憾的是整体的性能选择排序要高于插入排序。 也就是说虽然插入排序的比较次数少了，但是交换的次数却比选择排序要多，所以性能上有时可能不如选择排序。 注意，这不与笔者之前的意思相矛盾，笔者只是说在减少比较次数上插入排序是优于选择排序的，但没有说插入排序整体上优于选择排序。 那么有何种特性的数组可以让排序算法有其用武之地呢？ 从上面使用插入排序来排序[4, 1, 2, 5, 0]这个数组的时候，我们可以看到，因为0这个元素已经在末尾了，所以在j=4的时候我们费了好大劲才把它移到前面去。 那么将这个情况作为一个极端，我们可以这样想：如果这个数组里的元素里的index大致于最终顺序差不多的情况是不是就不用做这么多的搬移了？。这句话听起来像是理所当然的话，但是有一种数组属于“基本有序”的数组，这种数组也是无需的，但是它在整体上是有序的，比如： 1[2,1,3,6,4,5,9,7,8] 用笔者的话就叫做整体有序，部分无序。 我们可以简单用这个数组来分别进行选择排序和插入排序做个比较： 1234567selection sort...compare times:36selection sort time duration : 4.7msinsertion sort...compare times:5insertion sort time duration : 3.2ms 我们可以看到插入排序在基本有序的测试用例下表现更好。为了让差距更明显，笔者在Array+Extension.swift文件里增加了一个生成基本有序随机数组的方法： 12345678910111213141516171819202122static public func nearlySortedArray(size: Int, gap:Int) -&gt; [Int] &#123; var result = [Int](repeating: 0, count:size) for i in 0 ..&lt; size &#123; result[i] = i &#125; let count : Int = size / gap var arr = [Int]() for i in 0 ..&lt; count &#123; arr.append(i*gap) &#125; for j in 0 ..&lt; arr.count &#123; let swapIndex = arr[j] result.swapAt(swapIndex,swapIndex+1) &#125; return result&#125; 该函数需要传入数组的长度以及需要打乱顺序的index的跨度，它的实现是这样子的： 首先生成一个完全有序的序列。 将数组长度除以跨度来得出需要交换的index的个数count。 根据这个count可以得出需要交换的index，把这些index放在一个新的arr里面 便利这个arr来取出index，将之前生成好的w安全有序的数组的index于index+1做交换。 举个例子，如果我们生成一个数组长度为12，跨度为3的基本有序的数组，就可以这么调用： 12var originalArray = Array&lt;Int&gt;.nearlySortedArray(size: 12, gap: 3)//[1, 0, 2, 4, 3, 5, 7, 6, 8, 10, 9, 11] 跨度为3，说明有12/3 = 4 - 1 = 3 个元素需要调换位置，序号分别为0，3，6，9。所以序号为0，1；3，4；6，7；9，10的元素被调换了位置，可以看到调换后的数组还是基本有序的。 现在我们可以用一个比较大的数组来验证了： 1var originalArray = Array&lt;Int&gt;.nearlySortedArray(size: 100, gap: 10) 结果为： 1234567selection sort...compare times:4950selection sort time duration : 422msinsertion sort...compare times:10insertion sort time duration : 56.4ms 我们可以看到差距是非常明显的，插入排序的性能是选择排序的性能的近乎10倍 归并排序算法讲解归并排序使用了算法思想里的分治思想（divide conquer）。顾名思义，就是将一个大问题，分成类似的小问题来逐个攻破。在归并排序的算法实现上，首先逐步将要排序的数组等分成最小的组成部分（通常是1各元素），然后再反过来逐步合并。 用一张图来体会一下归并算法的实现过程： 上图面的虚线箭头代表拆分的过程；实线代表合并的过程。仔细看可以发现，拆分和归并的操作都是重复进行的，在这里面我们可以使用递归来操作。 首先看一下归并的操作： 归并的操作就是把两个数组（在这里这两个数组的元素个数通常是一致的）合并成一个完全有序数组。 归并操作的实现步骤是： 新建一个空数组，该数组用于存放合并后的有序数组。 两个传入的数组从index 0 开始两两比较，较小的元素放在新建的空数组中，index + 1; 较大的元素不作操作，index 不变，然后继续两两比较。知道index移到末尾为止。 个别情况当两个数组长度不一致的情况下需要将数组里剩余的元素放在新建的数组中。 代码实现我们来看一下归并排序算法的代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546func _merge(leftPile: [Int], rightPile: [Int]) -&gt; [Int] &#123; var leftIndex = 0 //left pile index, start from 0 var rightIndex = 0 //right pile index, start from 0 var sortedPile = [Int]() //sorted pile, empty in the first place while leftIndex &lt; leftPile.count &amp;&amp; rightIndex &lt; rightPile.count &#123; //append the smaller value into sortedPile if leftPile[leftIndex] &lt; rightPile[rightIndex] &#123; sortedPile.append(leftPile[leftIndex]) leftIndex += 1 &#125; else if leftPile[leftIndex] &gt; rightPile[rightIndex] &#123; sortedPile.append(rightPile[rightIndex]) rightIndex += 1 &#125; else &#123; //same value, append both of them and move the corresponding index sortedPile.append(leftPile[leftIndex]) leftIndex += 1 sortedPile.append(rightPile[rightIndex]) rightIndex += 1 &#125; &#125; //left pile is not empty while leftIndex &lt; leftPile.count &#123; sortedPile.append(leftPile[leftIndex]) leftIndex += 1 &#125; //right pile is not empty while rightIndex &lt; rightPile.count &#123; sortedPile.append(rightPile[rightIndex]) rightIndex += 1 &#125; return sortedPile&#125; 因为该函数是归并排序函数内部调用的函数，所以在函数名称的前面添加了下划线。仅仅是为了区分，并不是必须的。 从上面代码可以看出合并的实现逻辑： 新建空数组，初始化两个传入数组的index为0 两两比较两个数组index上的值，较小的放在新建数组里面并且index+1。 最后检查是否有剩余元素，如果有则添加到新建数组里面。 理解了合并的算法，下面我们看一下拆分的算法。拆分算法使用了递归： 12345678910func mergeSort(_ array: [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; let middleIndex = array.count / 2 let leftArray = mergeSort(Array(array[0..&lt;middleIndex])) // recursively split left part of original array let rightArray = mergeSort(Array(array[middleIndex..&lt;array.count])) // recursively split right part of original array return _merge(leftPile: leftArray, rightPile: rightArray) // merge left part and right part&#125; 我们可以看到mergeSort调用了自身，它的递归终止条件是!(array.count &gt;1)，也就是说当数组元素个数 = 1的时候就会返回，会触发调用栈的出栈。 从这个递归函数的实现可以看到它的作用是不断以中心店拆分传入的数组。根据他的递归终止条件，当数组元素 &gt; 1的时候，拆分会继续进行。而下面的合并函数只有在递归终止，开始出栈的时候才开始真正执行。也就是说在拆分结束后才开始进行合并，这样符合了上面笔者介绍的归并算法的实现过程。 上段文字需要反复体会。 为了更形象体现出归并排序的实现过程，可以在合并函数(_merge)内部添加log来验证上面的说法： 123456789func _merge(leftPile: [Int], rightPile: [Int]) -&gt; [Int] &#123; print("\nmerge left pile:\(leftPile) | right pile:\(rightPile)") ... print("sorted pile：\(sortedPile)") return sortedPile&#125; 而且为了方便和上图作比较，初始数组可以取图中的[3, 5, 9, 2, 7, 4, 8, 0]。运行一下看看效果： 12345678910111213141516171819202122232425original array:[3, 5, 9, 2, 7, 4, 8, 0]merge sort...merge left pile:[3] | right pile:[5]sorted pile：[3, 5]merge left pile:[9] | right pile:[2]sorted pile：[2, 9]merge left pile:[3, 5] | right pile:[2, 9]sorted pile：[2, 3, 5, 9]merge left pile:[7] | right pile:[4]sorted pile：[4, 7]merge left pile:[8] | right pile:[0]sorted pile：[0, 8]merge left pile:[4, 7] | right pile:[0, 8]sorted pile：[0, 4, 7, 8]merge left pile:[2, 3, 5, 9] | right pile:[0, 4, 7, 8]sorted pile：[0, 2, 3, 4, 5, 7, 8, 9] 我们可以看到，拆分归并的操作是先处理原数组的左侧部分，然后处理原数组的右侧部分。这是为什么呢？ 我们来看下最初函数是怎么调用的： 最开始我们调用函数： 12345678910func mergeSort(_ array: [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; let middleIndex = array.count / 2 let leftArray = mergeSort(Array(array[0..&lt;middleIndex])) //1 let rightArray = mergeSort(Array(array[middleIndex..&lt;array.count])) //2 return _merge(leftPile: leftArray, rightPile: rightArray) //3&#125; 在//1这一行开始了递归，这个时候数组是原数组，元素个数是8，而调用mergeSort时原数组被拆分了一半，是4。而4&gt;1，不满足递归终止的条件，继续递归，直到符合了终止条件（[3]）,递归开始返回。以为此时最初被拆分的是数组的左半部分，所以左半部分的拆分会逐步合并，最终得到了[2,3,5,9]。 同理，再回到了最初被拆分的数组的右半部分（上面代码段中的//2），也是和左测一样的拆分和归并，得到了右侧部分的归并结果：[0,4,7,8。 而此时的递归调用栈只有一个mergeSort函数了，mergeSort会进行最终的合并（上面代码段中的//3），调用_merge函数，得到了最终的结果：[0, 2, 3, 4, 5, 7, 8, 9]。 关于归并排序的性能：由于使用了分治和递归并且利用了一些其他的内存空间，所以其性能是高于上述介绍的所有排序的，不过前提是初始元素量不小的情况下。 我们可以将选择排序和归并排序做个比较：初始数组为长度500，最大值为500的随机数组： 12345selection sort...selection sort time duration : 12.7smerge sort...merge sort time duration : 5.21s 可以看到归并排序的算法是优与选择排序的。 现在我们知道归并排序使用了分治思想而且使用了递归，能够高效地将数组排序。其实还有一个也是用分治思想和递归，但是却比归并排序还要优秀的算法 - 快速排序算法。 快速排序快速排序算法被称之为20世纪十大算法之一，也是各大公司面试比较喜欢考察的算法。 算法讲解快速排序的基本思想是：通过一趟排序将带排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。 上述文字摘自《大话数据结构》 它的实现步骤为： 从数列中挑出一个元素（挑选的算法可以是随机，也可以作其他的优化），称为”基准”（pivot）。 重新对数组进行排序：所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面，相同的放两边。 递归地进行分区操作，继续把小于基准值元素的子数列和大于基准值元素的子数列排序。 从上面的描述可以看出，分区操作是快速排序中的核心算法。下面笔者结合实例来描述一下分区操作的过程。 首先拿到初始的数组：[5,4,9,1,3,6,7,8,2] 选择5作为pivot。 从剩下部分的两端开始：左侧1的标记为low，最右侧2的标记为high。 先看j：2 &lt; 5 , 交换5和2，j不变 ：[2,4,9,1,3,6,7,8,5] ； 再看i：2 &lt; 5 , i ++ ；4 &lt; 5, i++；9 &gt; 5，交换 9 和 5，i不变[2,4,5,1,3,6,7,8,9]。 代码实现使用Swift的filter函数因为在Swift中有一个数组的filter函数可以找出数组中符合某范围的一些数值，所以笔者先介绍一个会用该函数的简单的快速排序的实现： 12345678910func quickSort0&lt;T: Comparable&gt;(_ array: [T]) -&gt; [T] &#123; guard array.count &gt; 1 else &#123; return array &#125; let pivot = array[array.count/2] let less = array.filter &#123; $0 &lt; pivot &#125; let greater = array.filter &#123; $0 &gt; pivot &#125; return quickSort0(less) + quickSort0(greater)&#125; 不难看出这里面使用了递归：选中pivot以后，将数组分成了两个部分，最后将它们合并在一起。虽然这里面使用了Swift里面内置的函数来找出符合这两个个部分的元素，但是读者可以通过这个例子更好地理解快速排序的实现方式。 使用取index = 0 的partition函数除了使用swift内置的filter函数，当然我们也可以自己实现分区的功能，通常使用的是自定义的partition函数。 123456789101112131415161718192021222324func _partition(_ array: inout [Int], low: Int, high: Int) -&gt; Int&#123; var low = low var high = high let pivotValue = array[low] while low &lt; high &#123; while low &lt; high &amp;&amp; array[high] &gt;= pivotValue &#123; high -= 1 &#125; array[low] = array[high] while low &lt; high &amp;&amp; array[low] &lt;= pivotValue &#123; low += 1 &#125; array[high] = array[low] &#125; array[low] = pivotValue return low&#125; 从代码实现可以看出，最初在这里选择的pivotValue是当前数组的第一个元素。 然后从数组的最右侧的index逐渐向左侧移动，如果值大于pivotValue，那么index-1；否则直接将high与low位置上的元素调换；同样左侧的index也是类似的操作。 该函数执行的最终效果就是将最初的array按照选定的pivotValue前后划分。 那么_partition如何使用呢？ 1234567891011func quickSort1(_ array: inout [Int], low: Int, high: Int)&#123; guard array.count &gt; 1 else &#123; return &#125; if low &lt; high &#123; let pivotIndex = _partition(&amp;array, low: low, high: high) quickSort1(&amp;array, low: low, high: pivotIndex - 1) quickSort1(&amp;array, low: pivotIndex + 1, high: high) &#125; &#125; 外层调用的quickSort1是一个递归函数，不断地进行分区操作，最终得到排好序的结果。 我们将上面实现的归并排序，使用swift内置函数的快速排序，以及自定义partition函数的快速排序的性能作对比： 123456merge sort...merge sort time duration : 4.85squick sort...quick sort0 time duration : 984ms //swift filter functionquick sort1 time duration : 2.64s //custom partition 上面的测试用例是选择随机数组的，我们看一下测试用例为元素个数一致的基本有序的数组试一下： 123456merge sort...merge sort time duration : 4.88squick sort...quick sort0 time duration : 921msquick sort1 time duration : 11.3s 虽然元素个数一致，但是性能却差了很多，是为什么呢？因为我们在分区的时候，pivot的index强制为第一个。那么如果这个第一个元素的值本来就非常小，那么就会造成分区不均的情况（前重后轻），而且由于是迭代操作，每次分区都会造成分区不均，导致性能直线下降。所以有一个相对合理的方案就是在选取pivot的index的时候随机选取。 使用随机选择pivotValue的partition函数实现方法肯简单，只需在分区函数里将pivotValue的index随机生成即可： 12345678910func _partitionRandom(_ array: inout [Int], low: Int, high: Int) -&gt; Int&#123; let x = UInt32(low) let y = UInt32(high) let pivotIndex = Int(arc4random() % (y - x)) + Int(x) let pivotValue = array[pivotIndex] ...&#125; 现在用一个数组长度和上面的测试用例一致的基本有序的数组来测试一下随机选取pivotValue的算法： 1234567merge sort...merge sort time duration : 4.73squick sort...quick sort0 time duration : 866msquick sort1 time duration : 15.1s //fixed pivote indexquick sort2 time duration : 4.28s //random pivote index 我们可以看到当随机抽取pivot的index的时候，其运行速度速度是上面方案的3倍。 现在我们知道了3种快速排序的实现，都是根据pivotValue将原数组一分为二。但是如果数组中有大量的重复的元素，而且pivotValue很有可能落在这些元素里，那么显然上面这些算法对于这些可能出现多次于pivotValue重复的情况没有单独做处理。而为了很好解决存在与pivot值相等的元素很多的数组的排序，使用三路排序算法会比较有效果。 三路快速排序三路快速排序将大于，等于，小于pivotValue的元素都区分开，我们看一下具体的实现。先看一下partition函数的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455func swap(_ arr: inout [Int], _ j: Int, _ k: Int) &#123; guard j != k else &#123; return; &#125; let temp = arr[j] arr[j] = arr[k] arr[k] = temp&#125;func quickSort3W(_ array: inout [Int], low: Int, high: Int) &#123; if high &lt;= low &#123; return &#125; var lt = low // arr[low+1...lt] &lt; v var gt = high + 1 // arr[gt...high] &gt; v var i = low + 1 // arr[lt+1...i) == v let pivoteIndex = low let pivoteValue = array[pivoteIndex] while i &lt; gt &#123; if array[i] &lt; pivoteValue &#123; swap(&amp;array, i, lt + 1) i += 1 lt += 1 &#125;else if pivoteValue &lt; array[i]&#123; swap(&amp;array, i, gt - 1) gt -= 1 &#125;else &#123; i += 1 &#125; &#125; swap(&amp;array, low, lt) quickSort3W(&amp;array, low: low, high: lt - 1) quickSort3W(&amp;array, low: gt, high: high) &#125;func quickSort3(_ array: inout [Int] )&#123; quickSort3W(&amp;array, low: 0, high: array.count - 1) &#125; 主要看quickSort3W方法，这里将数组分成了三个区间，分别是大于，等于，小于pivote的值，对有大量重复元素的数组做了比较好的处理。 我们生成一个元素数量为500，最大值为5的随机数组看一下这些快速排序算法的性能： 123quick sort1 time duration : 6.19s //fixed pivote indexquick sort2 time duration : 8.1s //random pivote indexquick sort3 time duration : 4.81s //quick sort 3 way 可以看到三路快速排序（quick sort 3 way）在处理大量重复元素的数组的表现最好。 对于三路快速排序，我们也可以使用Swift内置的filter函数来实现: 1234567891011func quicksort4(_ array: [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; let pivot = array[array.count/2] let less = array.filter &#123; $0 &lt; pivot &#125; let equal = array.filter &#123; $0 == pivot &#125; let greater = array.filter &#123; $0 &gt; pivot &#125; return quicksort4(less) + equal + quicksort4(greater)&#125; 以上，介绍完了快速排序在Swift中的5中实现方式。 最后的话总结本文讲解了算法的一些基本概念以及结合了Swift代码的实现讲解了冒泡排序，选择排序，插入排序，归并排序，快速排序。相信认真阅读本文的读者能对这些算法有进一步的了解。 关于算法学习的思考关于算法的学习，笔者有一些思考想分享出来，也有可能有不对的地方，但笔者觉得有必要在这里说出来，希望可以引发读者的思考： 上图的Question是指问题；Mind是指想法，或者解决问题的思路；Code是指代码实现。 在阅读资料或书籍的算法学习过程，往往是按照图中1，2，3这些实线的路径进行的： 路径1：给出一个既定的问题后，马上给出解题策略 路径2：给出一个既定的问题后，马上给出算法实现 路径3：给出一个算法实现后，马上告诉你这些实现代码的意思 这些路径在算法的学习中虽然也是必不可少的，但是很容易给人一个错觉，这个错觉就是“我已经学会了这个算法了”。但是，仅仅是通过这些路径，对于真正理解算法，和今后对算法的应用还是远远不够的，原因是： 今后遇到的问题，几乎不可能与现在学习的问题一模一样，所以应该知其所以然，将问题本身抽象出来，达到触类旁通，举一反三。 有了一个新想法，如果没有足够的代码实现经验，很难以非常合理的方式用代码将其实现出来。所以应该增强将想法转化为代码的能力。 上面所说的两点的第一点，对应的是上图的路径4：给定一个策略或是设计，要思考这个策略或是设计是解决什么样的问题的，这样也就理解了这个策略或是设计的意义在哪里；而第二点对应的是上图中的路径5：怎样根据一个给定的策略来正确地，合理地用代码地实现出来；而上图中的路径6，笔者觉得也很重要：给定一份解决问题的代码，是否可以想到它所对应的问题是什么。 综上所述，笔者认为对于算法的学习，需要经常反复在问题，策略以及代码之间反复思考，这样才能真正地达到学以致用。]]></content>
      <categories>
        <category>Data Structure &amp; Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构 & 算法 in Swift （一）：Swift基础和数据结构]]></title>
    <url>%2F2019%2F08%2F29%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%26%20%E7%AE%97%E6%B3%95%20in%20Swift%20%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ASwift%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[写在前面从本文标题中的序号可以看出，本文是一个连载的开篇。而且这个连载的标题是：数据结构 &amp; 算法 in Swift。从这个连载的标题中可以看出，笔者分享的是使用Swift语言来实现所学的的数据结构和算法的知识。这里面需要解释两点：第一：为什么学习数据结构和算法？学习通用性知识，突破技能瓶颈：笔者做iOS开发也有两年了，这期间通过从项目，第三方源码，相关应用类的编程书籍提高了些技术水平。而作为没学过数据结构和算法的非科班大军中的一员，这些知识始终是绕不过去的。因为对此类知识的掌握程度会对今后编程技能的提高有着无可估量的影响，所以就决定学习了。 第二：为什么用Swift语言来实现？ 选择哪个语言并不重要，重要的是数据结构和算法本身的理解：通过两个星期的学习，如今笔者已经可以使用Swift语言来实现几种数据结构和算法了，但我相信如果我使用C语言或者Objective-C语言的话会学得更快些，因为在实现的时候由于对该语言的不熟悉导致在实现过程中踩了不少坑。不过可以反过来思考：如果我可以使用Swift来实现这些，那么我今后用C，Objective-C，甚至是Java就容易多了，再加上我还顺便学习了Swift不是么？ 如今Swift的势头还在上涨：笔者已经观察到很多新的库，教学都使用了Swift语言。而且听说一些面试的朋友在面试过程中多少有问过Swift相关的知识，一些公司的新项目也有用Swift写了。 该系列的最佳受众是那些已经会Swift，但是对数据结构和算法还没有过多接触过的iOS开发者。其次是那些不会Swift也不会数据结构和算法的iOS开发者，毕竟Swift是大势所趋。 不过对于那些非iOS开发者来说也同样适合，因为还是那句话：重点不在于使用哪种语言，而是数据结构和算法本身。除了第一篇会讲解一些在这个系列文章会使用到的Swift基础语法以外，后续的文章我会逐渐弱化对Swift语言的讲解，将重点放在数据结构和算法这里。而且后续我还会不断增加其他语言的实现（Java语言是肯定要加的，其他的语言还待定）。 好了，背景介绍完了，现在正式开始： 作为该系列的开篇，本文分为两个部分： Swift语法基础：讲解一下后续连载中讲到的数据结构和算法所涉及到的Swift语法知识（并不是很全面，也不是很深入，但是在实现数据结构和算法这块应该是够了）。 数据结构：简单介绍数据结构和算法的相关概念，以及用Swift来实现几个简单的数据结构（链表，栈，队列） 注：该系列涉及到的Swift语法最低基于Swift4.0。 Swift 语法基础Swift语法基础从以下几点来展开： 循环语句 泛型 guard 函数 集合 循环语句循环条件的开闭区间Swift将循环的开闭区间做了语法上的简化： 闭区间：12345678for index in 1...5 &#123; print("index: \(index)")&#125;// index : 1// index : 2// index : 3// index : 4// index : 5 半开闭区间：1234567for index in 1..&lt;5 &#123; print("index: \(index)")&#125;// index : 1// index : 2// index : 3// index : 4 循环的升序与降序上面两个例子都是升序的（index从小到大），我们来看一下降序的写法： 1234567for index in (1..&lt;5).reversed() &#123; print("index: \(index)")&#125;// index : 4// index : 3// index : 2// index : 1 降序的应用可以在下篇的冒泡排序算法中可以看到。 泛型使用泛型可以定义一些可复用的函数或类型，Swift中的Array和Dictionary都是泛型的集合。 为了体现出泛型的意义，下面举一个例子来说明一下： 实现这样一个功能:将传入该函数的两个参数互换。 整型的交换： 12345func swapTwoInts(_ a: inout Int, _ b: inout Int) &#123; let tmp = a a = b b = tmp&#125; 字符串的交换： 12345func swapTwoStrings(_ a: inout String, _ b: inout String) &#123; let tmp = a a = b b = tmp&#125; 浮点型的交换： 12345func swapTwoDoubles(_ a: inout Double, _ b: inout Double) &#123; let tmp = a a = b b = tmp&#125; 上面这三种情况的实现部分其实都是一样的，但仅仅是因为传入类型的不一致，导致对于不同的类型还要定义一个新的函数。所以如果类型有很多的话，定义的新函数也会很多，这样显然是不够优雅的。 此类问题可以使用泛型来解决： 12345func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) &#123; let tmp = a a = b b = tmp&#125; 上面函数中的T是泛型的固定写法，可以理解为“所有类型”。这样一来，我们可以传入任何相同的类型来作交换了。 泛型还有其他比较强大的功能，由于在后续的数据结构和算法的讲解里面可能不会涉及到，所以在这里先不赘述了。有兴趣的朋友可以参考官方文档：Swift：Generics guard guard是 swift 2.0推出的新的判断语句的用法。 与if语句相同的是，guard也是基于一个表达式的布尔值去判断一段代码是否该被执行。与if语句不同的是，guard只有在条件不满足的时候才会执行这段代码。你可以把guard近似的看做是Assert，但是你可以优雅的退出而非崩溃 使用guard语法，可以先对每个条件逐一做检查，如果不符合条件判断就退出（或者进行其他某些操作）。这就会让人容易看出来什么条件会让这个函数退出（或者进行其他某些操作）。 可以用一个例子来分别使用if和guard来实现，体会二者的区别： 使用if-else1234567891011121314151617181920212223242526//money: holding moneny (用户持有的钱数)//price: product price (商品的价格)//capacity: bag capacity (用户用来装商品的袋子容量)//volume: product size (商品的大小)func buying1( money: Int , price: Int , capacity: Int , volume: Int)&#123; if money &gt;= price&#123; if capacity &gt;= volume&#123; print("Start buying...") print("\(money-price) money left after buying.") print("\(capacity-volume) capacity left after buying.") &#125;else&#123; print("No enough capacity") &#125; &#125;else&#123; print("No enough money") &#125;&#125; 从上面的逻辑可以看出，当同时满足： 用户的钱数&gt;商品价格 用户用来装商品的袋子容量&gt;商品的大小 这两个情况的时候，购买才会进行，其他所有情况都无法引发购买。 对于大多数习惯使用if-else的朋友来说，上面的代码立即起来并没有难度，但是相同的逻辑，我们看一下使用guard之后的效果： 使用guard12345678910111213141516func buying2( money: Int , price: Int , capacity: Int , volume: Int)&#123; guard money &gt;= price else&#123; print("No enough money") return &#125; guard capacity &gt;= volume else&#123; print("No enough capacity") return &#125; print("Start buying...") print("\(money-price) money after buying.") print("\(capacity-volume) capacity left after buying.")&#125; 从上面的实现可以看出： 使用guard以后，将money &lt; price和capacity &lt; volume 这两个情况首先排除掉并填上了相应的处理代码。 在两个guard下面才是真正正确逻辑后的处理代码。 因此通过两个guard判断的语句，我们知道该函数所处理的正确逻辑是什么，非常清晰。 函数因为后续的数据结构和算法的讲解是离不开函数的使用的，所以在这里简单介绍一下Swift中函数的使用。 无返回值的函数 有返回值的函数 省略函数的外部参数名 值传递和引用传递 无返回值的函数123456func log(message: String) &#123; print("log: \(message)!")&#125;log(message: "memory warning")// output: log: memory warning! 有返回值的函数1234567func logString(string: String) -&gt; String &#123; return "log: " + string&#125;let logStr = logString(string: "memory warning!")print("\(logStr)")// output: log: memory warning! 省略函数外部参数名通过在函数形参前面加上_,可以起到在调用时省略外部参数的作用： 123456func logMessage(_ message: String) &#123; print("log: \(message)!")&#125;logMessage("memory warning")// output: log: memory warning! 再来看一下两个参数的情况： 123456func addInt(_ a : Int ,_ b : Int)&#123; print("sum is \(a + b)")&#125;addInt(3, 4)//output : sum is 7 值传递和引用传递Swift中，struct是按值传递，class是按引用传递。数组和字典在Swift里是属于struct，所以需要如果在一个函数里要修改传入的数组，需要做特殊处理： 123456789101112var originalArr = [2,1,3]func removeLastInArray(_ array: inout [Int])&#123; array.removeLast()&#125;print("\n============ before removing: \(originalArr)")//[2, 1, 3]removeLastInArray(&amp;originalArr)print("============ after removing: \(originalArr)")//[2, 1] 在这里使用的inout关键字就是将传入的数组改为引用传递了。 集合Swift里的集合类型有：数组，集合，字典，下面来分别讲一下。 这三种类型都支持泛型，也就是说里面的元素可以是整数，字符串，浮点等等。 数组 Swift’s Array type is bridged to Foundation’s NSArray class. 可变数组与不可变数组12345// immutable arraylet immutableNumbers: [Int] = [1, 3, 5, 4, 4, 1]// mutable arrayvar mutableNumbers : [Int] = [2, 1, 5, 4, 1, 3] Swift中可以用let和var来分别声明可变和不可变数组：数组的添加删除等操作只能作用于可变数组。 数组的遍历123456789101112131415161718// iteration 1for value in mutableNumbers &#123; if let index = mutableNumbers.index(of: value) &#123; print("Index of \(value) is \(index)") &#125;&#125;// iteration 2mutableNumbers.forEach &#123; value in if let index = mutableNumbers.index(of: value) &#123; print("Index of \(value) is \(index)") &#125;&#125;// iteration 3for (index, value) in mutableNumbers.enumerated() &#123; print("Item \(index + 1): \(value)")&#125; 数组的操作1234567891011121314151617181920mutableNumbers.append(11)// Output: [2, 1, 5, 4, 1, 3, 11]mutableNumbers.insert(42, at: 4)// Output: [2, 1, 5, 4, 42, 1, 3, 11]mutableNumbers.swapAt(0, 1)// Output: [1, 2, 5, 4, 42, 1, 3, 11]mutableNumbers.remove(at: 1)// Output: [2, 5, 4, 42, 1, 3, 11]mutableNumbers.removeFirst()// Output: [5, 4, 42, 1, 3, 11]mutableNumbers.removeLast()// Output: [5, 4, 42, 1, 3]mutableNumbers.removeAll()//[] append函数的作用是在数组的末尾添加元素 swapAt函数的作用是交换在传入的两个index上的元素，该方法在下篇的排序算法中使用得非常频繁。 集合 Swift’s Set type is bridged to Foundation’s NSSet class. 集合的无序性，值的唯一性关于集合与数组的区别，除了数组有序，集合无序以外，数组内部的元素的数值可以不是唯一的；但是集合里元素的数值必须是唯一的，如果有重复的数值会算作是一个： 12345678//value in set is uniquelet onesSet: Set = [1, 1, 1, 1]print(onesSet)// Output: [1]let onesArray: Array = [1, 1, 1, 1]print(onesArray)// Output: [1, 1, 1, 1] 集合的遍历1234567891011121314151617let numbersSet: Set = [1, 2, 3, 4, 5]print(numbersSet)// Output: undefined order, e.g. [5, 2, 3, 1, 4]// iteration 1for value in numbersSet &#123; print(value)&#125;// output is in undefined order// iteration 2numbersSet.forEach &#123; value in print(value)&#125;// output is in undefined order 集合的操作123456789101112131415161718192021222324252627282930313233343536373839var mutableStringSet: Set = ["One", "Two", "Three"]let item = "Two"//containsif mutableStringSet.contains(item) &#123; print("\(item) found in the set")&#125; else &#123; print("\(item) not found in the set")&#125;//isEmptylet strings = Set&lt;String&gt;()if strings.isEmpty &#123; print("Set is empty")&#125;//countlet emptyStrings = Set&lt;String&gt;()if emptyStrings.count == 0 &#123; print("Set has no elements")&#125;//insertmutableStringSet.insert("Four")//remove 1mutableStringSet.remove("Three")//remove 2if let removedElement = mutableStringSet.remove("Six") &#123; print("\(removedElement) was removed from the Set")&#125; else &#123; print("Six is not found in the Set")&#125;//removeAll()mutableStringSet.removeAll()// [] 字典 A dictionary Key type must conform to the Hashable protocol, like a set’s value type. 字典的声明12345678//empty dictionaryvar dayOfWeek = Dictionary&lt;Int, String&gt;()var dayOfWeek2 = [Int: String]()//not empty dictionaryvar dayOfWeek3: [Int: String] = [0: "Sun", 1: "Mon", 2: "Tue"]print(dayOfWeek3)//output:[2: "Tue", 0: "Sun", 1: "Mon"] 可以看到字典的键值对也是无序的，它与声明时的顺序不一定一致。 字典的遍历1234567891011121314// iteration 1for (key, value) in dayOfWeek &#123; print("\(key): \(value)")&#125;// iteration 2for key in dayOfWeek.keys &#123; print(key)&#125;// iteration 3for value in dayOfWeek.values &#123; print(value)&#125; 字典的操作123456789101112131415161718192021222324252627282930313233343536// find valuedayOfWeek = [0: "Sun", 1: "Mon", 2: "Tue"]if let day = dayOfWeek[2] &#123; print(day)&#125;// addValue 1dayOfWeek[3] = "Wed"print(dayOfWeek)// Prints: [2: "Tue", 0: "Sun", 1: "Mon", 3: "Wed"]// updateValue 1dayOfWeek[2] = "Mardi"print(dayOfWeek)// Prints: [2: "Mardi", 0: "Sun", 1: "Mon", 3: "Wed"]// updateValue 2dayOfWeek.updateValue("Tue", forKey: 2)print(dayOfWeek)// Prints: [2: "Tue", 0: "Sun", 1: "Mon", 3: "Wed"]// removeValue 1dayOfWeek[1] = nilprint(dayOfWeek)// Prints: [2: "Tue", 0: "Sun", 3: "Wed"]// removeValue 2dayOfWeek.removeValue(forKey: 2)print(dayOfWeek)// Prints: [0: "Sun", 3: "Wed"]// removeAlldayOfWeek.removeAll()print(dayOfWeek)// Output: [:] 可以看到从字典里面删除某个键值对有两个方法： 使用removeValue方法并传入要删除的键值对里的键。 将字典取下标之后将nil赋给它。 数据结构这一部分内容主要是对连载的后续文章作铺垫，让大家对数据结构先有一个基本的认识，因此在概念上不会深入讲解。该部分由以下三点展开： 数据结构的基本概念 抽象数据类型 链表，栈和队列的实现 概念首先我们来看一下数据结构的概念： 数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。 由数据结构这个词汇的本身（数据的结构）以及它的概念可以看出，它的重点在于“结构”和“关系”。所以说，数据是何种数据并不重要，重要的是这些数据是如何联系起来的。 而这些联系，可以从两个维度来展开： 逻辑结构：指数据对象中元素之间的相互关系。 物理结构：指数据的逻辑结构在计算机中的存储形式。 可以看出，逻辑结构是抽象的联系，而物理结构是实际在计算机内存里的具体联系。那么它们自己又细分为哪些结构呢？ 逻辑结构： 集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。 线性结构：线性结构中的数据元素之间是一对一的关系。 树形结构：数据结构中的元素存在一对多的相互关系。 图形结构：数据结构中的元素存在多对多的相互关系。 物理结构： 顺序存储结构：把数据元素粗放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的（数组）。 链式存储结构：把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。 为了便于记忆，用思维导图总结一下上面所说的： 而通过结合这两个维度中的某个结构，可以定义出来一个实际的数据结构的实现： 比如线性表就是线性结构的一种实现： 顺序存储结构的线性表就是数组：它的内存分布是连续的，元素之间可以通过内存地址来做关联； 链式存储结构的线性表就是 链表 ：它的内存分布可以是不连续的，元素之间通过指针来做关联： 如果每个元素（在链表中称作节点）只持有指向后面节点的指针，那此链表就是单链表。 如果每个元素（在链表中称作节点）持有指向前后节点的两个指针，那此链表就是双链表。 为什么会有链表这么麻烦的东西？像数组这样，所有内存地址都是连续的不是很方便么？既生瑜何生亮呢？ 对于获取元素（节点）这一操作，使用数组这个数据结构确实非常方便：因为所有元素在内存中是连续的，所以只需要知道数组中第一个元素的地址以及要获取元素的index就能算出该index内存的地址，一步到位非常方便。 但是对于向数组中某个index中插入新的元素的操作恐怕就没有这么方便了：恰恰是因为数组中所有元素的内存是连续的，所以如果想在中间插入一个新的元素，那么这个位置后面的所有元素都要后移，显然是非常低效的。如果插在数组尾部还好，如果插在第一位的话成本就太高了。 而如果使用链表，只要把要插入到的index前后节点的指针赋给这个新的节点就可以了，不需要移动原有节点在内存中的位置。 关于链表的这种插入操作会在后面用代码的形式体现出来。 既然有这么多的数据结构，那么有没有一个标准的格式来将这些特定的数据结构（也可以说是数学模型）抽象出来呢？答案是肯定的，它就是我们下一节要讲的抽象数据类型。 抽象数据类型首先来看一下抽象数据类型的概念，摘自《大话数据结构》: 抽象数据类型（Abstract Data Type，ADT）：是指一个数学模型及定义在该模型上的一组操作。 需要注意的是：抽象数据类型的定义仅仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现没有关系。而且，抽象数据类型不仅仅指那些已经定义并实现的数据类型，还尅是计算机编程者自己定义的数据类型。 我们看一下数据类型的标准格式： 1234567891011121314151617ADT 抽象数据类型名Data 数据元素之间逻辑关系的定义 Operation 操作1 初始条件 操作结果描述 操作2 初始条件 操作结果描述 操作nendADT 其实看上去和面向对象编程里的类的定义相似： 可以把抽象数据类型的Data 和 类的成员变量联系起来。 可以把抽象数据类型的操作和类的函数联系起来。 简单来说，抽象数据类型描述了一个数据模型所使用的数据和数据之间的逻辑关系，以及它可以执行的一些操作。因此，如果知道了一个数学模型的抽象数据类型，那么在真正接触数学模型的实现（代码）之前，就可以对该数学模型能做的事情有一个大致的了解。 下一章笔者会介绍链表，栈和队列这三个数学模型，在讲解每个数学模型的实现之前都会给出它们各自的抽象数据类型，让读者可以先对当前数学模型有个大致的了解。 注意：书本文归纳的所有抽象数据类型是笔者自己根据网上资料和相关书籍而定下来的，所以严格来说它们并不是“最官方”的抽象数据类型。读者也可以参考网上的资料或是相关书籍，结合自己的思考来定义自己对着三个数据模型的抽象数据类型。 链表，栈和队列的实现通过上一节的介绍，我们知道了数据结构的概念以及分类，还知道了不同的数据结构在不同的场景下会发挥不同的优势，我们要根据实际的场景来选择合适的数据结构。 下面就来介绍几种在实际应用中使用的比较多的数学模型： 链表 栈 队列 链表（Linked list）说到链表就不得不提线性表这一数据结构，在介绍链表之前，首先看一下线性表的定义： 线性表：零个或多个数据元素的有限序列。 而根据物理结构的不同，线性表有两种具体的实现方式： 线性表的顺序存储结构：线性表的数据元素是被一段地址连续的存储单存储起来的。 线性表的链式存储结构: 线性表的数据元素是被用一组连续或不连续的存储单元存储起来的，这些元素通过指针来作为逻辑上的连接。 注：上面两个概念是笔者用自己的话总结出来的。 在这里，线性表的顺序存储结构的实现就是我们熟悉的数组；而线性表的链式存储结构的实现就是笔者即将要介绍的链表。 链表的定义相信对于读完上一节的朋友来说，应该对链表有一个比较清晰的认识了。关于链表的定义有很多不同的版本，笔者个人比较喜欢百度百科里的定义： 链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。 而且由于数据元素所持有的指针个数和链接特性可以将链表分为： 单向链表：单向链表的链接方向是单向的，其中每个结点都有指针成员变量指向列表中的下一个结点； 双向链表：双向链表的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点，它的链接方向是双向的。 循环链表：循环链表是另一种形式的链式存贮结构。它的特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。 笔者从中挑选出双向链表来进行讲解，它的难度适中，而且能够很好地让读者体会出链表的优势。 双向链表的抽象数据类型因为节点是链表的基本组成单元，所以想要实现链表，必须先要介绍链表的组成部分-节点。 节点： 1234567891011ADT 节点(node)Data value:持有的数据Operation init:初始化 previous:指向上一节点的指针 next:指向下一节点的指针 endADT 再来看一下链表的抽象数据类型： 1234567891011121314151617181920ADT 链表（linked list）Data linked list:持有的线性表Operation init:初始化 count:持有节点总个数 isEmpty:是否为空 first:头节点 last:尾节点 node:传入index返回节点 insert:插入node到指定index insertToHead:插入节点到表头 appendToTail:插入节点到表尾 removeAll:移除所有节点 remove:移除传入的节点 removeAt:移除传入index的节点 endADT 双向链表的实现节点1234567891011121314151617public class LinkedListNode&lt;T&gt; &#123; //value of a node var value: T //pointer to previous node weak var previous: LinkedListNode? //pointer to next node var next: LinkedListNode? //init public init(value: T) &#123; self.value = value &#125;&#125; 再来看一下链表的实现： 因为整个链表的插入，删除等操作比较多，整个链表的定义超过了200行代码，所以为了看着方便一点，在这里来分段说明一下。 首先看一下链表的成员变量: 成员变量12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class LinkedList&lt;T&gt; &#123; public typealias Node = LinkedListNode&lt;T&gt; //if empty public var isEmpty: Bool &#123; return head == nil &#125; //total count of nodes public var count: Int &#123; guard var node = head else &#123; return 0 &#125; var count = 1 while let next = node.next &#123; node = next count += 1 &#125; return count &#125; //pointer to the first node, private private var head: Node? //pointer to the first node, public public var first: Node? &#123; return head &#125; //pointer to the last node public var last: Node? &#123; guard var node = head else &#123; return nil &#125; //until node.next is nil while let next = node.next &#123; node = next &#125; return node &#125; ... &#125; 相信看上面的命名以及注释大家可以对链表的成员变量有个初步的理解，这里面需要说三点： typealias是用来重新为已经存在的类型命名的：这里用Node代替了LinkedListNode&lt;T&gt;（节点类型），降低了不少阅读代码的成本。 在获取count和last的实现，都先判断了head这个指针是否为nil，如果是则判定为空链表，自然也就不存在节点个数和最后的节点对象了。 同样地，也是在获取count和last的实现里，使用了while控制语句来判断node.next节点是否存在：如果存在，则继续+1或者继续往下寻找，直到node.next为nil时才停止。在这里我们可以看到链表的寻址方式：是通过头结点开始，以节点的.next指针来寻找下一个节点的。而且作为链表的尾节点，它的.next指针不指向任何对象，因为它本来就是链表的最后一项。 最下方的…代表即将在下面介绍的一些函数，这些函数都定义在的LinkedList这个class里面。 获取index上node1234567891011121314151617181920212223242526//get node of indexpublic func node(atIndex index: Int) -&gt; Node? &#123; if index == 0 &#123; //head node return head! &#125; else &#123; var node = head!.next guard index &lt; count else &#123; return nil; &#125; for _ in 1..&lt;index &#123; // go on finding by .next node = node?.next if node == nil &#123; break &#125; &#125; return node! &#125;&#125; 注意在这里返回的node是可以为nil的，而且在这里可以看出来，链表在寻找特定node的时候，是根据节点的.next指针来一个一个寻找的。这个与顺序存储结构的数组是不同的，在后面我会重点讲解一下这二者的不同。 插入节点12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//insert node to last indexpublic func appendToTail(value: T) &#123; let newNode = Node(value: value) if let lastNode = last &#123; //update last node: newNode becomes new last node; //the previous last node becomes the second-last node newNode.previous = lastNode lastNode.next = newNode &#125; else &#123; //blank linked list head = newNode &#125;&#125;//insert node to index 0public func insertToHead(value: T) &#123; let newHead = Node(value: value) if head == nil &#123; //blank linked list head = newHead &#125;else &#123; newHead.next = head head?.previous = newHead head = newHead &#125;&#125;//insert node in specific indexpublic func insert(_ node: Node, atIndex index: Int) &#123; if index &lt; 0 &#123; print("invalid input index") return &#125; let newNode = node if count == 0 &#123; head = newNode &#125;else &#123; if index == 0 &#123; newNode.next = head head?.previous = newNode head = newNode &#125; else &#123; if index &gt; count &#123; print("out of range") return &#125; let prev = self.node(atIndex: index-1) let next = prev?.next newNode.previous = prev newNode.next = prev?.next prev?.next = newNode next?.previous = newNode &#125; &#125;&#125; 链表的插入节点的操作分为三种，按照从上到下的顺序依次是： 在头部插入 在尾部插入 指定index插入 需要注意的是 在前两种插入函数中，需要先判断该链表是否是空的，如果是，则要将链表的该节点赋给链表的head指针。 在第三种插入函数中，还是先判断该链表是否是空的，如果是，则无论index是多少(只要不小于0)，都插在链表的头部。如果不是空的，再判断index是否为0，如果是，则直接插在头部；如果index不为0，则判断index是否大于count，如果是，则无法插入；如果不是，则获取插入位置的前后节点进行重连。 在这里判断链表为空链表后的处理是笔者自己加上去的，笔者在网上的资料里没有看到过。大家不必纠结于这种处理方式，毕竟链表操作的重点在于前后节点的重连。 移除节点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//removing all nodespublic func removeAll() &#123; head = nil&#125;//remove the last nodepublic func removeLast() -&gt; T? &#123; guard !isEmpty else &#123; return nil &#125; return remove(node: last!)&#125;//remove a node by it's refrencepublic func remove(node: Node) -&gt; T? &#123; guard head != nil else &#123; print("linked list is empty") return nil &#125; let prev = node.previous let next = node.next if let prev = prev &#123; prev.next = next &#125; else &#123; head = next &#125; next?.previous = prev node.previous = nil node.next = nil return node.value&#125;//remove a node by it's indexpublic func removeAt(_ index: Int) -&gt; T? &#123; guard head != nil else &#123; print("linked list is empty") return nil &#125; let node = self.node(atIndex: index) guard node != nil else &#123; return nil &#125; return remove(node: node!)&#125; 如果要移除链表上所有节点，只需要将head指针置空就可以了，因为它是所有节点的“源头”，是链表寻址的第一个节点。 在持有某个节点的指针的时候可以指定链表来移除这个节点（使用remove函数）。在这个函数内部，首先需要将该节点的前后节点对接，然后将该几点的前后指针置空。 当有要移除节点的指针但是知道该节点在链表中的index，可以使用removeAt函数。在这个函数内部，首先根据index来获取对应的node的指针，然后再调用remove函数删除这个node。 打印所有节点12345678910111213141516171819202122public func printAllNodes()&#123; guard head != nil else &#123; print("linked list is empty") return &#125; var node = head print("\nstart printing all nodes:") for index in 0..&lt;count &#123; if node == nil &#123; break &#125; print("[\(index)]\(node!.value)") node = node!.next &#125;&#125; 该函数只是为了方便调试，为了跟踪链表的状态而定义的，它并不存在于链表的模型里。 为了验证上面这些方法的有效性，我们来实例化一个链表后实际操作一下，读者可以结合注释来看一下每一步对应的结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879let list = LinkedList&lt;String&gt;()list.isEmpty // truelist.first // nillist.count // 0list.appendToTail(value: "Swift")list.isEmpty // falselist.first!.value // "Swift"list.last!.value // "Swift"list.count //1list.appendToTail(value:"is")list.first!.value // "Swift"list.last!.value // "is"list.count // 2list.appendToTail(value:"great")list.first!.value // "Swift"list.last!.value // "great"list.count // 3list.printAllNodes()//[0]Swift//[1]is//[2]Greatlist.node(atIndex: 0)?.value // Swiftlist.node(atIndex: 1)?.value // islist.node(atIndex: 2)?.value // greatlist.node(atIndex: 3)?.value // nillist.insert(LinkedListNode.init(value: "language"), atIndex: 1)list.printAllNodes()//[0]Swift//[1]language//[2]is//[3]greatlist.remove(node: list.first!)list.printAllNodes()//[0]language//[1]is//[2]greatlist.removeAt(1)list.printAllNodes()//[0]language//[1]greatlist.removeLast()list.printAllNodes()//[0]languagelist.insertToHead(value: "study")list.count // 2list.printAllNodes()//[0]study//[1]languagelist.removeAll()list.printAllNodes()//linked list is emptylist.insert(LinkedListNode.init(value: "new"), atIndex: 3)list.printAllNodes()//[0]newlist.insert(LinkedListNode.init(value: "new"), atIndex: 3) //out of rangelist.printAllNodes()//[0]newlist.insert(LinkedListNode.init(value: "new"), atIndex: 1)list.printAllNodes()//[0]new//[1]new 栈（Stack）栈的讲解从 栈的定义 栈的抽象数据类型 栈的实现 三个部分来展开。 栈的定义首先来看一下栈的定义： 栈是限定仅在表的尾部进行插入和删除操作的线性表。 从定义中可以看出，我们知道我们只能在栈的一端来操作栈： 允许插入和删除的一端成为栈顶 另一端成为栈底 用一张图来看一下栈的操作： 图源：《维基百科：Stack (abstract data type)》 从上图可以看出，最先压入栈里面的只能最后访问，也就是说，栈遵循后进先出（Last In First Out, LIFO）的原则。 栈的抽象数据类型1234567891011121314ADT 栈（Stack）Data linked list:持有的线性表Operation init:初始化 count:栈的元素个数 isEmpty:是否为空 push:入栈 pop:出栈 top:返回顶部元素 endADT 上面的operation可能不全，但是涵盖了栈的一些最基本的操作。那么基于这个抽象数据类型，我们来看一下如何使用Swift来实现它。 栈的实现笔者将数组（顺序存储）作为栈的线性表的实现，同时支持泛型。 123456789101112131415ADT 栈（Stack）Data linked list:持有的线性表Operation init:初始化 count:栈的元素个数 isEmpty:是否为空 push:入栈 pop:出栈 top:返回顶部元素 endADT上面的operation可能不全，但是涵盖了栈的一些最基本的操作。那么基于这个抽象数据类型，我们来看一下如何使用Swift来实现它。 栈的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public struct Stack&lt;T&gt; &#123; //array fileprivate var stackArray = [T]() //count public var count: Int &#123; return stackArray.count &#125; //is empty ? public var isEmpty: Bool &#123; return stackArray.isEmpty &#125; //top element public var top: T? &#123; if isEmpty&#123; return nil &#125;else &#123; return stackArray.last &#125; &#125; //push operation public mutating func push(_ element: T) &#123; stackArray.append(element) &#125; //pop operation public mutating func pop() -&gt; T? &#123; if isEmpty&#123; print("stack is empty") return nil &#125;else &#123; return stackArray.removeLast() &#125; &#125; //print all public mutating func printAllElements() &#123; guard count &gt; 0 else &#123; print("stack is empty") return &#125; print("\nprint all stack elemets:") for (index, value) in stackArray.enumerated() &#123; print("[\(index)]\(value)") &#125; &#125;&#125; fileprivate：是Swift3.0新增的访问控制，表示在定义的声明文件里可访问。它代替了过去意义上的private。而有了fileprivate以后，新的private则代表了真正的私有：在这个类或结构体的外部无法访问。 这里printAllElements方法也不属于抽象数据类型里的方法，也是为了方便调试，可以打印出所有的数据元素。 我们来实例化上面定义的栈实际操作一下： 1234567891011121314151617181920212223242526272829303132333435var stack = Stack.init(stackArray: [])stack.printAllElements() //stack is emptystack.isEmpty //truestack.push(2)stack.printAllElements()//[0]2stack.isEmpty //falsestack.top //2stack.push(3)stack.printAllElements()//[0]2//[1]3stack.isEmpty //falsestack.top //3stack.pop()stack.printAllElements()//[0]2stack.isEmpty //falsestack.top //2stack.pop()stack.printAllElements() //stack is emptystack.top //nilstack.isEmpty //truestack.pop() //stack is empty 队列（Queue）队列的讲解从 队列的定义 队列的抽象数据类型 队列的实现 三个部分来展开。 队列的定义 图源：《维基百科：FIFO (computing and electronics)》 队列的抽象数据类型1234567891011121314ADT 队列（Queue）Data linked list:持有的线性表Operation init:初始化 count:栈的元素个数 isEmpty:是否为空 front:获取队列头元素 enqueue:插入到队尾 dequeue:删除队列头元素并返回 endADT 和上面的栈的实现一致，队列的实现也使用数组来实现队列内部的线性表。 队列的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public struct Queue&lt;T&gt; &#123; //array fileprivate var queueArray = [T]() //count public var count: Int &#123; return queueArray.count &#125; //is empty? public var isEmpty: Bool &#123; return queueArray.isEmpty &#125; //front element public var front: T? &#123; if isEmpty &#123; print("queue is empty") return nil &#125; else &#123; return queueArray.first &#125; &#125; //add element public mutating func enqueue(_ element: T) &#123; queueArray.append(element) &#125; //remove element public mutating func dequeue() -&gt; T? &#123; if isEmpty &#123; print("queue is empty") return nil &#125; else &#123; return queueArray.removeFirst() &#125; &#125; //print all public mutating func printAllElements() &#123; guard count &gt; 0 else &#123; print("queue is empty") return &#125; print("\nprint all queue elemets:") for (index, value) in queueArray.enumerated() &#123; print("[\(index)]\(value)") &#125; &#125; &#125; 我们初始化一个队列后实际操作一下： 123456789101112131415161718192021222324252627282930313233343536373839404142var queue = Queue.init(queueArray: [])queue.printAllElements()//queue is emptyqueue.isEmpty //truequeue.count //0queue.enqueue(2)queue.printAllElements()queue.isEmpty //false//[0]2queue.enqueue(3)queue.printAllElements()//[0]2//[1]3queue.enqueue(4)queue.printAllElements()//[0]2//[1]3//[2]4queue.front //2queue.dequeue()queue.printAllElements()//[0]3//[1]4queue.front //3queue.dequeue()queue.printAllElements()//[0]4queue.front //4queue.dequeue()queue.printAllElements() //queue is emptyqueue.front //return nil, and print : queue is emptyqueue.isEmpty //truequeue.count//0]]></content>
      <categories>
        <category>Data Structure &amp; Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[代码规范]]></title>
    <url>%2F2019%2F08%2F28%2F%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[这篇规范一共分为三个部分： 核心原则：介绍了这篇代码规范所遵循的核心原则。 通用规范：不局限于iOS的通用性的代码规范（使用C语言和Swift语言）。 iOS规范：仅适用于iOS的代码规范（使用Objc语言）。 一. 核心原则原则一：代码应该简洁易懂，逻辑清晰因为软件是需要人来维护的。这个人在未来很可能不是你。所以首先是为人编写程序，其次才是计算机： 不要过分追求技巧，降低程序的可读性。 简洁的代码可以让bug无处藏身。要写出明显没有bug的代码，而不是没有明显bug的代码。 原则二：面向变化编程，而不是面向需求编程。需求是暂时的，只有变化才是永恒的。本次迭代不能仅仅为了当前的需求，写出扩展性强，易修改的程序才是负责任的做法，对自己负责，对公司负责。 原则三：先保证程序的正确性，防止过度工程过度工程（over-engineering）：在正确可用的代码写出之前就过度地考虑扩展，重用的问题，使得工程过度复杂。引用《王垠：编程的智慧》里的话： 先把眼前的问题解决掉，解决好，再考虑将来的扩展问题。 先写出可用的代码，反复推敲，再考虑是否需要重用的问题。 先写出可用，简单，明显没有bug的代码，再考虑测试的问题。 二. 通用规范关于大括号 控制语句(if,for,while,switch)中，大括号开始与行尾 函数中，大括号要开始于行首 推荐这样写： 12345678910//控制语句white(someCondition)&#123;&#125;//函数void function(param1,param2)&#123;&#125; 运算符 1. 运算符与变量之间的间隔1.1 一元运算符与变量之间没有空格：12345!bValue~iValue++iCount*strSource&amp;fSum 1.2 二元运算符与变量之间必须有空格1234fWidth = 5 + 5;fLength = fWidth * 2;fHeight = fWidth + fLength;for(int i = 0; i &lt; 10; i++) 2. 多个不同的运算符同时存在时应该使用括号来明确优先级在多个不同的运算符同时存在的时候应该合理使用括号，不要盲目依赖操作符优先级。因为有的时候不能保证阅读你代码的人就一定能了解你写的算式里面所有操作符的优先级。 来看一下这个算式：2 &lt;&lt; 2 + 1 * 3 - 4 这里的&lt;&lt;是移位操作直观上却很容易认为它的优先级很高，所以就把这个算式误认为：(2 &lt;&lt; 2) + 1 3 - 4但事实上，它的优先级是比加减法还要低的，所以该算式应该等同于：2 &lt;&lt; (2 + 1 3 - 4)。所以在以后写这种复杂一点的算式的时候，尽量多加一点括号，避免让其他人误解（甚至是自己）。 变量 1. 一个变量有且只有一个功能，尽量不要把一个变量用作多种用途2. 变量在使用前应初始化，防止未初始化的变量被引用3. 局部变量应该尽量接近使用它的地方推荐这样写： 123456789101112func someFunction() &#123; let index = ...; //Do something With index ... ... let count = ...; //Do something With count &#125; 不推荐这样写： 1234567891011func someFunction() &#123; let index = ...; let count = ...; //Do something With index ... ... //Do something With count&#125; if语句 1. 必须列出所有分支（穷举所有的情况），而且每个分支都必须给出明确的结果。推荐这样写： 123456var hintStr;if (count &lt; 3) &#123; hintStr = "Good";&#125; else &#123; hintStr = "";&#125; 不推荐这样写： 1234var hintStr;if (count &lt; 3) &#123; hintStr = "Good";&#125; 2. 不要使用过多的分支，要善于使用return来提前返回错误的情况推荐这样写： 123456- (void)someMethod &#123; if (!goodCondition) &#123; return; &#125; //Do something&#125; 不推荐这样写： 12345- (void)someMethod &#123; if (goodCondition) &#123; //Do something &#125;&#125; 比较典型的例子我在JSONModel里遇到过： 12345678910111213141516171819202122232425262728293031323334353637383940-(id)initWithDictionary:(NSDictionary*)dict error:(NSError)err&#123; //方法1. 参数为nil if (!dict) &#123; if (err) *err = [JSONModelError errorInputIsNil]; return nil; &#125; //方法2. 参数不是nil，但也不是字典 if (![dict isKindOfClass:[NSDictionary class]]) &#123; if (err) *err = [JSONModelError errorInvalidDataWithMessage:@"Attempt to initialize JSONModel object using initWithDictionary:error: but the dictionary parameter was not an 'NSDictionary'."]; return nil; &#125; //方法3. 初始化 self = [self init]; if (!self) &#123; //初始化失败 if (err) *err = [JSONModelError errorModelIsInvalid]; return nil; &#125; //方法4. 检查用户定义的模型里的属性集合是否大于传入的字典里的key集合（如果大于，则返回NO） if (![self __doesDictionary:dict matchModelWithKeyMapper:self.__keyMapper error:err]) &#123; return nil; &#125; //方法5. 核心方法：字典的key与模型的属性的映射 if (![self __importDictionary:dict withKeyMapper:self.__keyMapper validation:YES error:err]) &#123; return nil; &#125; //方法6. 可以重写[self validate:err]方法并返回NO，让用户自定义错误并阻拦model的返回 if (![self validate:err]) &#123; return nil; &#125; //方法7. 终于通过了！成功返回model return self;&#125; 可以看到，在这里，首先判断出各种错误的情况然后提前返回，把最正确的情况放到最后返回。 3. 条件表达式如果很长，则需要将他们提取出来赋给一个BOOL值推荐这样写： 123456let nameContainsSwift = sessionName.hasPrefix("Swift")let isCurrentYear = sessionDateCompontents.year == 2014let isSwiftSession = nameContainsSwift &amp;&amp; isCurrentYearif (isSwiftSession) &#123; // Do something&#125; 不推荐这样写： 123if ( sessionName.hasPrefix("Swift") &amp;&amp; (sessionDateCompontents.year == 2014) ) &#123; // Do something&#125; 4. 条件语句的判断应该是变量在左，常量在右推荐这样写： 12if ( count == 6) &#123;&#125; 或者 12if ( object == nil) &#123;&#125; 或者 12if ( !object ) &#123;&#125; 不推荐这样写： 12if ( 6 == count) &#123;&#125; 或者 12if ( nil == object ) &#123;&#125; 5. 每个分支的实现代码都必须被大括号包围推荐这样写： 12if ( nil == object ) &#123;&#125; 不推荐这样写： 12if (!error) return success; 或者 1if (!error) return success; 6. 条件过多，过长的时候应该换行推荐这样写： 123456if (condition1() &amp;&amp; condition2() &amp;&amp; condition3() &amp;&amp; condition4()) &#123; // Do something&#125; 不推荐这样写： 123if (condition1() &amp;&amp; condition2() &amp;&amp; condition3() &amp;&amp; condition4()) &#123; // Do something&#125; for语句 1. 不可在for循环内修改循环变量，防止for循环失去控制。1234for (int index = 0; index &lt; 10; index++)&#123; ... logicToChange(index)&#125; 2. 避免使用continue和break。continue和break所描述的是“什么时候不做什么”，所以为了读懂二者所在的代码，我们需要在头脑里将他们取反。 其实最好不要让这两个东西出现，因为我们的代码只要体现出“什么时候做什么”就好了，而且通过适当的方法，是可以将这两个东西消灭掉的： 2.1 如果出现了continue，只需要把continue的条件取反即可1234567var filteredProducts = Array&lt;String&gt;()for level in products &#123; if level.hasPrefix("bad") &#123; continue &#125; filteredProducts.append(level)&#125; 我们可以看到，通过判断字符串里是否含有“bad”这个prefix来过滤掉一些值。其实我们是可以通过取反，来避免使用continue的： 12345for level in products &#123; if !level.hasPrefix("bad") &#123; filteredProducts.append(level) &#125;&#125; 2.2 消除while里的break：将break的条件取反，并合并到主循环里在while里的block其实就相当于“不存在”，既然是不存在的东西就完全可以在最开始的条件语句中将其排除。 while里的break： 123456while (condition1) &#123; ... if (condition2) &#123; break; &#125;&#125; 取反并合并到主条件： 123while (condition1 &amp;&amp; !condition2) &#123; ...&#125; 2.3 在有返回值的方法里消除break：将break转换为return立即返回有些朋友喜欢这样做：在有返回值的方法里break之后，再返回某个值。其实完全可以在break的那一行直接返回。 12345678910func hasBadProductIn(products: Array&lt;String&gt;) -&gt; Bool &#123; var result = false for level in products &#123; if level.hasPrefix("bad") &#123; result = true &#125; &#125; return result&#125; 遇到错误条件直接返回： 12345678func hasBadProductIn(products: Array&lt;String&gt;) -&gt; Bool &#123; for level in products &#123; if level.hasPrefix("bad") &#123; return true &#125; &#125; return false&#125; 这样写的话不用特意声明一个变量来特意保存需要返回的值，看起来非常简洁，可读性高。 Switch语句 1. 每个分支都必须用大括号括起来推荐这样写： 123456789101112131415161718switch (integer) &#123; case 1: &#123; // ... &#125; break; case 2: &#123; // ... break; &#125; case 3: &#123; // ... break; &#125; default:&#123; // ... break; &#125;&#125; 2. 使用枚举类型时，不能有default分支， 除了使用枚举类型以外，都必须有default分支123456789101112131415RWTLeftMenuTopItemType menuType = RWTLeftMenuTopItemMain; switch (menuType) &#123; case RWTLeftMenuTopItemMain: &#123; // ... break; &#125; case RWTLeftMenuTopItemShows: &#123; // ... break; &#125; case RWTLeftMenuTopItemSchedule: &#123; // ... break; &#125;&#125; 在Switch语句使用枚举类型的时候，如果使用了default分支，在将来就无法通过编译器来检查新增的枚举类型了。 函数 1. 一个函数的长度必须限制在50行以内通常来说，在阅读一个函数的时候，如果视需要跨过很长的垂直距离会非常影响代码的阅读体验。如果需要来回滚动眼球或代码才能看全一个方法，就会很影响思维的连贯性，对阅读代码的速度造成比较大的影响。最好的情况是在不滚动眼球或代码的情况下一眼就能将该方法的全部代码映入眼帘。 2. 一个函数只做一件事（单一原则）每个函数的职责都应该划分的很明确（就像类一样）。 推荐这样写： 12dataConfiguration()viewConfiguration() 不推荐这样写： 12345void dataConfiguration()&#123; ... viewConfiguration()&#125; 3. 对于有返回值的函数（方法），每一个分支都必须有返回值推荐这样写： 12345678910int function()&#123; if(condition1)&#123; return count1 &#125;else if(condition2)&#123; return count2 &#125;else&#123; return defaultCount &#125; &#125; 不推荐这样写： 12345678int function()&#123; if(condition1)&#123; return count1 &#125;else if(condition2)&#123; return count2 &#125;&#125; 4. 对输入参数的正确性和有效性进行检查，参数错误立即返回推荐这样写： 123456789101112void function(param1,param2)&#123; if(param1 is unavailable)&#123; return; &#125; if(param2 is unavailable)&#123; return; &#125; //Do some right thing&#125; 5. 如果在不同的函数内部有相同的功能，应该把相同的功能抽取出来单独作为另一个函数原来的调用： 123456789void logic() &#123; a(); b()； if (logic1 condition) &#123; c(); &#125; else &#123; d(); &#125;&#125; 将a，b函数抽取出来作为单独的函数 1234567891011121314void basicConfig() &#123; a(); b();&#125; void logic1() &#123; basicConfig(); c();&#125;void logic2() &#123; basicConfig(); d();&#125; 6. 将函数内部比较复杂的逻辑提取出来作为单独的函数一个函数内的不清晰（逻辑判断比较多，行数较多）的那片代码，往往可以被提取出去，构成一个新的函数，然后在原来的地方调用它这样你就可以使用有意义的函数名来代替注释，增加程序的可读性。 举一个发送邮件的例子： 123456789openEmailSite();login();writeTitle(title);writeContent(content);writeReceiver(receiver);addAttachment(attachment);send(); 中间的部分稍微长一些，我们可以将它们提取出来： 1234567void writeEmail(title, content,receiver,attachment)&#123; writeTitle(title); writeContent(content); writeReceiver(receiver); addAttachment(attachment); &#125; 然后再看一下原来的代码： 1234openEmailSite();login();writeEmail(title, content,receiver,attachment)send(); 8. 避免使用全局变量，类成员（class member）来传递信息，尽量使用局部变量和参数。在一个类里面，经常会有传递某些变量的情况。而如果需要传递的变量是某个全局变量或者属性的时候，有些朋友不喜欢将它们作为参数，而是在方法内部就直接访问了： 12345678910111213class A &#123; var x; func updateX() &#123; ... x = ...; &#125; func printX() &#123; updateX(); print(x); &#125;&#125; 我们可以看到，在printX方法里面，updateX和print方法之间并没有值的传递，乍一看我们可能不知道x从哪里来的，导致程序的可读性降低了。 而如果你使用局部变量而不是类成员来传递信息，那么这两个函数就不需要依赖于某一个类，而且更加容易理解，不易出错： 123456789func updateX() -&gt; String&#123; x = ...; return x; &#125; func printX() &#123; String x = updateX(); print(x); &#125; 注释 优秀的代码大部分是可以自描述的，我们完全可以用程代码本身来表达它到底在干什么，而不需要注释的辅助。 但并不是说一定不能写注释，有以下三种情况比较适合写注释： 公共接口（注释要告诉阅读代码的人，当前类能实现什么功能）。 涉及到比较深层专业知识的代码（注释要体现出实现原理和思想）。 容易产生歧义的代码（但是严格来说，容易让人产生歧义的代码是不允许存在的）。 除了上述这三种情况，如果别人只能依靠注释才能读懂你的代码的时候，就要反思代码出现了什么问题。 最后，对于注释的内容，相对于“做了什么”，更应该说明“为什么这么做”。 Code Review 换行、注释、方法长度、代码重复等这些是通过机器检查出来的问题，是无需通过人来做的。 而且除了审查需求的实现的程度，bug是否无处藏身以外，更应该关注代码的设计。比如类与类之间的耦合程度，设计的可扩展性，复用性，是否可以将某些方法抽出来作为接口等等。 三. iOS规范变量 1. 变量名必须使用驼峰格式类，协议使用大驼峰： 12HomePageViewController.h&lt;HeaderViewDelegate&gt; 对象等局部变量使用小驼峰： 12NSString *personName = @"";NSUInteger totalCount = 0; 2. 变量的名称必须同时包含功能与类型123UIButton *addBtn //添加按钮UILabel *nameLbl //名字标签NSString *addressStr//地址字符串 3. 系统常用类作实例变量声明时加入后缀 类型 后缀 UIViewController VC UIView View UILabel Lbl UIButton Btn UIImage Img UIImageView ImagView NSArray Array NSMutableArray Marray NSDictionary Dict NSMutableDictionary Mdict NSString Str NSMutableString MStr NSSet Set NSMutableSet Mset 常量 1. 常量以相关类名作为前缀推荐这样写： 1static const NSTimeInterval ZOCSignInViewControllerFadeOutAnimationDuration = 0.4; 不推荐这样写： 1static const NSTimeInterval fadeOutTime = 0.4; 2. 建议使用类型常量，不建议使用#define预处理命令首先比较一下这两种声明常量的区别： 预处理命令：简单的文本替换，不包括类型信息，并且可被任意修改。 类型常量：包括类型信息，并且可以设置其使用范围，而且不可被修改。 使用预处理虽然能达到替换文本的目的，但是本身还是有局限性的： 不具备类型信息。 可以被任意修改。 3. 对外公开某个常量：如果我们需要发送通知，那么就需要在不同的地方拿到通知的“频道”字符串（通知的名称），那么显然这个字符串是不能被轻易更改，而且可以在不同的地方获取。这个时候就需要定义一个外界可见的字符串常量。 推荐这样写： 123456//头文件extern NSString *const ZOCCacheControllerDidClearCacheNotification;//实现文件static NSString * const ZOCCacheControllerDidClearCacheNotification = @"ZOCCacheControllerDidClearCacheNotification";static const CGFloat ZOCImageThumbnailHeight = 50.0f; 不推荐这样写： 12#define CompanyName @"Apple Inc." #define magicNumber 42 宏 1. 宏、常量名都要使用大写字母，用下划线‘_’分割单词。123#define URL_GAIN_QUOTE_LIST @"/v1/quote/list"#define URL_UPDATE_QUOTE_LIST @"/v1/quote/update"#define URL_LOGIN @"/v1/user/login” 2. 宏定义中如果包含表达式或变量，表达式和变量必须用小括号括起来。1#define MY_MIN(A, B) ((A)&gt;(B)?(B):(A)) CGRect函数 其实iOS内部已经提供了相应的获取CGRect各个部分的函数了，它们的可读性比较高，而且简短，推荐使用： 推荐这样写： 123456CGRect frame = self.view.frame; CGFloat x = CGRectGetMinX(frame); CGFloat y = CGRectGetMinY(frame); CGFloat width = CGRectGetWidth(frame); CGFloat height = CGRectGetHeight(frame); CGRect frame = CGRectMake(0.0, 0.0, width, height); 而不是 123456CGRect frame = self.view.frame; CGFloat x = frame.origin.x; CGFloat y = frame.origin.y; CGFloat width = frame.size.width; CGFloat height = frame.size.height; CGRect frame = (CGRect)&#123; .origin = CGPointZero, .size = frame.size &#125;; 范型 建议在定义NSArray和NSDictionary时使用泛型，可以保证程序的安全性： 12NSArray&lt;NSString *&gt; *testArr = [NSArray arrayWithObjects:@"Hello", @"world", nil];NSDictionary&lt;NSString *, NSNumber *&gt; *dic = @&#123;@"key":@(1), @"age":@(10)&#125;; Block 为常用的Block类型创建typedef 如果我们需要重复创建某种block（相同参数，返回值）的变量，我们就可以通过typedef来给某一种块定义属于它自己的新类型 例如： 1234int (^variableName)(BOOL flag, int value) =^(BOOL flag, int value)&#123; // Implementation return someInt;&#125; 这个Block有一个bool参数和一个int参数，并返回int类型。我们可以给它定义类型： 1int(^EOCSomeBlock)(BOOL flag, int value); 再次定义的时候，就可以通过简单的赋值来实现： 123EOCSomeBlock block = ^(BOOL flag, int value)&#123;// Implementation&#125;; 定义作为参数的Block： 1- (void)startWithCompletionHandler: (void(^)(NSData *data, NSError* error))completion; 这里的Block有一个NSData参数，一个NSError参数并没有返回值 12typedef void(^EOCCompletionHandler)(NSData *data, NSError* error);(void)startWithCompletionHandler:(EOCCompletionHandler)completion;” 通过typedef定义Block签名的好处是:如果要某种块增加参数，那么只修改定义签名的那行代码即可。 字面量语法 尽量使用字面量值来创建 NSString , NSDictionary , NSArray , NSNumber 这些不可变对象： 123NSArray *names = @[@"Brian", @"Matt", @"Chris", @"Alex", @"Steve", @"Paul"];NSDictionary *productManagers = @&#123;@"iPhone" : @"Kate", @"iPad" : @"Kamal", @"Mobile Web" : @"Bill"&#125;;NSNumber *shouldUseLiterals = @YES;NSNumber *buildingZIPCode = @10018; 不推荐这样写： 123NSArray *names = [NSArray arrayWithObjects:@"Brian", @"Matt", @"Chris", @"Alex", @"Steve", @"Paul", nil];NSDictionary *productManagers = [NSDictionary dictionaryWithObjectsAndKeys: @"Kate", @"iPhone", @"Kamal", @"iPad", @"Bill" ];NSNumber *shouldUseLiterals = [NSNumber numberWithBool:YES];NSNumber *buildingZIPCode = [NSNumber numberWithInteger:10018]; 属性 1. 属性的命名使用小驼峰推荐这样写： 1@property (nonatomic, readwrite, strong) UIButton *confirmButton; 2. 属性的关键字推荐按照 原子性，读写，内存管理的顺序排列推荐这样写： 123@property (nonatomic, readwrite, copy) NSString *name;@property (nonatomic, readonly, copy) NSString *gender;@property (nonatomic, readwrite, strong) UIView *headerView; 3. Block属性应该使用copy关键字推荐这样写： 12typedef void (^ErrorCodeBlock) (id errorCode,NSString *message);@property (nonatomic, readwrite, copy) ErrorCodeBlock errorBlock;//将block拷贝到堆中 4. 形容词性的BOOL属性的getter应该加上is前缀推荐这样写： 1@property (assign, getter=isEditable) BOOL editable; 5. 使用getter方法做懒加载实例化一个对象是需要耗费资源的，如果这个对象里的某个属性的实例化要调用很多配置和计算，就需要懒加载它，在使用它的前一刻对它进行实例化： 123456789- (NSDateFormatter *)dateFormatter &#123; if (!_dateFormatter) &#123; _dateFormatter = [[NSDateFormatter alloc] init]; NSLocale *enUSPOSIXLocale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"]; [_dateFormatter setLocale:enUSPOSIXLocale]; [_dateFormatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ss.SSS"]; &#125; return _dateFormatter;&#125; 但是也有对这种做法的争议：getter方法可能会产生某些副作用，例如如果它修改了全局变量，可能会产生难以排查的错误。 6. 除了init和dealloc方法，建议都使用点语法访问属性使用点语法的好处： setter： setter会遵守内存管理语义(strong, copy, weak)。 通过在内部设置断点，有助于调试bug。 可以过滤一些外部传入的值。 捕捉KVO通知。 getter： 允许子类化。 通过在内部设置断点，有助于调试bug。 实现懒加载（lazy initialization）。 注意： 懒加载的属性，必须通过点语法来读取数据。因为懒加载是通过重写getter方法来初始化实例变量的，如果不通过属性来读取该实例变量，那么这个实例变量就永远不会被初始化。 在init和dealloc方法里面使用点语法的后果是：因为没有绕过setter和getter，在setter和getter里面可能会有很多其他的操作。而且如果它的子类重载了它的setter和getter方法，那么就可能导致该子类调用其他的方法。 7. 不要滥用点语法，要区分好方法调用和属性访问推荐这样写： 12view.backgroundColor = [UIColor orangeColor]; [UIApplication sharedApplication].delegate; 不推荐这样写： 12[view setBackgroundColor:[UIColor orangeColor]]; UIApplication.sharedApplication.delegate; 8. 尽量使用不可变对象建议尽量把对外公布出来的属性设置为只读，在实现文件内部设为读写。具体做法是： 在头文件中，设置对象属性为 在实现文件中设置为readwrite。 这样一来，在外部就只能读取该数据，而不能修改它，使得这个类的实例所持有的数据更加安全。而且，对于集合类的对象，更应该仔细考虑是否可以将其设为可变的。 如果在公开部分只能设置其为只读属性，那么就在非公开部分存储一个可变型。所以当在外部获取这个属性时，获取的只是内部可变型的一个不可变版本,例如： 在公共API中： 12345678910@interface EOCPerson : NSObject@property (nonatomic, copy, readonly) NSString firstName;@property (nonatomic, copy, readonly) NSString lastName;@property (nonatomic, strong, readonly) NSSet *friends //向外公开的不可变集合(id)initWithFirstName:(NSString)firstName andLastName:(NSString)lastName;(void)addFriend:(EOCPerson*)person;(void)removeFriend:(EOCPerson*)person;@end 在这里，我们将friends属性设置为不可变的set。然后，提供了来增加和删除这个set里的元素的公共接口。 在实现文件里： 12345678910111213141516171819202122232425262728293031@interface EOCPerson ()@property (nonatomic, copy, readwrite) NSString *firstName;@property (nonatomic, copy, readwrite) NSString* lastName;@end@implementation EOCPerson &#123; NSMutableSet *_internalFriends; //实现文件里的可变集合&#125;- (NSSet*)friends &#123; return [_internalFriends copy]; //get方法返回的永远是可变set的不可变型&#125;- (void)addFriend:(EOCPerson*)person &#123; [_internalFriends addObject:person]; //在外部增加集合元素的操作 //do something when add element&#125;- (void)removeFriend:(EOCPerson*)person &#123; [_internalFriends removeObject:person]; //在外部移除元素的操作 //do something when remove element&#125;- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName &#123; if ((self = [super init])) &#123; ... &#125; return self;&#125; 我们可以看到，在实现文件里，保存一个可变set来记录外部的增删操作。 这里最重要的代码是： 123- (NSSet *)friends &#123; return [_internalFriends copy];&#125; 这个是friends属性的获取方法：它将当前保存的可变set复制了一不可变的set并返回。因此，外部读取到的set都将是不可变的版本。 方法 1. 方法名中不应使用and，而且签名要与对应的参数名保持高度一致推荐这样写： 1- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height; 不推荐这样写： 12- (instancetype)initWithWidth:(CGFloat)width andHeight:(CGFloat)height;- (instancetype)initWith:(int)width and:(int)height; 2. 方法实现时，如果参数过长，则令每个参数占用一行，以冒号对齐。123456- (void)doSomethingWith:(NSString *)theFoo rect:(CGRect)theRect interval:(CGFloat)theInterval&#123; //Implementation&#125; 3. 私有方法应该在实现文件中申明。12345678910@interface ViewController ()- (void)basicConfiguration;@end@implementation ViewController- (void)basicConfiguration&#123; //Do some basic configuration&#125;@end 4. 方法名用小写字母开头的单词组合而成1- (NSString *)descriptionWithLocale:(id)locale; 5. 方法名前缀 刷新视图的方法名要以refresh为首。 更新数据的方法名要以update为首。 推荐这样写： 12- (void)updateDataSourceWithViewModel:(ViewModel*)viewModel;- (void)updateDataSourceWithViewModel:(ViewModel*)viewModel; 面向协议编程 如果某些功能（方法）具备可复用性，我们就需要将它们抽取出来放入一个抽象接口文件中（在iOS中，抽象接口即协议），让不同类型的对象遵循这个协议，从而拥有相同的功能。 因为协议是不依赖于某个对象的，所以通过协议，我们可以解开两个对象之间的耦合。如何理解呢？我们来看一下下面这个例子： 现在有一个需求：在一个UITableViewController里面拉取feed并展示出来。 方案一：定义一个拉取feed的类ZOCFeedParser，这个类有一些代理方法实现feed相关功能： 12345678910111213141516@protocol ZOCFeedParserDelegate &lt;NSObject&gt;@optional- (void)feedParserDidStart:(ZOCFeedParser *)parser;- (void)feedParser:(ZOCFeedParser *)parser didParseFeedInfo:(ZOCFeedInfoDTO *)info; - (void)feedParser:(ZOCFeedParser *)parser didParseFeedItem:(ZOCFeedItemDTO *)item; - (void)feedParserDidFinish:(ZOCFeedParser *)parser;- (void)feedParser:(ZOCFeedParser *)parser didFailWithError:(NSError *)error;@end @interface ZOCFeedParser : NSObject@property (nonatomic, weak) id &lt;ZOCFeedParserDelegate&gt; delegate; @property (nonatomic, strong) NSURL *url; - (id)initWithURL:(NSURL *)url; - (BOOL)start; - (void)stop; @end 然后在ZOCTableViewController里面传入ZOCFeedParser，并遵循其代理方法，实现feed的拉取功能。 123@interface ZOCTableViewController : UITableViewController&lt;ZOCFeedParserDelegate&gt;- (instancetype)initWithFeedParser:(ZOCFeedParser *)feedParser; @end 具体应用： 1234NSURL *feedURL = [NSURL URLWithString:@"http://bbc.co.uk/feed.rss"]; ZOCFeedParser *feedParser = [[ZOCFeedParser alloc] initWithURL:feedURL]; ZOCTableViewController *tableViewController = [[ZOCTableViewController alloc] initWithFeedParser:feedParser]; feedParser.delegate = tableViewController; OK，现在我们实现了需求：在ZOCTableViewController里面存放了一个ZOCFeedParser对象来处理feed的拉取功能。 但这里有一个严重的耦合问题：ZOCTableViewController只能通过ZOCFeedParser对象来处理feed的拉取功能。于是我们重新审视一下这个需求：其实我们实际上只需要ZOCTableViewController拉取feed就可以了，而具体是由哪个对象来拉取，ZOCTableViewController并不需要关心。 也就是说，我们需要提供给ZOCTableViewController的是一个更范型的对象，这个对象具备了拉取feed的功能就好了，而不应该仅仅局限于某个具体的对象（ZOCFeedParser）。所以，刚才的设计需要重新做一次修改： 方案二：首先需要在一个接口文件ZOCFeedParserProtocol.h里面定义抽象的，具有拉取feed功能的协议： 12345678910111213141516@protocol ZOCFeedParserDelegate &lt;NSObject&gt;@optional- (void)feedParserDidStart:(id&lt;ZOCFeedParserProtocol&gt;)parser;- (void)feedParser:(id&lt;ZOCFeedParserProtocol&gt;)parser didParseFeedInfo:(ZOCFeedInfoDTO *)info; - (void)feedParser:(id&lt;ZOCFeedParserProtocol&gt;)parser didParseFeedItem:(ZOCFeedItemDTO *)item; - (void)feedParserDidFinish:(id&lt;ZOCFeedParserProtocol&gt;)parser;- (void)feedParser:(id&lt;ZOCFeedParserProtocol&gt;)parser didFailWithError:(NSError *)error;@end @protocol ZOCFeedParserProtocol &lt;NSObject&gt;@property (nonatomic, weak) id &lt;ZOCFeedParserDelegate&gt; delegate; @property (nonatomic, strong) NSURL *url;- (BOOL)start;- (void)stop;@end 而原来的ZOCFeedParser仅仅是需要遵循上面这个协议就具备了拉取feed的功能： 123@interface ZOCFeedParser : NSObject &lt;ZOCFeedParserProtocol&gt; - (id)initWithURL:(NSURL *)url;//仅仅需要通过传入url即可，其他事情都交给ZOCFeedParserProtocol@end 而且，ZOCTableViewController也不直接依赖于ZOCFeedParser对象，我们只需要传给它一个遵循&lt;ZOCFeedParserProtocol&gt;的对象即可。 123@interface ZOCTableViewController : UITableViewController &lt;ZOCFeedParserDelegate&gt;- (instancetype)initWithFeedParser:(id&lt;ZOCFeedParserProtocol&gt;)feedParser;@end 这样一来，ZOCTableViewController和ZOCFeedParser之间就没有直接的关系了。以后，如果我们想： 给这个feed拉取器增加新的功能：仅需要修改ZOCFeedParserProtocol.h文件。 更换一个feed拉取器实例：创建一个新类型来遵循ZOCFeedParserProtocol.h即可。 iOS 中委托的设计 1. 要区分好代理和数据源的区别在iOS开发中的委托模式包含了delegate（代理）和datasource（数据源）。虽然二者同属于委托模式，但是这两者是有区别的。这个区别就是二者的信息流方向是不同的： delegate ：事件发生的时候，委托者需要通知代理。（信息流从委托者到代理） datasource：委托者需要从数据源拉取数据。（信息流从数据源到委托者） 然而包括苹果也没有做好榜样，将它们彻底的区分开。就拿UITableView来说，在它的delegate方法中有一个方法： 1- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath; 这个方法正确地体现了代理的作用：委托者（tableview）告诉代理（控制器）“我的某个cell被点击了”。但是，UITableViewDelegate的方法列表里还有这个方法： 1- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath; 该方法的作用是 由控制器来告诉tabievlew的行高，也就是说，它的信息流是从控制器（数据源）到委托者（tableview）的。准确来讲，它应该是一个数据源方法，而不是代理方法。 在UITableViewDataSource中，就有标准的数据源方法： 1- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView; 这个方法的作用就是让tableview向控制器拉取一个section数量的数据。 所以，在我们设计一个视图控件的代理和数据源时，一定要区分好二者的区别，合理地划分哪些方法属于代理方法，哪些方法属于数据源方法。 2. 代理方法的第一个参数必须为委托者代理方法必须以委托者作为第一个参数（参考UITableViewDelegate）的方法。其目的是为了区分不同委托着的实例。因为同一个控制器是可以作为多个tableview的代理的。若要区分到底是哪个tableview的cell被点击了，就需要在 1- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath* )indexPath 方法中做个区分。 向代理发送消息时需要判断其是否实现该方法最后，在委托着向代理发送消息的时候，需要判断委托着是否实现了这个代理方法: 123if ([self.delegate respondsToSelector:@selector(signUpViewControllerDidPressSignUpButton:)]) &#123; [self.delegate signUpViewControllerDidPressSignUpButton:self];&#125; 3. 遵循代理过多的时候，换行对齐显示1234@interface ShopViewController () &lt;UIGestureRecognizerDelegate, HXSClickEventDelegate, UITableViewDelegate, UITableViewDataSource&gt; 4. 代理的方法需要明确必须执行和可不执行代理方法在默认情况下都是必须执行的，然而在设计一组代理方法的时候，有些方法可以不是必须执行（是因为存在默认配置），这些方法就需要使用@optional关键字来修饰： 12@protocol ZOCServiceDelegate &lt;NSObject&gt;@optional- (void)generalService:(ZOCGeneralService *)service didRetrieveEntries:(NSArray *)entries; @end 类 1. 类的名称应该以三个大写字母为前缀；创建子类的时候，应该把代表子类特点的部分放在前缀和父类名的中间推荐这样写： 123456//父类ZOCSalesListViewController//子类ZOCDaySalesListViewControllerZOCMonthSalesListViewController 2. initializer &amp;&amp; dealloc推荐： 将 dealloc 方法放在实现文件的最前面 将init方法放在dealloc方法后面。如果有多个初始化方法，应该将指定初始化方法放在最前面，其他初始化方法放在其后。 2.1 dealloc方法里面应该直接访问实例变量，不应该用点语法访问2.2 init方法的写法： init方法返回类型必须是instancetype，不能是id。 必须先实现[super init]。 1234567- (instancetype)init &#123; self = [super init]; // call the designated initializer if (self) &#123; // Custom initialization &#125; return self; &#125; 2.3 指定初始化方法指定初始化方法(designated initializer)是提供所有的（最多的）参数的初始化方法，间接初始化方法(secondary initializer)有一个或部分参数的初始化方法。 注意事项1：间接初始化方法必须调用指定初始化方法。 123456789101112131415161718192021222324252627@implementation ZOCEvent //指定初始化方法- (instancetype)initWithTitle:(NSString *)title date:(NSDate *)date location:(CLLocation *)location&#123; self = [super init]; if (self) &#123; _title = title; _date = date; _location = location; &#125; return self; &#125; //间接初始化方法- (instancetype)initWithTitle:(NSString *)title date:(NSDate *)date&#123; return [self initWithTitle:title date:date location:nil];&#125;//间接初始化方法- (instancetype)initWithTitle:(NSString *)title &#123; return [self initWithTitle:title date:[NSDate date] location:nil];&#125;@end 注意事项2：如果直接父类有指定初始化方法，则必须调用其指定初始化方法 123456- (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil &#123; self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil]; if (self) &#123; &#125; return self; &#125; 注意事项3：如果想在当前类自定义一个新的全能初始化方法，则需要如下几个步骤 定义新的指定初始化方法，并确保调用了直接父类的初始化方法。 重载直接父类的初始化方法，在内部调用新定义的指定初始化方法。 为新的指定初始化方法写文档。 看一个标准的例子： 12345678910111213141516@implementation ZOCNewsViewController//新的指定初始化方法- (id)initWithNews:(ZOCNews *)news &#123; self = [super initWithNibName:nil bundle:nil]; if (self) &#123; _news = news; &#125; return self;&#125; // 重载父类的初始化方法- (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil&#123; return [self initWithNews:nil]; &#125;@end 在这里，重载父类的初始化方法并在内部调用新定义的指定初始化方法的原因是你不能确定调用者调用的就一定是你定义的这个新的指定初始化方法，而不是原来从父类继承来的指定初始化方法。 假设你没有重载父类的指定初始化方法，而调用者却恰恰调用了父类的初始化方法。那么调用者可能永远都调用不到你自己定义的新指定初始化方法了。 而如果你成功定义了一个新的指定初始化方法并能保证调用者一定能调用它，你最好要在文档中明确写出哪一个才是你定义的新初始化方法。或者你也可以使用编译器指令__attribute__((objc_designated_initializer))来标记它。 3. 所有返回类对象和实例对象的方法都应该使用instancetype将instancetype关键字作为返回值的时候，可以让编译器进行类型检查，同时适用于子类的检查，这样就保证了返回类型的正确性（一定为当前的类对象或实例对象） 推荐这样写： 123@interface ZOCPerson+ (instancetype)personWithName:(NSString *)name; @end 不推荐这样写： 123@interface ZOCPerson+ (id)personWithName:(NSString *)name; @end 4. 在类的头文件中尽量少引用其他头文件有时，类A需要将类B的实例变量作为它公共API的属性。这个时候，我们不应该引入类B的头文件，而应该使用向前声明（forward declaring）使用class关键字，并且在A的实现文件引用B的头文件。 123456789101112131415// EOCPerson.h#import &lt;Foundation/Foundation.h&gt;@class EOCEmployer;@interface EOCPerson : NSObject@property (nonatomic, copy) NSString *firstName;@property (nonatomic, copy) NSString *lastName;@property (nonatomic, strong) EOCEmployer *employer;//将EOCEmployer作为属性@end// EOCPerson.m#import "EOCEmployer.h" 这样做有什么优点呢： 不在A的头文件中引入B的头文件，就不会一并引入B的全部内容，这样就减少了编译时间。 可以避免循环引用：因为如果两个类在自己的头文件中都引入了对方的头文件，那么就会导致其中一个类无法被正确编译。 但是个别的时候，必须在头文件中引入其他类的头文件: 主要有两种情况： 该类继承于某个类，则应该引入父类的头文件。 该类遵从某个协议，则应该引入该协议的头文件。而且最好将协议单独放在一个头文件中。 5. 类的布局1234567891011121314151617181920212223242526272829#pragma mark - Life Cycle Methods- (instancetype)init- (void)dealloc- (void)viewWillAppear:(BOOL)animated- (void)viewDidAppear:(BOOL)animated- (void)viewWillDisappear:(BOOL)animated- (void)viewDidDisappear:(BOOL)animated#pragma mark - Override Methods#pragma mark - Intial Methods#pragma mark - Network Methods#pragma mark - Target Methods#pragma mark - Public Methods#pragma mark - Private Methods#pragma mark - UITableViewDataSource #pragma mark - UITableViewDelegate #pragma mark - Lazy Loads#pragma mark - NSCopying #pragma mark - NSObject Methods 分类 1. 分类添加的方法需要添加前缀和下划线推荐这样写： 123@interface NSDate (ZOCTimeExtensions) - (NSString *)zoc_timeAgoShort;@end 不推荐这样写： 123@interface NSDate (ZOCTimeExtensions) - (NSString *)timeAgoShort;@end 2. 把类的实现代码分散到便于管理的多个分类中一个类可能会有很多公共方法，而且这些方法往往可以用某种特有的逻辑来分组。我们可以利用Objecctive-C的分类机制，将类的这些方法按一定的逻辑划入几个分区中。 举个🌰： 先看一个没有使用无分类的类： 123456789101112131415161718192021222324#import &lt;Foundation/Foundation.h&gt;@interface EOCPerson : NSObject@property (nonatomic, copy, readonly) NSString *firstName;@property (nonatomic, copy, readonly) NSString *lastName;@property (nonatomic, strong, readonly) NSArray *friends;- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName;/* Friendship methods */- (void)addFriend:(EOCPerson*)person;- (void)removeFriend:(EOCPerson*)person;- (BOOL)isFriendsWith:(EOCPerson*)person;/* Work methods */- (void)performDaysWork;- (void)takeVacationFromWork;/* Play methods */- (void)goToTheCinema;- (void)goToSportsGame;@end 分类之后： 1234567891011121314151617181920212223242526272829303132333435#import &lt;Foundation/Foundation.h&gt;@interface EOCPerson : NSObject@property (nonatomic, copy, readonly) NSString *firstName;@property (nonatomic, copy, readonly) NSString *lastName;@property (nonatomic, strong, readonly) NSArray *friends;- (id)initWithFirstName:(NSString*)firstNameandLastName:(NSString*)lastName;@end@interface EOCPerson (Friendship)- (void)addFriend:(EOCPerson*)person;- (void)removeFriend:(EOCPerson*)person;- (BOOL)isFriendsWith:(EOCPerson*)person;@end@interface EOCPerson (Work)- (void)performDaysWork;- (void)takeVacationFromWork;@end@interface EOCPerson (Play)- (void)goToTheCinema;- (void)goToSportsGame;@end 其中，FriendShip分类的实现代码可以这么写： 1234567891011121314151617181920212223242526272829// EOCPerson+Friendship.h#import "EOCPerson.h"@interface EOCPerson (Friendship)- (void)addFriend:(EOCPerson*)person;- (void)removeFriend:(EOCPerson*)person;- (BOOL)isFriendsWith:(EOCPerson*)person;@end// EOCPerson+Friendship.m#import "EOCPerson+Friendship.h"@implementation EOCPerson (Friendship)- (void)addFriend:(EOCPerson*)person &#123; /* ... */&#125;- (void)removeFriend:(EOCPerson*)person &#123; /* ... */&#125;- (BOOL)isFriendsWith:(EOCPerson*)person &#123; /* ... */&#125;@end 注意：在新建分类文件时，一定要引入被分类的类文件。 通过分类机制，可以把类代码分成很多个易于管理的功能区，同时也便于调试。因为分类的方法名称会包含分类的名称，可以马上看到该方法属于哪个分类中。 利用这一点，我们可以创建名为Private的分类，将所有私有方法都放在该类里。这样一来，我们就可以根据private一词的出现位置来判断调用的合理性，这也是一种编写“自我描述式代码（self-documenting）”的办法。 单例 1. 单例不能作为容器对象来使用单例对象不应该暴露出任何属性，也就是说它不能作为让外部存放对象的容器。它应该是一个处理某些特定任务的工具，比如在iOS中的GPS和加速度传感器。我们只能从他们那里得到一些特定的数据。 2. 使用dispatch_once来生成单例推荐这样写： 12345678+ (instancetype)sharedInstance &#123; static id sharedInstance = nil; static dispatch_once_t onceToken = 0; dispatch_once(&amp;onceToken, ^&#123; sharedInstance = [[self alloc] init]; &#125;); return sharedInstance; &#125; 不推荐这样写： 1234567+ (instancetype)sharedInstance &#123; static id sharedInstance; @synchronized(self) &#123; if (sharedInstance == nil) &#123; sharedInstance = [[MyClass alloc] init]; &#125; &#125; return sharedInstance; &#125; 相等性的判断 判断两个person类是否相等的合理做法： 1234567891011121314- (BOOL)isEqual:(id)object &#123; if (self == object) &#123; return YES; //判断内存地址 &#125; if (![object isKindOfClass:[ZOCPerson class]]) &#123; return NO; //是否为当前类或派生类 &#125; return [self isEqualToPerson:(ZOCPerson *)object]; &#125;//自定义的判断相等性的方法- (BOOL)isEqualToPerson:(Person *)person &#123; if (!person) &#123; return NO; &#125; BOOL namesMatch = (!self.name &amp;&amp; !person.name) || [self.name isEqualToString:person.name]; BOOL birthdaysMatch = (!self.birthday &amp;&amp; !person.birthday) || [self.birthday isEqualToDate:person.birthday]; return haveEqualNames &amp;&amp; haveEqualBirthdays; &#125; 方法文档 一个函数(方法)必须有一个字符串文档来解释，除非它： 非公开，私有函数。 很短。 显而易见。 而其余的，包括公开接口，重要的方法，分类，以及协议，都应该伴随文档（注释）： 以/开始 第二行识总结性的语句 第三行永远是空行 在与第二行开头对齐的位置写剩下的注释。 建议这样写： 12345/This comment serves to demonstrate the format of a doc string.Note that the summary line is always at most one line long, and after the opening block comment,and each line of text is preceded by a single space.*/ 看一个指定初始化方法的注释： 1234567/ * Designated initializer. * * @param store The store for CRUD operations. * @param searchService The search service used to query the store. * @return A ZOCCRUDOperationsStore object. */ - (instancetype)initWithOperationsStore:(id&lt;ZOCGenericStoreProtocol&gt;)store searchService:(id&lt;ZOCGenericSearchServiceProtocol&gt;)searchService; 多用队列，少用同步锁来避免资源抢夺 多个线程执行同一份代码时，很可能会造成数据不同步。建议使用GCD来为代码加锁的方式解决这个问题。 方案一：使用串行同步队列来将读写操作都安排到同一个队列里：1234567891011121314151617181920_syncQueue = dispatch_queue_create("com.effectiveobjectivec.syncQueue", NULL);//读取字符串- (NSString*)someString &#123; __block NSString *localSomeString; dispatch_sync(_syncQueue, ^&#123; localSomeString = _someString; &#125;); return localSomeString;&#125;//设置字符串- (void)setSomeString:(NSString*)someString &#123; dispatch_sync(_syncQueue, ^&#123; _someString = someString; &#125;);&#125; 这样一来，读写操作都在串行队列进行，就不容易出错。 但是，还有一种方法可以让性能更高： 方案二：将写操作放入栅栏快中，让他们单独执行；将读取操作并发执行。12345678910111213141516171819_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);//读取字符串- (NSString*)someString &#123; __block NSString *localSomeString; dispatch_sync(_syncQueue, ^&#123; localSomeString = _someString; &#125;); return localSomeString;&#125;//设置字符串- (void)setSomeString:(NSString*)someString &#123; dispatch_barrier_async(_syncQueue, ^&#123; _someString = someString; &#125;);&#125; 显然，数据的正确性主要取决于写入操作，那么只要保证写入时，线程是安全的，那么即便读取操作是并发的，也可以保证数据是同步的。这里的dispatch_barrier_async方法使得操作放在了同步队列里“有序进行”，保证了写入操作的任务是在串行队列里。 实现description方法打印自定义对象信息 在打印我们自己定义的类的实例对象时，在控制台输出的结果往往是这样的：object = &lt;EOCPerson: 0x7fd9a1600600&gt; 这里只包含了类名和内存地址，它的信息显然是不具体的,远达不到调试的要求。 但是！如果在我们自己定义的类覆写description方法，我们就可以在打印这个类的实例时输出我们想要的信息。 例如： 123- (NSString*)description &#123; return [NSString stringWithFormat:@"&lt;%@: %p, %@ %@&gt;", [self class], self, firstName, lastName];&#125; 在这里，显示了内存地址，还有该类的所有属性。 而且，如果我们将这些属性值放在字典里打印，则更具有可读性： 123456789- (NSString*)description &#123; return [NSString stringWithFormat:@"&lt;%@: %p, %@&gt;",[self class],self, @&#123; @"title":_title, @"latitude":@(_latitude), @"longitude":@(_longitude)&#125; ];&#125; 输出结果： 123456location = &lt;EOCLocation: 0x7f98f2e01d20, &#123; latitude = "51.506"; longitude = 0; title = London;&#125; 我们可以看到，通过重写description方法可以让我们更加了解对象的情况，便于后期的调试，节省开发时间。 NSArray&amp; NSMutableArray 1. addObject之前要非空判断。2. 取下标的时候要判断是否越界。3. 取第一个元素或最后一个元素的时候使用firtstObject和lastObjectNSCache 1. 构建缓存时选用NSCache 而非NSDictionary如果我们缓存使用得当，那么应用程序的响应速度就会提高。只有那种“重新计算起来很费事的数据，才值得放入缓存”，比如那些需要从网络获取或从磁盘读取的数据。 在构建缓存的时候很多人习惯用NSDictionary或者NSMutableDictionary，但是作者建议大家使用NSCache，它作为管理缓存的类，有很多特点要优于字典，因为它本来就是为了管理缓存而设计的。 2. NSCache优于NSDictionary的几点： 当系统资源将要耗尽时，NSCache具备自动删减缓冲的功能。并且还会先删减“最久未使用”的对象。 NSCache不拷贝键，而是保留键。因为并不是所有的键都遵从拷贝协议（字典的键是必须要支持拷贝协议的，有局限性）。 NSCache是线程安全的：不编写加锁代码的前提下，多个线程可以同时访问NSCache。 NSNotification 1. 通知的名称建议将通知的名字作为常量，保存在一个专门的类中： 12345// Const.hextern NSString * const ZOCFooDidBecomeBarNotification// Const.mNSString * const ZOCFooDidBecomeBarNotification = @"ZOCFooDidBecomeBarNotification"; 2. 通知的移除通知必须要在对象销毁之前移除掉。 其他 1. Xcode工程文件的物理路径要和逻辑路径保持一致。2. 忽略没有使用变量的编译警告对于某些暂时不用，以后可能用到的临时变量，为了避免警告，我们可以使用如下方法将这个警告消除： 12345- (NSInteger)giveMeFive &#123; NSString *foo; #pragma unused (foo) return 5; &#125; 3. 手动标明警告和错误手动明确一个错误：1234- (NSInteger)divide:(NSInteger)dividend by:(NSInteger)divisor &#123; #error Whoa, buddy, you need to check for zero here! return (dividend / divisor); &#125; 手动明确一个警告：12345678- (float)divide:(float)dividend by:(float)divisor &#123; #warning Dude, don't compare floating point numbers like this! if (divisor != 0.0) &#123; return (dividend / divisor); &#125; else &#123; return NAN; &#125; &#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS ImageView contentMode 图片填充模式]]></title>
    <url>%2F2019%2F07%2F12%2FiOS-ImageView-contentMode-%E5%9B%BE%E7%89%87%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[摘要： UIImageView的contentMode这个属性是用来设置图片的显示方式,如居中、居右,是否缩放等,系统给出的有枚举类型,以下示例图片比例大于imageViewUIViewContentModeScaleToFill,&lt;默认属性,图片根据imageView大小显示,会使图片变形&gt;根据视图的比例去拉伸图片内容UIViewContentModeScaleAspectFit,//contentsscaledtofitwithfixedaspect.remainde UIImageView的contentMode这个属性是用来设置图片的显示方式,如居中、居右,是否缩放等,系统给出的有枚举类型,以下示例图片比例大于imageView UIViewContentModeScaleToFill,&lt;默认属性,图片根据imageView大小显示,会使图片变形&gt; 根据视图的比例去拉伸图片内容 UIViewContentModeScaleAspectFit,/ /contents scaled to fit with fixed aspect. remainder is transparent (内容符合固定的方面。剩余部分是透明的) &lt;图片根据自身比例进行显示,图片小于imageView的部分会透明显示&gt; 保持图片内容的纵横比例,来适应视图的大小 UIViewContentModeScaleAspectFill,// contents scaled to fill with fixed aspect. some portion of content may be clipped.&lt;内容扩展填充固定方面。部分内容可能剪。&gt; &lt;图片按imageView大小比例居中显示,图片可能会失真并且不会显示完整,只显示中间部分&gt; 用图片内容来填充视图的大小,多余得部分可以被修剪掉来填充整个视图边界 UIViewContentModeRedraw,// redraw on bounds change (calls - setNeedsDisplay) &lt;重划边界变化(重设 - setNeedsDisplay)&gt; 这个选项是单视图的尺寸位置发生变化的时候通过调用setNeedsDisplay方法来重新显示 UIViewContentModeCenter,// contents remain same size. positioned adjusted.&lt;内容保持相同大小。定位调整&gt; 保持图片原比例在视图中间显示图片内容,如果视图大小小于图片的尺寸,则图片会超出视图边界,下面类同 UIViewContentModeTop, 保持图片原比例在视图中间顶部显示图片内容 UIViewContentModeBottom, 保持图片原比例在视图中间底部显示图片内容 UIViewContentModeLeft, 保持图片原比例在视图中间左边显示图片内容 UIViewContentModeRight, 保持图片原比例在视图中间右边显示图片内容 UIViewContentModeTopLeft, 保持图片原比例在视图左上角显示图片内容 UIViewContentModeTopRight, 保持图片原比例在视图右上角显示图片内容 UIViewContentModeBottomLeft, 保持图片原比例在视图左下角显示图片内容 UIViewContentModeBottomRight, 保持图片原比例在视图右下角显示图片内容]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS八种更新方式]]></title>
    <url>%2F2019%2F07%2F12%2FiOS%E5%85%AB%E7%A7%8D%E6%9B%B4%E6%96%B0%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、JSPatch热更新时，从服务器拉去js脚本。理论上可以修改和新建所有的模块，但是不建议这样做。建议 用来做紧急的小需求和 修复严重的线上bug。二、lua脚本比如： wax。热更新时，从服务器拉去lua脚本。游戏开发经常用到。三、Weex跨平台，一套代码，iOS、Android都可以运行。用前端语法实现原生效果。比React Native更好用。 weex基于vue.js，ReactNative使用React。 ReactNative安装配置麻烦。 weex安装cli之后就可以使用。 react模板JSX有一定的学习成本，vue和常用的web开发类似，模板是普通的html，数据绑定用mustache风格，样式直接使用css。 淘宝干的漂亮，中国在编码的实力越来越牛叉了。威武！！！ 四、React Native不像Weex能一套代码多端运行，需要自己分别做修改。 React Native 可以动态添加业务模块，但无法做到修改原生OC代码。 JSPatch、lua 配合React Native可以让一个原生APP时刻处于可扩展可修改的状态。 五、Hybrid像PhoneGap之类的框架, 基本概念和web差不多, 通过更新js/html来实现动态化，没有原生的效果流畅。 六、动态库可以做demo用，真实使用的时候会被苹果禁止。 因为 打包发到AppStore的ipa安装包 里的每个动态库 都有唯一的编码，iOS系统会进行验证，所以动态通过网络获取 新的动态库 也用不了。 七、rollout.ioRollout紧急修复线上bug。后端有相关的管理页面。因为是国外的网站，然后呢，要FQ才能使用。 八、DynamicCocoa滴滴iOS的一个框架，准备在2017年初开源，与JSPatch比更加智能化，用OC在XCode中写完代码，用工具可以自动生成可以更新的js文件。 转自 iOS热更新-8种实现方式]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>热更新</tag>
      </tags>
  </entry>
</search>
